
	<!doctype html>
	<html>
	<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Cabbage user Manual</title>
	<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='http://fonts.googleapis.com/css?family=Roboto+Condensed' rel='stylesheet' type='text/css'>
	<link href='./Styles/DocStyle.css' rel='stylesheet' type='text/css'>
	</head>
	<body>
	<input type="checkbox" id="menu-toggle" />
	<label for="menu-toggle" class="menu-icon"><i class="fa fa-bars"></i></label>
	<div class="content-container">
	</div>
	<div class="content"><h1>New Widgets, Part 3</h1>
<p>We now have a simple step sequencer that the user can click on to enable steps. They can also see which is the current step in the sequence. But it remains quite useless until we can get it to communicate with the underlying instance of Csound. Cabbage widgets communicate with Csound through the use of named channels. For example, whenever a sure moves a slider in Cabbage, the value of that slider gets sent to Csound over a named channel bus. Each widget that is capable of affecting change in a Csound instrument must have a channel associated with it. So our widget must also have an associated channel. We can retrieve the name of the channel by accessing the string passed to the channel identifier.  </p>
<pre><code class="csharp">class CabbageStepper    :   public Component, public Timer
{
    String name, channel;
    float numberOfSteps;
    int stepBPM, currentStep;
    Colour colour;
    Array&lt;int&gt; stepStates;

    public:

    CabbageStepper (CabbageGUIType &amp;cAttr, CabbagePluginAudioProcessorEditor* _owner)
        : Component(), 
        owner(_owner),
        name(cAttr.getStringProp(CabbageIDs::name)),
        channel(cAttr.getStringProp(CabbageIDs::channel)),
        colour(Colour::fromString(cAttr.getStringProp(CabbageIDs::colour))),
        stepBPM(cAttr.getNumProp(&quot;stepbpm&quot;)),
        numberOfSteps(cAttr.getNumProp(&quot;numberofsteps&quot;)),
        currentStep(0)
    {
(...)
</code></pre>

<h3>Sending messages to Csound channels</h3>
<p>An instance of Csound is created in the CabbagePluginAudioProcessor class, but we don't need to access it directly. We need only add some messages to the outgoing messages which are stored in CabbagePluginAudioProcesso::messageQueue. To access our main AudioProcessror class we can call the CabbagePluginAudioProcessorEditor::getFilter() method. We can then add some messages to the outgoing queue. At every k-boundary Cabbage will send the messages to Csound, this ensures complete thread safety. The best place to add messages to our queue is in the <strong>timerCallback()</strong> function. </p>
<pre><code class="csharp">void CabbageStepper::timerCallback()
{
    currentStep = currentStep&lt;11 ? currentStep+1 : 0;
    int valueToSendToCsound = stepStates[currentStep]==1 ? currentStep+1 : 0;
    owner-&gt;getFilter()-&gt;messageQueue.addOutgoingChannelMessageToQueue(channel, valueToSendToCsound, String::empty);
    repaint();
} 
</code></pre>

<p><strong>addOutgoingChannelMessageToQueue(...)</strong> takes three parameters. The first parameter is the name of the channel to communicate with Csound on. The next parameter is the value to send, and the final parameter is the message type, which is only used for special message types. In most cases this can be set to an empty string. </p>
<p>With this final method in place, Cabbage will send messages to Csound on each step. It will send a 0 if the step is disabled, otherwise it will send the step index+1. In order to use this widget with a Csound instrument we can do something like this.  </p>
<pre><code class="csharp">&lt;Cabbage&gt;
form size(500, 100), caption(&quot;Stepper&quot;), pluginID(&quot;plu1&quot;), colour(57, 110, 185)
stepper bounds(10, 10, 480, 40), channel(&quot;step1&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120)
&lt;/Cabbage&gt;
&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt; 
-m0d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 16
nchnls = 2
0dbfs=1

instr 1
if changed:k(chnget:k(&quot;step1&quot;))==1 &amp;&amp; chnget:k(&quot;step1&quot;)!=0 then
    event &quot;i&quot;, 2, 0, 3
endif
endin

instr 2
    print p1
    a1 expon 1, p3, 0.001
    a2 oscili a1, 256
    outs a2, a2
endin

&lt;/CsInstruments&gt;  
&lt;CsScore&gt;
i1 0 5000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</code></pre>

<p>Whenever channel "step1" changes, and is not equal to 0, we trigger instr 2 to play a note. </p>
<h3>Using Csound to control our widget</h3>
<p>Our new stepper widget serves as a good example of how easy it is to add new widget types to Cabbage, but it's still not quite ready for public consumption. There are still quite a few additions we could make to enhance the widget and provide users with a greater level of control. Perhaps the most important thing is to provide users with a way of turning the sequencer on or off. We could simply add a check box to our widget that will turn it on or off, but this will inevitably leads to problems if you wish to stack several steppers on top of each other. It would be very frustrating for the end-user if they have to enable each stepper widget manually. A better approach would be to provide them with a way of turning the sequence on or off from Csound. We can do this using identifier channels. </p>
<p>The <strong>CabbagePluginAudioProcessor::updateGUIControls()</strong> method checks for incoming identifier strings from Csound and gets called at every k-cycle. Identifier strings can be sent to a Cabbage widget using the chnset opcode in Csound. Once a string is sent, Cabbage parses it and updates the widget accordingly. Each widget that accepts identifier strings needs to implement an update(...) function. If you browse through the <strong>CabbagePluginAudioProcessor::updateGUIControls()</strong> code you'll seeing the following conditional statement. </p>
<pre><code class="csharp">    //sample stepper widget
    else if(checkForIdentifierMessage(getFilter()-&gt;getGUILayoutCtrls(i), &quot;stepper&quot;))
    {
        ((CabbageStepper*)layoutComps[i])-&gt;update(getFilter()-&gt;getGUILayoutCtrls(i));
        getFilter()-&gt;getGUILayoutCtrls(i).setStringProp(CabbageIDs::identchannelmessage, &quot;&quot;);
    }
</code></pre>

<p>The <strong>checkForIdentifierMessage(...)</strong> method checks for the existence of an identifier string for a particular widget type. If an incoming string identifier is found it calls the widget classes <strong>update(...)</strong> function.</p>
<h3>Writing an update function</h3>
<p>The update function gets passed a CabbageGUIType class object which provides us with all the information we need in order to update out widget. If for example we want to allow users to update the widget's colour from Csound we might do something like this in our <strong>update(...)</strong> method.</p>
<pre><code class="csharp">void CabbageStepper::update(CabbageGUIType cAttr)
{
    if(colour.toString()!=cAttr.getStringProp(&quot;colour&quot;))
    {
        colour = Colour::fromString(cAttr.getStringProp(&quot;colour&quot;));
    }
}
</code></pre>

<p>We can now change the colour of our widget using the following Cabbage/Csound code:</p>
<pre><code class="csharp">&lt;Cabbage&gt;
form size(500, 150), caption(&quot;Stepper&quot;), pluginID(&quot;plu1&quot;), colour(57, 110, 185)
stepper bounds(10, 10, 480, 40), channel(&quot;step1&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120), identchannel(&quot;stepIdent&quot;)
button bounds(12, 58, 120, 25), channel(&quot;colourButton&quot;), text(&quot;Change colour&quot;)
&lt;/Cabbage&gt;
&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt; 
-m0d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 16
nchnls = 2
0dbfs=1

instr 1
if changed:k(chnget:k(&quot;colourButton&quot;))==1 then
    if chnget:k(&quot;colourButton&quot;)==1 then
        chnset &quot;colour(255, 255, 0)&quot;, &quot;stepIdent&quot;
    else
        chnset &quot;colour(255, 255, 255)&quot;, &quot;stepIdent&quot;
    endif
endif

(...)
</code></pre>

<p><img alt="NewWidget3" src="images/newWidgetColourUpdate.gif"></p>
<p>It won't take much to update our <strong>update()</strong> function so that users can turn the step sequencer on and off, as well as control the tempo. We will need to add a new member variable to hold the running state of the widget. We can call it <strong>isRunning</strong>, and we will let users use the pre-existing <strong>active()</strong> identifier to set the running state. Our updated constructor will look like this.</p>
<pre><code class="csharp">CabbageStepper::CabbageStepper (CabbageGUIType &amp;cAttr, CabbagePluginAudioProcessorEditor* _owner)
        : Component(), 
        owner(_owner),
        name(cAttr.getStringProp(CabbageIDs::name)),
        channel(cAttr.getStringProp(CabbageIDs::channel)),
        colour(Colour::fromString(cAttr.getStringProp(CabbageIDs::colour))),
        stepBPM(cAttr.getNumProp(&quot;stepbpm&quot;)),
        numberOfSteps(cAttr.getNumProp(&quot;numberofsteps&quot;)),
        currentStep(0),
        isRunning(cAttr.getNumProp(CabbageIDs::active)==1 ? true : false)
{
    for(int i = 0; i &lt; numberOfSteps;i++ )
        stepStates.add(0);

    startTimer((60.f/stepBPM)*1000.f);
}
</code></pre>

<p>And our new <strong>update()</strong> function will now look like this.</p>
<pre><code class="csharp">void CabbageStepper::update(CabbageGUIType cAttr)
{
    if(cAttr.getNumProp(&quot;stepbpm&quot;)!=stepBPM)
    {
        stepBPM = cAttr.getNumProp(&quot;stepbpm&quot;);
    }

    if(cAttr.getNumProp(CabbageIDs::active)!=isRunning)
    {
        isRunning = cAttr.getNumProp(CabbageIDs::active);
        if(isRunning==1)
            startTimer((60.f/stepBPM)*1000.f);
        else
            stopTimer();
    }

    if(colour.toString()!=cAttr.getStringProp(&quot;colour&quot;))
        colour = Colour::fromString(cAttr.getStringProp(&quot;colour&quot;));
}
</code></pre>

<h3>Putting it all together</h3>
<p>Now that we have a way to turn on and off our widget we can create a more musically interesting instrument. We can for example stack several stepper widgets on top of each to create a simple grid sequencer. Below is a simple instrument demonstrating this. It uses a simple User Defined Opcode to enable and disable the steppers, but everything else is kept as simple as possible. </p>
<pre><code class="csharp">&lt;Cabbage&gt;
form size(500, 430), caption(&quot;Stepper&quot;), pluginID(&quot;plu1&quot;), colour(57, 110, 185)
button bounds(178, 345, 135, 31), channel(&quot;startButton&quot;), colour:1(&quot;lime&quot;), text(&quot;Start&quot;, &quot;Stop&quot;)
stepper bounds(10, 10, 480, 40), channel(&quot;c4&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120),  active(0), identchannel(&quot;stepIdent1&quot;) 
stepper bounds(10, 50, 480, 40), channel(&quot;b3&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120),  active(0), identchannel(&quot;stepIdent2&quot;)
stepper bounds(10, 90, 480, 40), channel(&quot;a3&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120),  active(0), identchannel(&quot;stepIdent3&quot;)
stepper bounds(10, 130, 480, 40), channel(&quot;g3&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120), active(0), identchannel(&quot;stepIdent4&quot;)
stepper bounds(10, 170, 480, 40), channel(&quot;f3&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120), active(0), identchannel(&quot;stepIdent5&quot;)
stepper bounds(10, 210, 480, 40), channel(&quot;e3&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120), active(0), identchannel(&quot;stepIdent6&quot;)
stepper bounds(10, 250, 480, 40), channel(&quot;d3&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120), active(0), identchannel(&quot;stepIdent7&quot;)
stepper bounds(10, 290, 480, 40), channel(&quot;c3&quot;), colour(&quot;white&quot;), numberofsteps(12), stepbpm(120), active(0), identchannel(&quot;stepIdent8&quot;)

rslider bounds(12, 340, 80, 80), channel(&quot;bpm&quot;), range(40, 180, 60), text(&quot;BPM&quot;), trackercolour(&quot;lime&quot;)
rslider bounds(92, 340, 80, 80), channel(&quot;gain&quot;), range(0, .7, .5), text(&quot;Gain&quot;), trackercolour(&quot;lime&quot;)

&lt;/Cabbage&gt;
&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt; 
-m0d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 16
nchnls = 2
0dbfs=1

opcode controlSteppers, k, kk
    kStart, kBPM xin
    SMessage sprintfk &quot;stepbpm(%d), active(%d)&quot;, kBPM, kStart
    chnset SMessage, &quot;stepIdent1&quot;
    chnset SMessage, &quot;stepIdent2&quot;
    chnset SMessage, &quot;stepIdent3&quot;
    chnset SMessage, &quot;stepIdent4&quot;
    chnset SMessage, &quot;stepIdent5&quot;
    chnset SMessage, &quot;stepIdent6&quot;
    chnset SMessage, &quot;stepIdent7&quot;
    chnset SMessage, &quot;stepIdent8&quot;
xout kStart
endop


;main instrument
instr 1
    ;check if user has pressed the start button
    kStartStop chnget &quot;startButton&quot;
    kTempo chnget &quot;bpm&quot;
    if changed:k(kStartStop)==1 || changed:k(kTempo)==1 then
        if chnget:k(&quot;startButton&quot;)==1 then
            k1 controlSteppers 1, kTempo
        else
            k1 controlSteppers 0, kTempo
        endif
    endif

    ;trigger notes according to which steps are activated
    if changed:k(chnget:k(&quot;c4&quot;))==1 &amp;&amp; chnget:k(&quot;c4&quot;)!=0 then
        event &quot;i&quot;, 2, 0, 3, cpsmidinn(72)
    elseif changed:k(chnget:k(&quot;b3&quot;))==1 &amp;&amp; chnget:k(&quot;b3&quot;)!=0 then
        event &quot;i&quot;, 2, 0, 3, cpsmidinn(71)
    elseif changed:k(chnget:k(&quot;a3&quot;))==1 &amp;&amp; chnget:k(&quot;a3&quot;)!=0 then
        event &quot;i&quot;, 2, 0, 3, cpsmidinn(69)
    elseif changed:k(chnget:k(&quot;g3&quot;))==1 &amp;&amp; chnget:k(&quot;g3&quot;)!=0 then
        event &quot;i&quot;, 2, 0, 3, cpsmidinn(67)
    elseif changed:k(chnget:k(&quot;f3&quot;))==1 &amp;&amp; chnget:k(&quot;f3&quot;)!=0 then
        event &quot;i&quot;, 2, 0, 3, cpsmidinn(65)
    elseif changed:k(chnget:k(&quot;e3&quot;))==1 &amp;&amp; chnget:k(&quot;e3&quot;)!=0 then
        event &quot;i&quot;, 2, 0, 3, cpsmidinn(64)
    elseif changed:k(chnget:k(&quot;d3&quot;))==1 &amp;&amp; chnget:k(&quot;d3&quot;)!=0 then
        event &quot;i&quot;, 2, 0, 3, cpsmidinn(62)
    elseif changed:k(chnget:k(&quot;c3&quot;))==1 &amp;&amp; chnget:k(&quot;c3&quot;)!=0 then
        event &quot;i&quot;, 2, 0, 3, cpsmidinn(60)
    endif

endin

;simple synthesiser 
instr 2
    print p1
    a1 expon chnget:i(&quot;gain&quot;), p3, 0.001
    a2 oscili a1, p4
    outs a2, a2
endin

&lt;/CsInstruments&gt;  
&lt;CsScore&gt;
i1 0 5000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</code></pre>

<p><img alt="NewWidget3" src="images/newWidgetFinished.gif"></p>
	  </div>
	</div>
	<div class="slideout-sidebar">
	<ul>
	<li><a href="index.html">Cabbage User Manual</a></li>
	<li><a href="csound.html">Beginners (Csound)</a><ul>
	<li><a href="file_structure_and_syntax.html">File Structure and Syntax</a></li>
	<li><a href="keywords.html">Keywords</a></li>
	<li><a href="constants_and_variables.html">Constants and Variables</a></li>
	<li><a href="opcodes.html">Opcodes</a></li>
	<li><a href="operators_and_comments.html">Operators and Comments</a></li>
	</ul>
	</li>
	<li><a href="introduction.html">Using Cabbage</a><ul>
	<li><a href="using_cabbage.html">Introduction</a></li>
	<li><a href="cabbage_syntax.html">Cabbage Syntax</a></li>
	<li><a href="beginner_synth.html">A simple Synthesiser</a></li>
	<li><a href="first_effect.html">A simple Effect</a></li>
	<li><a href="audio_graph.html">The Cabbage patcher</a></li>
	<li><a href="exporting.html">Exporting plugins</a></li>
	<li><a href="cabbage_in_host.html">Using plugins in 3rd Party software</a></li>
	<li><a href="distributing.html">Distributing instruments</a></li>
	</ul>
	</li>
	<li><a href="features.html">Features</a><ul>
	<li><a href="plants.html">Plants</a></li>
	<li><a href="identchannels.html">Controlling widgets with Csound</a></li>
	<li><a href="presets.html">Presets</a></li>
	<li><a href="widget_arrays.html">Widget arrays</a></li>
	<li><a href="macros_and_reserved_channels.html">Reserved channels and Macros</a></li>
	<li><a href="managing_large_numbers_of_widgets.html">Managing large numbers of Widgets</a></li>
	<li><a href="using_svgs.html">Using SVGs</a></li>
	<li><a href="soundfiles.html">Working with sound files</a></li>
	<li><a href="host_info.html">Getting host information into Csound</a></li>
	</ul>
	</li>
	<li><a href="cabbage_syntax.html">Widget Reference</a><ul>
	<li><a href="button.html">Button</a></li>
	<li><a href="button_file.html">Button(File)</a></li>
	<li><a href="button_info.html">Button(Info)</a></li>
	<li><a href="checkbox.html">Checkbox</a></li>
	<li><a href="combobox.html">Combobox</a></li>
	<li><a href="csound_output.html">Csound Output</a></li>
	<li><a href="encoder.html">Endless encoder</a></li>
	<li><a href="gentable.html">Gentable</a></li>
	<li><a href="form.html">Form</a></li>
	<li><a href="groupbox.html">Groupbox</a></li>
	<li><a href="hrange.html">Hrange</a></li>
	<li><a href="image.html">Image</a></li>
	<li><a href="keyboard.html">Keyboard</a></li>
	<li><a href="label.html">Labels</a></li>
	<li><a href="listbox.html">Listbox</a></li>
	<li><a href="meter.html">Meteres</a></li>
	<li><a href="numberbox.html">Numberbox</a></li>
	<li><a href="signaldisplay.html">SignalDisplay</a></li>
	<li><a href="sliders.html">Sliders</a></li>
	<li><a href="soundfiler.html">Soundfiler</a></li>
	<li><a href="textbox.html">Textbox</a></li>
	<li><a href="texteditor.html">Texteditor</a></li>
	<li><a href="vrange.html">Vrange</a></li>
	<li><a href="xypad.html">XY Pad</a></li>
	</ul>
	</li>
	<li><a href="add_new_widgets.html">Adding new Widgets</a><ul>
	<li><a href="new_widgets_part_1.html">Part 1</a></li>
	<li><a href="new_widgets_part_2.html">Part 2</a></li>
	<li><a href="new_widgets_part_3.html">Part 3</a></li>
	</ul>
	</li>
	</ul>

	</div>
	</body>
	</html>
	