<Cabbage>
form size(405, 90), caption("clip"), pluginid("Clip") style("legacy")
image        bounds(0, 0, 405, 90), colour( 20, 30, 40), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
rslider  bounds( 10, 11, 70, 70), text("Input Gain"), channel("InGain"), range(1, 10, 1, 0.5,0.01), colour(0,10,20), fontcolour("silver"), trackercolour("lightblue")
rslider  bounds( 75, 11, 70, 70), text("Limit"), channel("limit"), range(0.001, 1, 1, 0.5,0.001), colour(0,10,20), fontcolour("silver"), trackercolour("lightblue")
rslider  bounds(140, 11, 70, 70), text("Argument"), channel("arg"), range(0, 1.00, 0.5), colour(0,10,20), fontcolour("silver"), trackercolour("lightblue")
checkbox bounds(128,  7,  8,  8), channel("clip_light"), text("clip"), colour("red"), fontcolour("white"), shape("ellipse"), value(0), active(0)
label    bounds(137,  6, 25, 10), text("CLIP")
combobox bounds(210, 15, 80, 20), channel("method"), value(1), text("B.D.J.","Sine","Tanh")
checkbox bounds(210, 50, 15, 15), channel("GainComp"), text("Gain Compensation"), colour("lime"), fontcolour("white")
label    bounds(225, 52,100, 10), text("GAIN COMPENSATION")
rslider  bounds(325, 11, 70, 70), text("Level"), channel("level"), range(0.00, 10.00, 0.7), colour(0,10,20), fontcolour("silver"), trackercolour("lightblue")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 	= 	32		; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 	= 	2		; NUMBER OF CHANNELS (2=STEREO)
0dbfs	=	1

; Author: Iain McCurdy (2012)

instr	1
	kInGain	chnget	"InGain"
	kGainComp	chnget	"GainComp"
	klimit		chnget	"limit"
	kmethod	chnget	"method"
	kmethod	init	1
	karg		chnget	"arg"
	klevel		chnget	"level"
	asigL	=	inch:a(1) * kInGain
	asigR	=	inch:a(2) * kInGain

	; CLIP METER
	krmsL		=	rms:k(asigL,10) * 3
	krmsR		=	rms:k(asigR,10) * 3
	if ( trigger:k(krmsL,klimit,0)==1 || trigger:k(krmsR,klimit,0)==1 ) then
		chnset	k(1),"clip_light"
	elseif ( trigger:k(krmsL,klimit,1)==1 ||trigger:k(krmsR,klimit,1)==1 ) then
		chnset	k(0),"clip_light"
	endif

	if	changed(klimit,kmethod,karg)==1	then	; IF A VARIABLE CHANGE INDICATOR IS RECEIVED...
		reinit	UPDATE		; ...BEGIN A REINITIALISATION PASS FROM LABEL 'START' 
	endif				; END OF CONDITIONAL BRANCHING
	UPDATE:				; LABEL
	asigL		clip 		asigL, i(kmethod)-1, i(klimit), i(karg)
	asigR		clip 		asigR, i(kmethod)-1, i(klimit), i(karg)
	rireturn			; RETURN TO PERFORMANCE PASSES FROM INITIALISATION PASS
	if (kGainComp==1) then
	 asigL		=			asigL * (1/sqrt(klimit))
	 asigR		=			asigR * (1/sqrt(klimit))
	endif
			outs		asigL*klevel, asigR*klevel
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer><Cabbage>
form size(405, 90), caption("clip"), pluginid("Clip")  style("legacy") style("legacy")
image        bounds(0, 0, 405, 90), colour( 20, 30, 40), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
rslider  bounds( 10, 11, 70, 70), text("Input Gain"), channel("InGain"), range(1, 10, 1, 0.5,0.01), colour(0,10,20), fontcolour("silver"), trackercolour("lightblue")
rslider  bounds( 75, 11, 70, 70), text("Limit"), channel("limit"), range(0.001, 1, 1, 0.5,0.001), colour(0,10,20), fontcolour("silver"), trackercolour("lightblue")
rslider  bounds(140, 11, 70, 70), text("Argument"), channel("arg"), range(0, 1.00, 0.5), colour(0,10,20), fontcolour("silver"), trackercolour("lightblue")
checkbox bounds(128,  7,  8,  8), channel("clip_light"), text("clip"), colour("red"), fontcolour("white"), shape("ellipse"), value(0), active(0)
label    bounds(137,  6, 25, 10), text("CLIP")
combobox bounds(210, 15, 80, 20), channel("method"), value(1), text("B.D.J.","Sine","Tanh")
checkbox bounds(210, 50, 15, 15), channel("GainComp"), text("Gain Compensation"), colour("lime"), fontcolour("white")
label    bounds(225, 52,100, 10), text("GAIN COMPENSATION")
rslider  bounds(325, 11, 70, 70), text("Level"), channel("level"), range(0.00, 10.00, 0.7), colour(0,10,20), fontcolour("silver"), trackercolour("lightblue")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 	= 	32		; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 	= 	2		; NUMBER OF CHANNELS (2=STEREO)
0dbfs	=	1

; Author: Iain McCurdy (2012)

instr	1
	kInGain	chnget	"InGain"
	kGainComp	chnget	"GainComp"
	klimit		chnget	"limit"
	kmethod	chnget	"method"
	kmethod	init	1
	karg		chnget	"arg"
	klevel		chnget	"level"
	asigL	=	inch:a(1) * kInGain
	asigR	=	inch:a(2) * kInGain

	; CLIP METER
	krmsL		=	rms:k(asigL,10) * 3
	krmsR		=	rms:k(asigR,10) * 3
	if ( trigger:k(krmsL,klimit,0)==1 || trigger:k(krmsR,klimit,0)==1 ) then
		chnset	k(1),"clip_light"
	elseif ( trigger:k(krmsL,klimit,1)==1 ||trigger:k(krmsR,klimit,1)==1 ) then
		chnset	k(0),"clip_light"
	endif

	if	changed(klimit,kmethod,karg)==1	then	; IF A VARIABLE CHANGE INDICATOR IS RECEIVED...
		reinit	UPDATE		; ...BEGIN A REINITIALISATION PASS FROM LABEL 'START' 
	endif				; END OF CONDITIONAL BRANCHING
	UPDATE:				; LABEL
	asigL		clip 		asigL, i(kmethod)-1, i(klimit), i(karg)
	asigR		clip 		asigR, i(kmethod)-1, i(klimit), i(karg)
	rireturn			; RETURN TO PERFORMANCE PASSES FROM INITIALISATION PASS
	if (kGainComp==1) then
	 asigL		=			asigL * (1/sqrt(klimit))
	 asigR		=			asigR * (1/sqrt(klimit))
	endif
			outs		asigL*klevel, asigR*klevel
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>; LoFi.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form size(230, 120), caption("Lo Fi"), pluginid("lofi"), scrollbars(0) style("legacy")
image pos(0, 0), size(230, 120), colour(0,0,0), shape("sharp")
image   bounds( 30, 94, 30, 15), shape("rounded"), colour("black")
image   bounds( 85, 70, 60, 15), shape("rounded"), colour("black")
image   bounds(165, 94, 40, 15), shape("rounded"), colour("black")
rslider bounds(  5, 31, 80, 80), text("Bits"),     channel("bits"),  range(1, 16, 16),        textcolour("White"),    colour("orange"), trackercolour("brown"), outlinecolour("grey")
rslider bounds( 75,  7, 80, 80), text("Foldover"), channel("fold"),  range(1, 1024, 0, 0.25), textcolour("White"),    colour("orange"), trackercolour("brown"), outlinecolour("grey")
rslider bounds(145, 31, 80, 80), text("Level"),    channel("level"), range(0, 1.00, 1),       textcolour("White"),    colour("orange"), trackercolour("brown"), outlinecolour("grey")
}
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;Iain McCurdy, 2012
;http://iainmccurdy.org/csound.html


opcode	LoFi,a,akk
	ain,kbits,kfold	xin									;READ IN INPUT ARGUMENTS
	kvalues		pow		2, kbits					;RAISES 2 TO THE POWER OF kbitdepth. THE OUTPUT VALUE REPRESENTS THE NUMBER OF POSSIBLE VALUES AT THAT PARTICULAR BIT DEPTH
	aout		=	(int((ain/0dbfs)*kvalues))/kvalues	;BIT DEPTH REDUCE AUDIO SIGNAL
	aout		fold 	aout, kfold							;APPLY SAMPLING RATE FOLDOVER
		xout	aout									;SEND AUDIO BACK TO CALLER INSTRUMENT
endop

instr 1 
kbits chnget "bits"
kfold chnget "fold"
klevel chnget "level"
a1,a2	ins
kporttime	linseg	0,0.001,0.01
kfold	portk	kfold,kporttime
a1	LoFi	a1,kbits*0.6,kfold
a2	LoFi	a2,kbits*0.6,kfold
a1	=	a1 * klevel
a2	=	a2 * klevel
	outs	a1,a2
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pdclip.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("pdclip") size(380, 90), pluginid("pdcl") style("legacy")
label        bounds(  5,-12,380,100), colour(20,100,100, 0), fontcolour(70,150,150,200), text("pdclip"), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
image        bounds(  0,  0,380, 90), colour(10,100,200,200), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
rslider      bounds( 10, 11, 70, 70), text("Input Gain"),  channel("InGain"),  range(0, 5.00, 1,0.375),     textcolour("white"), colour(5, 30,80), trackercolour(255,255,25), outlinecolour(30,30,50)
rslider      bounds( 75, 11, 70, 70), text("Width"),  channel("width"),  range(0, 1.00, 0),     textcolour("white"), colour(5, 30,80), trackercolour(255,255,25), outlinecolour(30,30,50)
rslider      bounds(140, 11, 70, 70), text("Centre"), channel("center"), range(-1.00, 1.00, 0), textcolour("white"), colour(5, 30,80), trackercolour(255,255,25), outlinecolour(30,30,50)
rslider      bounds(300, 11, 70, 70), text("Level"),  channel("level"),  range(0, 1.00, 0.7),   textcolour("white"), colour(5, 30,80), trackercolour(255,255,25), outlinecolour(30,30,50)
combobox     bounds(215, 20, 80, 20), channel("bipolar"), value(2), text("Unipolar", "Bipolar")
checkbox     bounds(215, 48,130, 12), channel("TestTone"), FontColour("white"),  value(0), text("Sine Tone"), colour(yellow)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

gisine	ftgen	0,0,4096,10,1

instr	1
	kporttime	linseg	0,0.001,0.05				; portamento time ramps up from zero
	gkInGain	chnget	"InGain"			;READ WIDGETS...
	gkInGain	portk	gkInGain,kporttime
	gkwidth		chnget	"width"
	gkwidth		portk	gkwidth,kporttime
	gkcenter	chnget	"center"			;
	gkcenter	portk	gkcenter,kporttime
	gkbipolar	chnget	"bipolar"			;
	gkbipolar	init	1
	gkbipolar	=	gkbipolar-1
	gklevel		chnget	"level"				;
	gklevel		portk	gklevel,kporttime
	gkTestTone	chnget	"TestTone"
	if gkTestTone==1 then						; if test tone selected...
	 koct	rspline	4,8,0.2,0.5						
	 asigL		poscil	1,cpsoct(koct),gisine			; ...generate a tone
	 asigR		=	asigL					; right channel equal to left channel
	else								; otherwise...
	 asigL, asigR	ins						; read live inputs
	endif

	ifullscale	=	0dbfs	;DEFINE FULLSCALE AMPLITUDE VALUE
	kSwitch		changed		gkbipolar	;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
	if	kSwitch=1	then	;IF A VARIABLE CHANGE INDICATOR IS RECEIVED...
		reinit	START		;...BEGIN A REINITIALISATION PASS FROM LABEL 'START' 
	endif				;END OF CONDITIONAL BRANCHING
	START:				;LABEL
	;CLIP THE AUDIO SIGNAL USING pdclip
	aL		pdclip		asigL*gkInGain, gkwidth, gkcenter, i(gkbipolar)	; [, ifullscale]]
	aR		pdclip		asigR*gkInGain, gkwidth, gkcenter, i(gkbipolar)	; [, ifullscale]]
	rireturn			;RETURN TO PERFORMANCE PASSES FROM INITIALISATION PASS
	alevel		interp		gklevel
			outs		aL * alevel, aR * alevel		;pdclip OUTPUT ARE SENT TO THE SPEAKERS
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>


</CsoundSynthesizer>



























; Powershape.csd
; Iain McCurdy 2012
;
; Encapsulation of the powershape opcode used for wave distortion
;
; CONTROLS
; --------
; Test Tone	--	a glissandoing test tone
; Amount	--	amount of distortion
; Level		--	output level

<Cabbage>
form caption("Powershape") size(300,160), pluginid("pshp") style("legacy")
image               bounds(0, 0,300,160), colour("Brown"), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
checkbox bounds(10,  8,130, 12), channel("TestTone"), FontColour("white"),  value(0), text("Sine Tone"), colour(yellow)
hslider bounds(  5, 18,290, 40),          colour("white"), trackercolour("white"), channel("amount"), range(0.1, 1000, 1, 0.25,0.001)
label   bounds(129, 50, 40, 11), text("Amount"), fontcolour("white")
nslider  bounds(100, 65,100, 40), text("Amount [type]"),  channel("amount"),  range(0.1, 1000, 1,1,0.001), textcolour(white)
hslider bounds(  5,108,290, 40),          colour("white"), trackercolour("white"),  channel("level"),  range(0, 50, 0.5, 0.25,0.000001)    
label   bounds(135,140, 27, 11), text("Level"), fontcolour("white")
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

gisine	ftgen	0,0,4096,10,1 ;,0,1/2,0,1/4,0,1/8,0,1/16,0,1/32,0,1/64

instr	1
	kporttime	linseg	0,0.001,0.05				; portamento time ramps up from zero
	gkshape		chnget	"amount"				; READ WIDGETS...
	gkshape		portk	gkshape,kporttime
	gklevel		chnget	"level"					;
	gklevel		portk	gklevel,kporttime
	gklevel		portk	gklevel,kporttime
	gkTestTone	chnget	"TestTone"
	if gkTestTone==1 then						; if test tone selected...
	 koct	rspline	4,8,0.2,0.5						
	 asigL		poscil	1,cpsoct(koct),gisine			; ...generate a tone
	 asigR		=	asigL					; right channel equal to left channel
	else								; otherwise...
	 asigL, asigR	ins						; read live inputs
	endif
	ifullscale	=	0dbfs	;DEFINE FULLSCALE AMPLITUDE VALUE
	aL 		powershape 	asigL, gkshape, ifullscale	;CREATE POWERSHAPED SIGNAL
	aR 		powershape 	asigR, gkshape, ifullscale	;CREATE POWERSHAPED SIGNAL
	alevel		interp		gklevel
			outs		aL * alevel, aR * alevel		;WAVESET OUTPUT ARE SENT TO THE SPEAKERS
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>


</CsoundSynthesizer>



























; Compressor.csd
; Written by Iain McCurdy, 2016.

; Encapsulation of the compressor opcode

; A compressor is a dynamics processor that essentially applies waveshaping to an audio signal.
; In the case of a typical compressor, increasingly high dynamics will be increasingly attenuated thereby reducing the dynamic range of a signal.
; This can be useful in forcing a dynamically expressive signal to sit better within a mix of signals or for processing a final mix so that it functions better when listened to in an environment with background noise. 

; When reference is made to a soft knee, this is the part of the dynamic mapping function that separates the lower response region and the upper response region. 
; Below the 'knee' the dynamic tranformation is 1:1, i.e. no change. 

; Threshold	-	Lowest decibel level that will be allowed through. Can be used to remove low level noise from a signal. A setting of zero will defeat this feature.  
; Low Knee	-	Decibel point at which the 'soft knee' 
; High Knee	-	Decibel point at which the 'soft knee' terminates
; Attack	-	Attack time of the compressor
; Release	-	Release time of the compressor
; Ratio		-	Compression ratio of the upper compressor response region
; Lookahead	-	Essentially this is a delay that will be applied to the signal that will be compressed (the track signal will always be un-delayed).
;			This can be useful for making sure that the compressor responds appropriately to fast attacks (at the expense of some added latency by the delay).
;			This is an initialisation time parameter so making changes to it will interrupt the realtime audio stream
; Gain		-	A make-up gain control. Use this to compensate for loss of power caused by certain ocmpressor settings.

<Cabbage>
#define SLIDER_APPEARANCE trackercolour("DarkSlateGrey"), textcolour("black") 
form caption("Compressor") size(440,130), pluginid("Comp") style("legacy")
image            bounds(  0,  0,440,130), outlinethickness(6), outlinecolour("white"), colour("grey")
rslider bounds( 10, 10, 70, 70), channel("thresh"), text("Threshold"), range(0,120,0), $SLIDER_APPEARANCE
rslider bounds( 80, 10, 70, 70), channel("att"), text("Attack"),  range(0,1,0.01,0.5), $SLIDER_APPEARANCE
rslider bounds(150, 10, 70, 70), channel("rel"), text("Release"), range(0,1,0.05,0.5), $SLIDER_APPEARANCE
rslider bounds(220, 10, 70, 70), channel("ratio"), text("Ratio"), range(1,300,10000,0.5), $SLIDER_APPEARANCE
rslider bounds(290, 10, 70, 70), channel("look"), text("Lookahead"), range(0,1,0.01,0.5), $SLIDER_APPEARANCE
rslider bounds(360, 10, 70, 70), channel("gain"), text("Gain"), range(-36,36,0), $SLIDER_APPEARANCE
hrange   bounds( 10, 80,420, 30), channel("LowKnee","HighKnee"), range(0, 120, 48:60), $SLIDER_APPEARANCE
label    bounds( 10,108,420, 13), text("Soft Knee"), fontcolour("black")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

; Author: Iain McCurdy (2016)

instr 1
 aL,aR		ins									; read in live audio
 kthresh	chnget		"thresh"						; read in widgets
 kLowKnee	chnget		"LowKnee"
 kHighKnee	chnget		"HighKnee"
 katt		chnget		"att"
 krel		chnget		"rel"
 kratio 	chnget		"ratio"
 kgain	 	chnget		"gain"
 klook 		chnget		"look"  						; look-ahead time (this will have to be cast as an i-time variable)
 klook		init		0.01							
 if changed(klook)==1 then								; if slider is moved...
  reinit REINIT										; ... reinit
 endif
 REINIT:
 aC_L 	compress aL, aL, kthresh, kLowKnee, kHighKnee, kratio, katt, krel, i(klook)	; compress both channels
 aC_R 	compress aR, aR, kthresh, kLowKnee, kHighKnee, kratio, katt, krel, i(klook)
 aC_L	*=	ampdb(kgain)								; apply make up gain
 aC_R	*=	ampdb(kgain)
	outs	aC_L,aC_R
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]									; play instr 1 for 1 week
</CsScore>

</CsoundSynthesizer>; Compressor/Expander.csd
; Written by Iain McCurdy, 2015.

; A dynamics processor
; Read point on the transfer function is indicated by a moving dot.

; Threshold	-	threshold point at which the main dynamics processing curve begins
; Compress	-	degree of dynamic compression of the dynamic area beneath the threshold
; Curve		-	curve of the main dynamics processing segment
; Ceiling	-	dynamic ceiling. Shifts main dynamic curve to the left in the transfer function.
; Attack	-	Attack time of the dynamic tracker. Increase to smooth out dynamic changes carried out.
; Release	-	Release time of the dynamic tracker. Increase to smooth out dynamic changes carried out.
; Smoothing	-	A lowpass filter is applied to the output gain function. increasing 'Smoothing' will smooth changes in dynamics.
;			This is in addition to the attack and release parameters used in the follow2 opcode but may produce nicer smoothing.
; Pre-gain	-	Boost the input signal before dynamic tracking takes place. 
;			This does not affect the output level but merely forces reading further across the transfer function - this is confirmed by observing the dot on the graph. 
; Sensitivity	-	Adjusts the range of dynamic change the effect will apply (without having to adjust the transfer function.  
; Mix		-	Dry/wet mix. This should normally be set at maximum '1' but switching back to '0' (dry) may be informative in auditioning changes.  
; Level		-	Output level

<Cabbage>
form caption("Compressor/Expander") size(890, 100), pluginid("CoEx") style("legacy")
image                       bounds(0, 0, 890, 100), colour("tan"), shape("rounded"), outlinecolour("white"), outlinethickness(6)
rslider  bounds( 10, 13, 75, 75), text("Threshold"), channel("thresh"), range(0,1,0.143,0.5,0.001),     textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds( 80, 13, 75, 75), text("Compress"),  channel("comp"),   range(0,1,0.25),               textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(150, 13, 75, 75), text("Curve"),     channel("curve"),  range(-20,20,2.6),             textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(220, 13, 75, 75), text("Ceiling"),   channel("ceil"),   range(0,1,0),                 textcolour("black"), colour(37,59,59), trackercolour("Silver")
gentable bounds(300, 10, 80, 80), tablenumber(1), tablecolour("black"), identchannel("table"), amprange(0,1,-1), zoom(-1), tablegridcolour(white), tablebackgroundcolour(white), outlinethickness(1)
image    bounds(0, 0, 6, 6), colour("black"), shape("ellipse"), outlinethickness(0), identchannel("Dot")
rslider  bounds(385, 13, 75, 75), text("Attack"),    channel("att"),    range(0.01,1,0.3,0.5,0.01),   textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(455, 13, 75, 75), text("Release"),   channel("rel"),    range(0.01,1,0.3,0.5,0.01),   textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(525, 13, 75, 75), text("Smoothing"), channel("smooth"), range(0.01,1,0.1,0.5,0.001),  textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(595, 13, 75, 75), text("Pre-gain"),  channel("PreGain"),range(0.5,10,2.4,0.5,0.001),  textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(665, 13, 75, 75), text("Sensitivity"),channel("sense"), range(1,10,3),               textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(735, 13, 75, 75), text("Mix"),       channel("mix"),    range(0,1,1),                 textcolour("black"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(805, 13, 75, 75), text("Level"),     channel("lev"),    range(0,5,0.5,0.5,0.001),     textcolour("black"), colour(37,59,59), trackercolour("Silver")

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1


instr 1
 kthresh	chnget "thresh"
 kcomp		chnget "comp"
 kcurve	 	chnget "curve"
 kceil	 	chnget "ceil"
 katt	 	chnget "att"
 krel	 	chnget "rel"
 ksmooth 	chnget "smooth"
 kPreGain 	chnget "PreGain"
 ksense 	chnget "sense" 
 kmix	 	chnget "mix"
 klev	 	chnget "lev"
 
 kpeg	metro	2				; maximum rate at which table will be rebuilt upon receipt of changes to Threshold, Compress, Curve or Ceiling
 if kpeg==1 then
  if changed(kthresh,kcomp,kcurve,kceil)==1 then
   reinit REBUILD_TABLE
  endif
 endif
 REBUILD_TABLE:
 icurve		=	i(kcurve)
 ithresh	=	i(kthresh)
 iTabLen	=	4096
 ithreshi	=	int(iTabLen*ithresh)	; threshold as a table point x value
 irem		=	iTabLen-ithreshi	; remainder table points
 iceil		=	i(kceil)
 irem1		=	int(irem*(1-iceil))
 irem2		=	irem-irem1
 icomp		=	i(kcomp)
 giTransferFunc	ftgen 1, 0, iTabLen, 16, 0, ithreshi, 0, ithresh*icomp, irem1, icurve, 1, irem2, 0, 1
 chnset	"tablenumber(1)","table"
 
 aL,aR	ins
 ;aL,aR	diskin2	"ClassicalGuitar.wav",1,0,1
 
 aFollow	follow2		(aL+aR)*kPreGain,katt,krel
 ;aFollow	pow	aFollow,0.5
 kRMS		downsamp	aFollow

 /* apply transfer function */
 aMap	table	aFollow,giTransferFunc,1		; read transfer function value
 aDiff	=	1+(aMap-aFollow)			; divergence from flat dynamic response 
 aDiff	pow	aDiff,ksense				; raising to a power greater than 1 increases range of change: greater attenuation, greater amplification
 aDiff	tone	aDiff,1/ksmooth				; smoothing. This is in addition to the attack and release parameters used in the follow2 opcode but may produce nicer smoothing. Reduce this value for greater smoothing, increase it for less.
 aDynL	=	aL * aDiff				; apply dynamic change
 aDynR	=	aR * aDiff
 aMixL	ntrpol	aL,aDynL,kmix				; dry / wet mix
 aMixR	ntrpol	aR,aDynR,kmix
 	outs	aMixL*klev, aMixR*klev			; send audio to outputs

 /* DISPLAY */
 if metro(ksmps*0.5)==1 then
  kx	limit	kRMS,0,1				; limit x position
  ky	table	kx,giTransferFunc,1			; derice y position (0 to 1)
  Smsg	sprintfk	"pos(%d,%d)", 297+int(kx*80),7+(80-int(ky*80))	; create message string
  	chnset	Smsg,"Dot"				; send message string to gentable widget
 endif

endin

</CsInstruments>

<CsScore>                                              
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>                                                  ; Exciter.csd
; Written by Iain McCurdy, 2015.
                
; An exciter is a device that uses harmonic distortion to add a high frequency shimmer to a signal. It is a common tool in mastering.
; Csound includes an opcode called 'exciter' which is an implementation of the 'Calf' exciter plugin. 
; 'Frequency' and 'Ceiling' define the frequency range across which harmonics will be created.      
; We also have control over the amount of harmonics created and the blend between the 2nd and 3rd order harmonics. 
; The effect of these parameters is subtle and the user might find it useful to at first set 'Dry/Wet Mix' to maximum (100% wet) in order to hear the effect more clearly.
             
<Cabbage>
form caption("Exciter") size(445, 100), pluginid("Ectr") style("legacy")
image           bounds(0, 0, 445, 100), colour("LightSlateGrey"), shape("rounded"), outlinecolour("white"), outlinethickness(6)
rslider  bounds( 10, 13, 75, 75), text("Frequency"), channel("freq"), range(20,20000,3000,0.5),  textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds( 80, 13, 75, 75), text("Ceiling"), channel("ceil"), range(20,20000,20000,0.5), textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(150, 13, 75, 75), text("Harmonics"), channel("harms"), range(0.1,10.00,10),     textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(220, 13, 75, 75), text("Blend"), channel("blend"), range(-10,10,10,0.5,0.0001),     textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(290, 13, 75, 75), text("Mix"), channel("mix"), range(0, 1.00, 0.5),      textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(360, 13, 75, 75), text("Level"), channel("level"), range(0, 1.00, 0.5),      textcolour("white"), colour(37,59,59), trackercolour("Silver")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1



instr 1
 kporttime	linseg	0,0.001,0.05  			; ramping up value used for portamento time                                                   
 kfreq	chnget "freq"					; read in widgets
 kceil	chnget "ceil"
 kharms chnget "harms"
 kblend	chnget "blend"
 klevel chnget "level"
 kmix  	chnget "mix"
 kmix	portk	kmix,kporttime
 klevel	portk	klevel,kporttime
 
 a1,a2	ins
; a1,a2	diskin2	"ClassicalGuitar.wav",1,0,1		; test with a sound file
 
 aE1	exciter a1, kfreq, kceil, kharms, kblend
 aE2	exciter a1, kfreq, kceil, kharms, kblend

 a1	ntrpol	a1, aE1, kmix				; dry/wet mix
 a2	ntrpol	a2, aE2, kmix
 	outs	a1*klevel, a2*klevel			; send to outputs and apply amplitude level control
endin

</CsInstruments>

<CsScore>                                              
i 1 0 [60*60*24*7]					; play note for a week
</CsScore>

</CsoundSynthesizer>                                                  ; Gate.csd
; Written by Iain McCurdy, 2015.

; Two 'Processing Configutions' are available:
;  'Stereo Mixed' 		-	the two input channels are mixed before being sent to a single envelope follower. 
;					Subsequent processing (gating filtering) is still carried out on the stereo input, just the gate open/closed control data will be the same on both channels
;  'Stereo Separate' 		-	the two input channels are sent to independent envelope followers. 
;					Therefore gate open/closed control data for the two channels can differ.  
; Right Channel Sidechain	-	In this mode, the gate is triggered by the signal received in the right channel but the gated signal is the left channel 

; Input signal is sent to an envelope follower and a gate state (open/closed) is assessed according to user defined thresholds.
; Independent thresholds and time durations can be defined for gate opening and closing.

; Pre-filter filters the input signal through a highpass filter and lowpass filter in series. 
; (Note this is only the signal sent into the envelope follower and the signal sent to the actual gate and the then the output is unfiltered.)
; This feature can be used to fine tune gate opening for particular frequency bands. 
; E.G. Opening for a voice singing but not for low frequency rumble picked up through the microphone stand. 

; The 'Filter Gate' can gate the signal using a lowpass filter (either 12 dB/oct or 24 dB/oct). 
; The user sets the 'Min.' (gate closed) and 'Max.' (gate open) cutoff values for the filter (in oct format)

; 'Atten.' sets the amount of amplitude attenuation to be applied.
; 'Delay' delays the audio (after envelope following but before gating is applied)
;	This can be used to recover the attack of a sound, particularly if the attack time of the gate is long.
;	If delay time is zero then the delay is completely bypassed.  
                                                                       
<Cabbage>                                                                                                                   
form caption("Gate"), colour( 20, 20, 30), size(430, 305), pluginid("Gate"), scrollbars(0) style("legacy")

image     bounds(  5, 10,420, 40), shape("sharp"), outlinecolour("white"), colour(0,0,0,0), outlinethickness(1), plant("Input") {
label     bounds( 20, 10,180, 14), fontcolour("white"), text("Processing Configuration:"), colour(0,0,0,0), align("right")
combobox  bounds(202, 10,180, 16), channel("InputMode"), text("Stereo Mixed","Stereo Separate","Right Channel Side Chain"), value(1), colour( 70, 70, 70), fontcolour("white")
}

image     bounds(  5, 55,207, 90), shape("sharp"), outlinecolour("white"), colour(0,0,0,0), outlinethickness(1), plant("OnThresh") {
label     bounds(  0,  5,207, 12), fontcolour("white"), text("On Threshold"), colour(0,0,0,0)
rslider   bounds( 10, 20, 60, 60), range(0,0.1,0.01,0.5,0.0001),  channel("OnThresh"), text("Level"), textcolour("white")
nslider bounds( 65, 35, 45, 15), channel("OnThresh_dB"), range(-90,120,-90,1,0.1)
label     bounds(110, 37, 20, 12), fontcolour("white"), text("dB"), colour(0,0,0,0)
rslider   bounds(135, 20, 60, 60), range(0,0.3,0.04,0.5,0.0001),  channel("AttTime"), text("Time"), textcolour("white")
}

image     bounds(218, 55,207, 90), shape("sharp"), outlinecolour("white"), colour(0,0,0,0), outlinethickness(1), plant("OffThresh") {
label     bounds(  0,  5,207, 12), fontcolour("white"), text("Off Threshold"), colour(0,0,0,0)
rslider   bounds( 10, 20, 60, 60), range(0,0.1,0.007,0.5,0.0001),  channel("OffThresh"), text("Level"), textcolour("white")
nslider bounds( 65, 35, 45, 15), channel("OffThresh_dB"), range(-90,120,-90,1,0.1)
label     bounds(110, 37, 20, 12), fontcolour("white"), text("dB"), colour(0,0,0,0)
rslider   bounds(135, 20, 60, 60), range(0,0.3,0.03,0.5,0.0001),  channel("RelTime"), text("Time"), textcolour("white")
}

image    bounds(  5,150,420, 50), shape("sharp"), outlinecolour("white"), colour(0,0,0,0), outlinethickness(1), plant("PreFilter") {
checkbox bounds( 10, 15, 70, 12), channel("PreFiltOnOff"), text("Pre-Filter"), fontcolour("white")
;hslider2 bounds( 85,  0,330, 40), channel("HPF","LPF"), min(200), max(12000), range(20,20000, 0, 0.5, 1), identchannel("Filter")
hrange   bounds(  85,  5,330, 20), channel("HPF","LPF"), range(20, 20000, 200:12000, 0.5, 1), identchannel("Filter")
label    bounds( 85, 30,330, 12), text("Highpass / Lowpass"), fontcolour("white"), identchannel("FilterL")
}

image    bounds(  5,205,210, 95), shape("sharp"), outlinecolour("white"), colour(0,0,0,0), outlinethickness(1), plant("FilterGate") {
label    bounds(  5, 22, 80, 12), text("Filter Gate"), fontcolour("white")
combobox bounds(  5, 35, 80, 20), channel("FilterGate"), text("Bypass","12 dB/Oct","24 dB/Oct"), value(1)
rslider  bounds( 75,  5, 80, 80), range(2,14,2,0.5,0.01),  channel("FiltGateMin"), text("Min"), textcolour("white"), textbox(1)
rslider  bounds(135,  5, 80, 80), range(2,14,14,0.5,0.01),  channel("FiltGateMax"), text("Max"), textcolour("white"), textbox(1)
}

image    bounds(220,205,205, 95), shape("sharp"), outlinecolour("white"), colour(0,0,0,0), outlinethickness(1), plant("Master") {
checkbox bounds( 14, 30, 15, 13), channel("GateIndicOp"), shape("ellipse"), colour( 50,255, 50), active(0)
checkbox bounds( 14, 50, 15, 13), channel("GateIndicCl"), shape("ellipse"), colour(255, 50, 50), value(1), active(0)
rslider  bounds( 20,  5, 80, 80), range(0,90,90,0.5,0.1),  channel("Atten"), text("Atten."), textcolour("white"), textbox(1)
rslider  bounds( 75,  5, 80, 80), range(0,0.1,0,0.8,0.001),  channel("DelTim"), text("Delay"), textcolour("white"), textbox(1)
rslider  bounds(130,  5, 80, 80), range(0,2,1,0.5,0.01),  channel("Gain"), text("Gain"), textcolour("white"), textbox(1)
}

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n
</CsOptions>

<CsInstruments>

sr	=	44100
ksmps	=	32
nchnls	=	2
0dbfs	=	1

;Author: Iain McCurdy (2015)

opcode	SwitchPort, k, kkk
	kin,kupport,kdnport	xin
	kold			init	0
	kporttime		=	(kin<kold?kdnport:kupport)
	kout			portk	kin, kporttime
	kold			=	kout
				xout	kout
endop

instr	1
 /* READ IN WIDGETS */
 kOnThresh	chnget	"OnThresh"
 kOffThresh	chnget	"OffThresh"
 kAttTime	chnget	"AttTime"
 kRelTime	chnget	"RelTime"
 kAtten		chnget	"Atten"
 kGain		chnget	"Gain"
 kFilterGate	chnget	"FilterGate"
 kFiltGateMin	chnget	"FiltGateMin"
 kFiltGateMax	chnget	"FiltGateMax"
 kInputMode	chnget	"InputMode"
 kHPF		chnget	"HPF"
 kLPF		chnget	"LPF"
 kPreFiltOnOff		chnget	"PreFiltOnOff"
 kDelTim	chnget	"DelTim"
 
 kporttime	linseg	0,0.001,0.05		;
 kGain		portk	kGain,kporttime

 /* INPUT */
 ;aL,aR	diskin2	"029_HPF.wav",1,0,1	; use diskin for testing
 aL,aR	ins
 
 /* SHOW OR HIDE PRE-FILTER SLIDERS */
 if changed(kPreFiltOnOff)==1 then
  if kPreFiltOnOff==1 then
   	chnset	"visible(1)","Filter"
   	chnset	"visible(1)","FilterL"
  else
   	chnset	"visible(0)","Filter"  
   	chnset	"visible(0)","FilterL"  
  endif
 endif
 


 /* STEREO MIX MODE */
 if kInputMode==1 then
 
  aInSig	sum	aL,aR		; mix left and right inputs

  if kPreFiltOnOff==1 then		; if pre-filter switch is on...
   aInSig	buthp	aInSig,kHPF	; highpass filter
   aInSig	buthp	aInSig,kHPF	; and again to steepen slope
   aInSig	butlp	aInSig,kLPF	; lowpass filter
   aInSig	butlp	aInSig,kLPF	; and again to steepen slope
  endif


  kRMS	rms	aInSig			; scan rms of input signal

  /* OPEN AND CLOSE GATE*/
  kGate	init	1
  if kRMS < kOffThresh && kGate ==1 then
   kGate	=	0
  elseif kRMS >= kOnThresh && kGate == 0 then
   kGate	=	1
  endif
  
  /* TURN GATE STATUS INDICATORS ON AND OFF */
  if changed(kGate)==1 then
  	chnset	1-kGate,"GateIndicCl"
  	chnset	kGate,"GateIndicOp"
  endif
   
  /* SMOOTH GATE OPENING AND CLOSING (CALL UDO) */
  kGateD SwitchPort kGate, kAttTime, kRelTime	; smooth opening and closing
  
  /* AMPLITUDE GATE */
  kGateDA	scale	kGateD,1,ampdb(-kAtten)	; modify gating function according to user defined attenuation setting
  aGate	interp	kGateDA				; create an arate version (smoother)
    
  /* DELAY */
  if kDelTim>0 then
   aL	vdelay	aL, kDelTim*1000, 100
   aR	vdelay	aR, kDelTim*1000, 100
  endif
   
  /* APPLY GATE */
  aL	*=	aGate
  aR	*=	aGate
  
  /* FILTER GATE */
  if kFilterGate>1 then				
   kcfoct	scale	kGateD,kFiltGateMax,kFiltGateMin
   acf	interp	cpsoct(kcfoct)
   if kFilterGate==2 then
    aL	tone	aL,acf
    aR	tone	aR,acf
   else
    aL	butlp	aL,acf
    aR	butlp	aR,acf
   endif
  endif
    
    
    
    
    
 /* STEREO SEPARATE MODE */
 elseif kInputMode==2 then
 
 aInSigL	=	aL
 aInSigR	=	aR

  if kPreFiltOnOff==1 then
   aInSigL	buthp	aInSigL,kHPF
   aInSigL	buthp	aInSigL,kHPF
   aInSigL	butlp	aInSigL,kLPF
   aInSigL	butlp	aInSigL,kLPF
   aInSigR	buthp	aInSigR,kHPF
   aInSigR	buthp	aInSigR,kHPF
   aInSigR	butlp	aInSigR,kLPF
   aInSigR	butlp	aInSigR,kLPF
  endif


  kRMSL	rms	aInSigL*2
  kRMSR	rms	aInSigR*2

  kGateL,kGateR	init	1

  if kRMSL < kOffThresh && kGateL ==1 then
   kGateL	=	0
  elseif kRMSL >= kOnThresh && kGateL == 0 then
   kGateL	=	1
  endif

  if kRMSR < kOffThresh && kGateR ==1 then
   kGateR	=	0
  elseif kRMSR >= kOnThresh && kGateR == 0 then
   kGateR	=	1
  endif
  
  if changed(kGateL)==1 then
  	chnset	1-kGateL,"GateIndicCl"
  	chnset	kGateL,"GateIndicOp"
  endif
   
  kGateDL SwitchPort kGateL, kAttTime, kRelTime	; smooth opening and closing
  kGateDR SwitchPort kGateR, kAttTime, kRelTime	; smooth opening and closing
  
  kGateDAL	scale	kGateDL,1,ampdb(-kAtten)
  kGateDAR	scale	kGateDR,1,ampdb(-kAtten)
  
  aGateL	interp	kGateDAL
  aGateR	interp	kGateDAR
   
  /* DELAY */
  if kDelTim>0 then
   aL	vdelay	aL, kDelTim*1000, 100
   aR	vdelay	aR, kDelTim*1000, 100
  endif
   
  /* APPLY GATE */
  aL	*=	aGateL
  aR	*=	aGateR
  
  if kFilterGate>1 then
   kcfoctL	scale	kGateDL,kFiltGateMax,kFiltGateMin
   kcfoctR	scale	kGateDR,kFiltGateMax,kFiltGateMin
   acfL	interp	cpsoct(kcfoctL)
   acfR	interp	cpsoct(kcfoctR)
   if kFilterGate==2 then
    aL	tone	aL,acfL
    aR	tone	aR,acfR
   else
    aL	butlp	aL,acfL
    aR	butlp	aR,acfR
   endif
  endif



 ; Right Channel Side Chain
 else
 
  if kPreFiltOnOff==1 then		; if pre-filter switch is on...
   aR	buthp	aR,kHPF	; highpass filter
   aR	buthp	aR,kHPF	; and again to steepen slope
   aR	butlp	aR,kLPF	; lowpass filter
   aR	butlp	aR,kLPF	; and again to steepen slope
  endif


  kRMS	rms	aR			; scan rms of input signal

  /* OPEN AND CLOSE GATE*/
  kGate	init	1
  if kRMS < kOffThresh && kGate ==1 then
   kGate	=	0
  elseif kRMS >= kOnThresh && kGate == 0 then
   kGate	=	1
  endif
  
  /* TURN GATE STATUS INDICATORS ON AND OFF */
  if changed(kGate)==1 then
  	chnset	1-kGate,"GateIndicCl"
  	chnset	kGate,"GateIndicOp"
  endif
   
  /* SMOOTH GATE OPENING AND CLOSING (CALL UDO) */
  kGateD SwitchPort kGate, kAttTime, kRelTime	; smooth opening and closing
  
  /* AMPLITUDE GATE */
  kGateDA	scale	kGateD,1,ampdb(-kAtten)	; modify gating function according to user defined attenuation setting
  aGate	interp	kGateDA				; create an arate version (smoother)
    
  /* DELAY */
  if kDelTim>0 then
   aL	vdelay	aL, kDelTim*1000, 100
  endif
   
  /* APPLY GATE */
  aL	*=	aGate
  
  /* FILTER GATE */
  if kFilterGate>1 then				
   kcfoct	scale	kGateD,kFiltGateMax,kFiltGateMin
   acf	interp	cpsoct(kcfoct)
   if kFilterGate==2 then
    aL	tone	aL,acf
   else
    aL	butlp	aL,acf
   endif
  endif
  aR	=	aL

 endif
 	outs	aL*kGain, aR*kGain

endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; Limiter.csd
; Written by Iain McCurdy, 2016.

; A simple 'brick-wall' limiter

; Threshold	-	dB threshold below above which signals will be aggressively limited
; Smoothing	-	response of the amplitude follower. Higher values result in a slower, but possibly smoother, response
; Delay		-	delay applied to the input sound before it is limited (the tracked signal is always undelayed)
;			This can be useful for compensating for a limiter than is not responding fast enough to sudden dynamic transients 
; Gain		-	Make up gain. Useful for compensating for gain loss.
   
<Cabbage>
#define SLIDER_APPEARANCE textcolour("black"), trackercolour("LightSlateGrey")
form caption("Limiter") size(435,105), pluginid("lmtr") style("legacy")
image         bounds(  0,  0,435,105), outlinethickness(6), outlinecolour("white"), colour("silver")
rslider  bounds( 10,15, 80, 80), channel("thresh"), text("Threshold [dB]"), range(-120,0,-24), $SLIDER_APPEARANCE
rslider  bounds( 90,15, 80, 80), channel("smooth"), text("Smoothing"), range(0.01,1,0.1,0.5), $SLIDER_APPEARANCE
rslider  bounds(170,15, 80, 80), channel("delay"), text("Delay [s]"), range(0,0.2,0,0.5), $SLIDER_APPEARANCE
rslider  bounds(250,15, 80, 80), channel("gain"), text("Gain [dB]"), range(-48,48,0), $SLIDER_APPEARANCE
checkbox bounds(335,35,100, 20), channel("limiting"), text("Limiting"), shape("ellipse"), colour("red"), fontcolour("black"), active(0)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

; Author: Iain McCurdy (2016)

instr 1
 aL,aR		ins							; read live audio in
 kthresh	chnget		"thresh" 		; read in widgets
 ksmooth	chnget		"smooth" 		; this is needed as an i-time variable so will have to be cast as an i variable and a reinitialisation forced
 kthresh	=		ampdbfs(kthresh)	; convert threshold to an amplitude value
 if changed(ksmooth)==1 then			; if Smoothing slider is moved...
  reinit REINIT							; ... force a reinitialisation
 endif
 REINIT:								; reinitialise from here
 krmsL		rms		aL,1/i(ksmooth)		; scan both channels
 krmsR		rms		aR,1/i(ksmooth)		; ...
 rireturn								; return to performance pass from reinitialisation pass (if applicable)
 krms		max		krmsL,krmsR			; but only used the highest rms

 kdelay		chnget	"delay"				
 if kdelay>0 then						; if Delay value is anything above zero ...
  aL	vdelay	aL, kdelay*1000, 200	; delay audio signals before limiting
  aR	vdelay	aR, kdelay*1000, 200
 endif

 if krms>kthresh then					; if current RMS is above threshold; i.e. limiting required
  kfctr		=	kthresh/krms			; derive less than '1' factor required to attenuate audio signal to limiting value
  afctr		interp	kfctr				; smooth changes (and interpolate from k to a)
  aL_L		=	aL * afctr			; apply scaling factor
  aL_R		=	aR * afctr
  klimiting	=	1				; switch value used by GUI indicator (on)
 else
  aL_L		=	aL				; pass audio signals unchanged
  aL_R		=	aR				; ...
  klimiting	=	0				; switch value used by GUI indicator (off)
 endif

 kgain		chnget	"gain"				; make up gain control
 kgain		=	ampdb(kgain)			; derive gain value as an amplitude factor
 aL_L		*=	kgain				; make up gain
 aL_R		*=	kgain

 if metro(16)==1 then					; peg rate if updates of limiting indicator (to save a bit of CPU)
  		chnset	klimiting,"limiting"		; send value for limiting indicator
 endif

	outs	aL_L, aL_R				; send limited audio signals to outputs
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>; BandFilter.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("Band Filter"), colour(10,10,10), size(470, 360), pluginid("BdFl") style("legacy")
xypad bounds(5, 5, 350, 350), channel("cf", "bw"), rangex(0, 1, 0.5), rangey(0, 1, 0.3), text("x:cutoff | y:bandwidth"), colour(200,200,200)
checkbox bounds(370, 10, 20, 20), channel("balance"), FontColour("white"),  value(0)
label    bounds(395, 15, 55, 15), text("Balance"), FontColour("white")

label   bounds(375,  43, 75, 15), text("Filter Type"), FontColour("white")
combobox bounds(370,  60,85, 20), channel("type"), value(1), text("reson", "butterbp", "areson", "butterbr")

rslider bounds(368, 93, 90, 90), text("Mix"),		colour(27,59,59),trackercolour(127,159,159),textcolour("white"),fontcolour("white"), 		channel("mix"), 	range(0, 1.00, 1)
rslider bounds(368,190, 90, 90), text("Level"),		colour(27,59,59),trackercolour(127,159,159),textcolour("white"),fontcolour("white"), 		channel("level"), 	range(0, 1.00, 1)

nslider  bounds(360,283, 50, 30), text("CF"), textcolour("white"), channel("cfDisp"), range(1, 20000, 1, 1, 1)
nslider  bounds(415,283, 50, 30), text("BW"), textcolour("white"), channel("bwDisp"), range(1, 20000, 1, 1, 1)

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>
sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	2
0dbfs	=	1

;Author: Iain McCurdy (2012)

instr	1
	kcf		chnget	"cf"
	kbw		chnget	"bw"
	kbalance	chnget	"balance"
	ktype		chnget	"type"
	kmix		chnget	"mix"
	klevel		chnget	"level"
	kporttime	linseg	0,0.001,0.05

	kcf	expcurve	kcf, 4
	kcf	scale	kcf,18000,20

	kbw	expcurve	kbw, 16
	kbw	scale	kbw,3,0.01

	aL,aR	ins
	;aL,aR	diskin2	"seashore.wav",1,0,1
	;aL	pinkish	1	;USE FOR TESTING
	;aR	pinkish	1
	
	kbw	limit	kbw*kcf,1,20000
	
	chnset	kcf,"cfDisp"	;send actual values for cutoff and bandwidth to GUI value boxes
	chnset	kbw,"bwDisp"

	kcf	portk	kcf,kporttime
	kbw	portk	kbw,kporttime	

	if ktype==1 then		;if reson chosen...
	 aFiltL	reson	aL,kcf,kbw,1
	 aFiltR	reson	aR,kcf,kbw,1
	elseif ktype==2 then		;or if butterworth bandpass is chosen
	 aFiltL	butbp	aL,kcf,kbw
	 aFiltR	butbp	aR,kcf,kbw
	elseif ktype==3 then		;or if areson  is chosen...
	 aFiltL	areson	aL,kcf,kbw,1
	 aFiltR	areson	aR,kcf,kbw,1
	else				;otherwise must be butterworth band reject
	 aFiltL	butbr	aL,kcf,kbw
	 aFiltR	butbr	aR,kcf,kbw
	endif
	if kbalance==1 then		;if 'balance' switch is on...
	 aFiltL	balance	aFiltL,aL,0.3	
	 aFiltR	balance	aFiltR,aR,0.3
	endif
	amixL	ntrpol	aL,aFiltL,kmix	;create wet/dry mix
	amixR	ntrpol	aR,aFiltR,kmix
		outs	amixL*klevel,amixR*klevel
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; BandFilterII.csd
; Written by Iain McCurdy, 2015.

; Modify filter limits using the xypad

; The limit double slider is more just for display.
                                                                                   
<Cabbage>                                                                                                                   
form caption("Bandfilter II"), colour("LightSlateGrey"), size(510, 655), pluginid("BFII"), scrollbars(0) style("legacy")

checkbox bounds(9,3,90,15), channel("TestSound"), text("Test Sound"), value(0), fontcolour("black")

xypad bounds(5,20, 500, 500), channel("shift", "width"), rangex(0, 1, 0.5), rangey(0, 1, 0.5), text("x:cutoff y:bandwidth"), colour("LightSlateGrey"), fontcolour("white")

;hslider2 bounds(  5,513,500, 40), channel("Lim1","Lim2"), min(4), max(14), range(4, 14, 0, 1, 0.001)
hrange   bounds(  5,513, 500, 40), channel("Lim1","Lim2"), range(4, 14, 4:14, 1, 0.001)
;hslider   bounds(  5,513,500,15),   channel("Lim1"), range(4,14,4)
;hslider   bounds(  5,528,500,15),   channel("Lim2"), range(4,14,14)

label    bounds(  5,543,500, 13), text("L I M I T S"), fontcolour("black")

image    bounds(  5,560,155, 90), shape("sharp"), outlinecolour("black"), colour(0,0,0,0), outlinethickness(1)
checkbox bounds( 15,570, 80, 11), channel("HPF_active"), text("HPF Active"), fontcolour("black"), value(1)
label    bounds( 15,595, 80, 13), text("HPF Type"), fontcolour("black")
combobox bounds( 15,610, 80, 20), value(2), channel("HPF_type"),   text("6dB/oct","12dB/oct","24dB/oct","36dB/oct","48dB/oct","Resonant"), colour("black")
rslider  bounds( 95,560, 60, 85), range(0,1,0),  channel("HPF_res"),  identchannel("HPF_resID"),   text("Res"),   textbox(1), colour("black"), fontcolour("black"), textcolour("black"), fontcolour("black")

image    bounds(165,560,155, 90), shape("sharp"), outlinecolour("black"), colour(0,0,0,0), outlinethickness(1)
checkbox bounds(175,570, 80, 11), channel("LPF_active"), text("LPF Active"), fontcolour("black"), value(1)
label    bounds(175,595, 80, 13), text("LPF Type"), fontcolour("black")
combobox bounds(175,610, 80, 20), value(2), channel("LPF_type"),  text("6dB/oct","12dB/oct","24dB/oct","36dB/oct","48dB/oct","Resonant"), colour("black")
rslider  bounds(255,560, 60, 85), range(0,1,0),  channel("LPF_res"),  identchannel("LPF_resID"),   text("Res"),   textbox(1), colour("black"), fontcolour("black"), textcolour("black")

label    bounds(370,550, 95, 13), fontcolour("black"), text("Mode")
combobox bounds(370,565, 95, 20), channel("PassRej"), text("Bandpass","Bandreject","Bypass"), value(1)

label   bounds(330,591,170,13), fontcolour("black"), text("Smoothing")
hslider bounds(330,605,170,15), range(0,0.1,0.03,0.75,0.0001),  channel("Smoothing"), textcolour("black")

label   bounds(330,621,170,13), fontcolour("black"), text("Gain")
hslider bounds(330,635,170,15), range(0,1,1),  channel("Gain"), textcolour("black")
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr	=	44100
ksmps	=	32
nchnls	=	2
0dbfs	=	1

;Author: Iain McCurdy (2015)

opcode HighpassNetwork,aa,aakkk
 aL,aR,kHPF,kHPF_res,kHPF_type	xin
 if kHPF_type==1 then 
  aL	atone	aL, cpsoct(kHPF)
  aR	atone	aR, cpsoct(kHPF)
 elseif kHPF_type==2 then 
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
 elseif kHPF_type==3 then 
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
 elseif kHPF_type==4 then 
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
 elseif kHPF_type==5 then 
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
  aL	buthp	aL, cpsoct(kHPF)
  aR	buthp	aR, cpsoct(kHPF)
 elseif kHPF_type==6 then  
  aL	bqrez	aL,cpsoct(kHPF),1+(kHPF_res*40),1
  aR	bqrez	aR,cpsoct(kHPF),1+(kHPF_res*40),1
 endif
 	xout	aL,aR
endop

opcode LowpassNetwork,aa,aakkk
 aL,aR,kLPF,kLPF_res,kLPF_type	xin
 if kLPF_type==1 then                                           
  aL	tone	aL, cpsoct(kLPF)                                
  aR	tone	aR, cpsoct(kLPF)
 elseif kLPF_type==2 then 
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
 elseif kLPF_type==3 then 
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
 elseif kLPF_type==4 then 
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
 elseif kLPF_type==5 then 
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
  aL	butlp	aL, cpsoct(kLPF)
  aR	butlp	aR, cpsoct(kLPF)
 elseif kLPF_type==6 then
  aL	moogladder	aL,cpsoct(kLPF),kLPF_res
  aR	moogladder	aR,cpsoct(kLPF),kLPF_res
 endif
 	xout	aL,aR
endop

instr	1
 kshift	chnget	"shift"
 kwidth	chnget	"width"
 kgain	chnget	"Gain"
 kPassRej	chnget	"PassRej"
 kPassRej	init	1
 kTestSound	chnget	"TestSound"
 kSmoothing	chnget	"Smoothing"
 
 kLPF_type	chnget	"LPF_type"
 kHPF_type	chnget	"HPF_type"
 kLPF_type	init	2
 kHPF_type	init	2
 kLPF_res	chnget	"LPF_res"
 kHPF_res	chnget	"HPF_res"

 kLPF_active	chnget	"LPF_active"
 kHPF_active	chnget	"HPF_active"

 if changed(kHPF_type)==1 then
  if kHPF_type==6 then
   	chnset	"visible(1)","HPF_resID"
  else
   	chnset	"visible(0)","HPF_resID"
  endif
 endif  

 if changed(kLPF_type)==1 then
  if kLPF_type==6 then
   	chnset	"visible(1)","LPF_resID"
  else
   	chnset	"visible(0)","LPF_resID"
  endif
 endif  

 kLim1	limit	scale:k(kshift-(kwidth*kshift),14,4), 4, 14
 kLim2	limit	scale:k(kshift+(kwidth*kshift),14,4), 4, 14
 
 	chnset	kLim1,"Lim1"
 	chnset	kLim2,"Lim2"

 if kTestSound==1 then
  aL	pinkish	0.5	; use for testing
  aR	pinkish	0.5	; use for testing
 else
  aL,aR	ins
 endif
 
 kporttime	linseg	0,0.01,1
 kporttime	*=	kSmoothing
 kLim1	portk	kLim1,kporttime
 kLim2	portk	kLim2,kporttime
 
 if kPassRej==1 then
  if kHPF_active==1 then
   aL,aR	HighpassNetwork	aL,aR,kLim1,kHPF_res,kHPF_type
  endif
  if kLPF_active==1 then
   aL,aR	LowpassNetwork	aL,aR,kLim2,kLPF_res,kLPF_type
  endif
 elseif kPassRej==2 then
  if kHPF_active==1 then
   aL1,aR1	HighpassNetwork	aL,aR,kLim2,kHPF_res,kHPF_type
  endif
  if kLPF_active==1 then  
   aL2,aR2	LowpassNetwork	aL,aR,kLim1,kLPF_res,kLPF_type
  endif
  aL1,aR1,aL2,aR2	init	0
  aL	sum	aL1,aL2
  aR	sum	aR1,aR2
  	clear	aL1,aR1,aL2,aR2
 endif
 
 


 	outs	aL*kgain, aR*kgain

endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; clfilt.csd
; Written by Iain McCurdy, 2012.

; Port.		-	portamento applied to changes that are made to 'Freq.'

<Cabbage>
form caption("clfilt - Multi-Mode Filter") size(655, 90), pluginid("clfl"), scrollbars(0) style("legacy")
image                              bounds(0, 0, 655, 90), colour( 40,40,100), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
rslider bounds( 10, 11, 70, 70), text("Freq."),       colour( 20,20, 80), 	fontcolour("white"), 	channel("cf"), 		range(20, 20000, 2000, 0.333), trackercolour("white"), outlinecolour(140,140,170), textcolour("white")
rslider bounds( 75, 16, 60, 60), text("Port."),       colour( 20,20, 80), 	fontcolour("white"), 	channel("port"), 	range(0,  50, 0.1, 0.5,0.01), trackercolour("white"), outlinecolour(140,140,170), textcolour("white")

rslider bounds(130, 11, 70, 70), text("N.Poles"),     colour( 20,20, 80), 	fontcolour("white"), 	channel("npol"),	range(2,80,24,1,2),            trackercolour("white"), outlinecolour(140,140,170), textcolour("white")
rslider bounds(195, 11, 70, 70), text("Ripple"),      colour( 20,20, 80), 	fontcolour("white"), 	channel("pbr"),		range(0.1,50,14),              trackercolour("white"), outlinecolour(140,140,170), textcolour("white")
rslider bounds(260, 11, 70, 70), text("Attenuation"), colour( 20,20, 80), 	fontcolour("white"), 	channel("sba"),		range(-120,-1,-60),            trackercolour("white"), outlinecolour(140,140,170), textcolour("white")
label                      bounds(365, 10, 40, 12), text("Type:"), fontcolour("white")
combobox channel("type"),  bounds(328, 23, 128, 18), value(1), text("Lowpass","Highpass")
label                      bounds(363, 46, 50, 12), text("Method:"), fontcolour("white")
combobox channel("kind"),  bounds(328, 59, 128, 18), value(2), text("Butterworth","Chebychev type I","Chebychev type II")
rslider bounds(455, 11, 70, 70), text("Mix"),	      colour( 20,20, 80),	fontcolour("white"), 	channel("mix"), 	range(0,1.00,1),   trackercolour("white"), outlinecolour(140,140,170), textcolour("white")
rslider bounds(520, 11, 70, 70), text("Level"),	      colour( 20,20, 80),	fontcolour("white"), 	channel("level"), 	range(0,1.00,0.3), trackercolour("white"), outlinecolour(140,140,170), textcolour("white")
checkbox channel("test"), pos(595, 35), text("TEST"), colour("yellow"), fontcolour("white"), size(60, 15), value(0)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2013)

instr	1	; widgets input
	gkcf		chnget	"cf"
	gkport		chnget	"port"
	gknpol		chnget	"npol"
	gknpol		init	2
	gkpbr		chnget	"pbr"
	gksba		chnget	"sba"
	gktype		chnget	"type"
	gktype		=	gktype - 1
	gktype		init	0
	gkkind		chnget	"kind"
	gkkind		=	gkkind - 1
	gkkind		init	0
	gkmix		chnget	"mix"
	gklevel		chnget	"level"
	gktest		chnget	"test"
endin

instr	2	; clfilt - multimode filter
	kporttime	linseg	0,0.001,1
	kcf	portk	gkcf,kporttime*gkport
	kmix	portk	gkmix,kporttime*0.1
	klevel	portk	gklevel,kporttime
	if gktest=0 then
	 aL,aR	ins
	else
	 aL	pinkish	0.5
	 aR	=	aL
	endif
	
	ktrig	changed	gktype, gknpol, gkkind, gkpbr, gksba
	if ktrig==1 then
	 reinit	UPDATE
	endif
	UPDATE:
	aFiltL	clfilt	aL, kcf, i(gktype), i(gknpol), i(gkkind), i(gkpbr), i(gksba)
	aFiltR	clfilt	aR, kcf, i(gktype), i(gknpol), i(gkkind), i(gkpbr), i(gksba)
	rireturn

	aL	ntrpol	aL,aFiltL,kmix
	aR	ntrpol	aR,aFiltR,kmix
		outs	aL*klevel,aR*klevel
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
i 2 0.01 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; EnvelopeFollower.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("Envelope Follower") size(530, 100), pluginid("envf") style("legacy")
image                  pos(0, 0), size(530, 100), colour("brown"), shape("rounded"), outlinecolour("white"), outlinethickness(4)
vmeter   bounds(20, 10, 15, 80) channel("Meter") value(0) outlinecolour("black"), overlaycolour(20, 3, 3,255) metercolour:0(255,100,100,255) metercolour:1(255,150,155, 255) metercolour:2(255,255,123, 255) outlinethickness(3) 

rslider bounds( 40, 11, 75, 75), text("Sensitivity"), channel("sens"),  range(0, 1, 0.65),                   colour(255,100,100), textcolour(255,255,200), trackercolour(255,255,150)
rslider bounds(110,  6, 45, 45), text("Att."),        channel("att"),   range(0.001, 0.5, 0.01, 0.5, 0.001), colour(255,200,100), textcolour(255,255,200), trackercolour(255,255,150)
rslider bounds(110, 51, 45, 45), text("Dec."),        channel("rel"),   range(0.001, 0.5, 0.2, 0.5, 0.001),  colour(255,200,100), textcolour(255,255,200), trackercolour(255,255,150)
rslider bounds(150, 11, 75, 75), text("Frequency"),   channel("freq"),  range(10, 10000, 1000, 0.5),         colour(255,100,100), textcolour(255,255,200), trackercolour(255,255,150)
label    bounds(225, 15, 85, 14), text("Type"), fontcolour(255,255,200)
combobox bounds(225, 30, 85, 20), text("lpf18","moogladder","butlp","tone"), value("1"), channel("type")
rslider bounds(310, 11, 75, 75), text("Resonance"),   channel("res"),   range(0,  1, 0.75),                  colour(255,100,100), textcolour(255,255,200), trackercolour(255,255,150), identchannel("resID")
rslider bounds(380, 11, 75, 75), text("Distortion"),  channel("dist"),  range(0,  1.00, 0),                  colour(255,100,100), textcolour(255,255,200), trackercolour(255,255,150), identchannel("distID")
rslider bounds(450, 11, 75, 75), text("Level"),       channel("level"), range(0, 1.00, 1),                   colour(255,200,100), textcolour(255,255,200), trackercolour(255,255,150)
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 64
nchnls = 2
0dbfs = 1

; Author: Iain McCurdy (2012)

opcode	EnvelopeFollower,a,akkkkkkk
	ain,ksens,katt,krel,kfreq,ktype,kres,kdist	xin			; READ IN INPUT ARGUMENTS
	setksmps	4
	;				     ATTCK.REL.  -  ADJUST THE RESPONSE OF THE ENVELOPE FOLLOWER HERE
	aFollow		follow2		ain, katt, krel			; AMPLITUDE FOLLOWING AUDIO SIGNAL
	kFollow		downsamp	aFollow				; DOWNSAMPLE TO K-RATE
	kFollow		expcurve	kFollow/0dbfs,0.5		; ADJUSTMENT OF THE RESPONSE OF DYNAMICS TO FILTER FREQUENCY MODULATION
	kFrq		=		kfreq + (kFollow*ksens*10000)	; CREATE A LEFT CHANNEL MODULATING FREQUENCY BASE ON THE STATIC VALUE CREATED BY kfreq AND THE AMOUNT OF DYNAMIC ENVELOPE FOLLOWING GOVERNED BY ksens
	kFrq		limit		kFrq, 20,sr/2			; LIMIT FREQUENCY RANGE TO PREVENT OUT OF RANGE FREQUENCIES  
	if ktype==1 then
	 aout		lpf18		ain, kFrq, kres, kdist		; REDEFINE AUDIO SIGNAL AS FILTERED VERSION OF ITSELF
	elseif ktype==2 then
	 aout		moogladder	ain, kFrq, kres			; REDEFINE AUDIO SIGNAL AS FILTERED VERSION OF ITSELF
	elseif ktype==3 then
	 aFrq	interp	kFrq
	 aout		butlp		ain, aFrq			; REDEFINE AUDIO SIGNAL AS FILTERED VERSION OF ITSELF
	elseif ktype==4 then
	 aout		tone		ain, kFrq			; REDEFINE AUDIO SIGNAL AS FILTERED VERSION OF ITSELF
	endif
			xout		aout				; SEND AUDIO BACK TO CALLER INSTRUMENT
endop

opcode	SwitchPort, k, kii
	kin,iupport,idnport	xin
	kold			init	0
	kporttime		=	(kin<kold?idnport:iupport)
	kout			portk	kin, kporttime
	kold			=	kout
				xout	kout
endop

instr 1
ksens chnget "sens"
katt chnget "att"
krel chnget "rel"
kfreq chnget "freq"
ktype chnget "type"
ktype	init	1
kres chnget "res"
kdist chnget "dist"
klevel chnget "level"
a1,a2	ins


if changed:k(ktype)==1 then
 if ktype==1 then
  chnset	"visible(1)","distID"
  chnset	"visible(1)","resID"
 elseif ktype==2 then
  chnset	"visible(0)","distID"
  chnset	"visible(1)","resID"
 else
  chnset	"visible(0)","distID"
  chnset	"visible(0)","resID"
 endif
endif

;a1,a2	diskin2	"808loop.wav",1,0,1
;a1	=	a1*0.4
;a2	=	a2*0.4

/*level meter*/
amix	sum	a1,a2
krms	rms	amix*0.5
krms	pow	krms,0.75
krms	SwitchPort	krms,0.01,0.05
		chnset	krms,"Meter"

a1	EnvelopeFollower	a1,ksens,katt,krel,kfreq,ktype,kres*0.95,kdist*100
a2	EnvelopeFollower	a2,ksens,katt,krel,kfreq,ktype,kres*0.95,kdist*100
a1	=	a1 * klevel * (1 - ((kdist*0.3)^0.02))	;scale amplitude according to distortion level (to compensate for gain increases it applies)
a2	=	a2 * klevel * (1 - ((kdist*0.3)^0.02))
;	outs	a1,a2
endin

</CsInstruments>
<CsScore>
i 1 0 [60*60*24*7]
</CsScore>
</CsoundSynthesizer>; FilterLFO.csd
; Author: Iain McCurdy (2013)

; INTRODUCTION
; ------------
; multimode filter with a 2 multimode LFOs on the cutoff frequency
; additional controls for specific filter models are accessed using the pop-up buttons

; The outputs of both LFOs are added to the main cutoff frequency (Freq.)
; LFO amplitude are in 'octaves'
; LFO rates are in beats per minute
; 'Smoothing' adds a small amount of portamento to changes in cutoff frequency
;   this can be useful in square wave-type modulations 

; 'Type' is ignored when 'moogladder', 'resonz', 'phaser2' or 'resony' are chosen as 'model'

; some subtlety is required when using the more complex filter models (e.g. phaser2, resony)
;    often low LFO amplitudes and rate work better with these

; CONTROL
; -------
; Freq.		--	global manual frequency control. Like an LFO offset value.
; Res.		--	resonance control. Affects moogladder, resonz and phaser2 models
; Mix		--	dry/wet (filtered/unfiltered) mix
; Level		--	global output level control
; Model		--	(drop down menu) filter model
; Type		--	Filter type: highpass/lowpass - affects tone, butterworth, cl-butterworth, cl-Chebychev models only
; Input		--	choose between live input and (for testing) sawtooth tone and pink noise
; Resync	--	resync. (i.e. restart) the two LFOs
; clfilt/phaser2/resony	--	pop-up panels with further controls for these models
; LFO Type	--	sine, triangle, square (bipolar), square (unipolar), sawtooth up, sawtooth down, random sample & hold and random spline
; LFO Amp	--	amplitude of the LFOs
; LFO Rate	--	rates of the LFOs in beats per minute
; Link Rates	--	when this switch is activate Rate controls for the two LFOs will be linked
; LFO Rate Div.	--	integer division of Rate control value (unaffected by 'Link Rates' setting)
; Smooth	--	a small amount of smoothing can be appied to the LFO to smooth abrupt changes in value (may be useful and 'square' and 'rand.S&H' type modulations

<Cabbage>
form caption("Filter LFO") size(790,170), pluginid("FLFO") style("legacy")
image pos(0, 0),           size(790,170), colour(0,0,0,170), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
rslider bounds( 10, 11, 70, 70), text("Freq."), colour( 30, 30, 30),	trackercolour("white"),	fontcolour("white"), 		channel("cf"), 		range(1, 20000, 300, 0.333)
rslider bounds( 75, 11, 70, 70), text("Res."),  colour( 30, 30, 30),	trackercolour("white"),	fontcolour("white"), 		channel("res"),		range(0,1.00,0.75)
rslider bounds(140, 11, 70, 70), text("Mix"),   colour( 30, 30, 30),	trackercolour("white"),	fontcolour("white"), 		channel("mix"), 	range(0,1.00,1)
rslider bounds(205, 11, 70, 70), text("Level"), colour( 30, 30, 30),	trackercolour("white"),	fontcolour("white"), 		channel("level"), 	range(0, 1.00, 0.2)

label    bounds( 40, 90, 50, 12), text("MODEL"), fontcolour("white")
combobox bounds( 20,102, 100, 18), channel("model"), value(6), text("Tone","Butterworth","Moogladder","cl-Butterworth","cl-Chebychev I","resonz","phaser2","resony")

label    bounds(160, 90, 50, 12), text("TYPE"),  fontcolour("white")
combobox bounds(140,102, 100, 18), channel("type"), value(1), text("Low-pass","High-pass")

label    bounds( 40,127, 50, 12), text("INPUT"), fontcolour("white")
combobox bounds( 20,139,100, 18), channel("input"), value(2), text("Live","Tone","Noise")

button   bounds(140,139, 80, 18), colour("Green"), text("RESYNC.", "RESYNC."), channel("resync"), value(1)

; controls pertaining to the setup of clfilt accessed in a pop-up panel.
button   bounds(280, 15,100, 30), channel("clfiltButton"), text("clfilt")
groupbox bounds(280, 15,150, 90),  colour("black"), plant("clfilt"), outlinethickness(0), popup(1), identchannel("clfiltPlant");, fontcolour("white")
{
rslider bounds(  5, 16, 70, 70), text("N.Poles"), colour( 30 , 30, 30),	trackercolour("white"), fontcolour("white"), channel("npol"),   range(2, 80, 2, 1, 2)
rslider bounds( 75, 16, 70, 70), text("Ripple"),  colour( 30 , 30, 30),	trackercolour("white"), fontcolour("white"), channel("pbr"),    range(0.1, 50.00, 1, 0.5, 0.001)
}

; controls pertaining to the setup of phaser2 accessed in a pop-up panel.
button   bounds(280, 55,100, 30), channel("phaser2Button"), text("phaser2")
groupbox bounds(280, 55,315, 90), colour("black"), plant("phaser2"), outlinethickness(0), popup(1), identchannel("phaser2Plant");, fontcolour(white)
{
rslider  bounds(  5, 16, 70, 70), text("Q"),       channel("q"),   range(0.0001,4,3),       colour( 30 , 30, 30),	trackercolour("white"), fontcolour("white")
rslider  bounds( 75, 16, 70, 70), text("N.Ords."), channel("ord"), range(1, 256, 8, 0.5,1), colour( 30 , 30, 30),	trackercolour("white"), fontcolour("white")
label    bounds(145, 20, 90, 14), text("Sep. Mode:"), fontcolour("white")
combobox bounds(145, 35, 90, 20), channel("mode"), value(1), text("Equal", "Power"), colour( 30 , 30, 30),	trackercolour("white"), fontcolour("white")
rslider  bounds(240, 16, 70, 70), text("Separation"), channel("sep"), range(-3, 3.00, 0.9), colour( 30 , 30, 30),	trackercolour("white"), fontcolour("white")
}

; controls pertaining to the setup of resony accessed in a pop-up panel.
button   bounds(280, 95,100, 30), channel("resonyButton"), text("resony")
groupbox bounds(280, 95,565, 90),  colour("black"), plant("resony"), outlinethickness(0), popup(1), identchannel("resonyPlant");, fontcolour(white)
{
rslider  bounds(  5, 16, 70, 70), text("BW."),           fontcolour("white"), channel("bw"),    range(0.01, 1000, 13, 0.5), colour( 30 , 30, 30),	trackercolour("white")
rslider  bounds( 75, 16, 70, 70), text("Num."),          fontcolour("white"), channel("num"),   range(1, 80, 10, 1,1),      colour( 30 , 30, 30),	trackercolour("white")
rslider  bounds(145, 16, 70, 70), text("Sep.oct."),      fontcolour("white"), channel("sepR"),  range(-11, 11, 2),          colour( 30 , 30, 30),	trackercolour("white")
rslider  bounds(215, 16, 70, 70), text("Sep.semi."),     fontcolour("white"), channel("sepR2"), range(-48, 48, 24,1,1),     colour( 30 , 30, 30),	trackercolour("white")
label    bounds(285, 20,130, 14), text("Scaling Mode"), fontcolour("white")
combobox bounds(285, 35,130, 20), channel("scl"), value(2), text("none", "peak response", "RMS")
label    bounds(425, 20,130, 14), text("Separation Mode"), fontcolour("white")
combobox bounds(425, 35,130, 20), channel("sepmode"), value(1), text("octs.total", "hertz", "octs.adjacent")
}

;checkbox bounds(400, 50,100, 15), text("Balance") channel("balance"), fontcolour("white"), colour("yellow")  value(0)


line bounds(390, 10,  2,150), colour("Grey")

;LFO
label    bounds(405, 11, 45, 17), text("LFO 1"), fontcolour("white")
combobox bounds(405, 50, 100, 18), channel("LFOtype"), value(3), text("Sine","Triangle","Square[bi]","Square[uni]","Saw Up","Saw Down","Rand.S&H","Rand.Spline")
rslider  bounds(515, 11, 70, 70), text("Amp"),      colour( 30, 30 ,30),	trackercolour("white"), fontcolour("white"), channel("LFOamp"), range(0, 9.00, 0.67)
rslider  bounds(580, 11, 70, 70), text("Rate"),     colour( 30, 30 ,30),	trackercolour("white"), fontcolour("white"), channel("LFOBPM"), range(0, 480, 60, 1, 1)
rslider  bounds(645, 11, 70, 70), text("Rate Div."),colour( 30, 30 ,30),	trackercolour("white"), fontcolour("white"), channel("LFOBPMDiv"), range(1, 64, 1, 1, 1)
rslider  bounds(710, 11, 70, 70), text("Smoothing"),colour( 30, 30 ,30),	trackercolour("white"), fontcolour("white"), channel("LFOport"), range(0, 0.1, 0.005, 0.25, 0.000001)
checkbox bounds(405, 31, 80, 12), text("Link Rates"), channel("RateLink"),colour(yellow), fontcolour("white"),  value(0)

;LFO2
label    bounds(405, 91, 45, 17), text("LFO 2"), fontcolour("white")
combobox bounds(405,130, 100, 18), channel("LFOtype2"), value(8), text("Sine","Triangle","Square[bi]","Square[uni]","Saw Up","Saw Down","Rand.S&H","Rand.Spline")
rslider  bounds(515, 91, 70, 70), text("Amp"), colour( 30, 30 ,30),	        trackercolour("white"), fontcolour("white"), channel("LFOamp2"), range(0, 9.00, 2.5)
rslider  bounds(580, 91, 70, 70), text("Rate"),colour( 30, 30 ,30),	        trackercolour("white"), fontcolour("white"), channel("LFOBPM2"), range(0, 480,  1, 1, 1)
rslider  bounds(645, 91, 70, 70), text("Rate Div."),colour( 30, 30 ,30),	trackercolour("white"), fontcolour("white"), channel("LFOBPMDiv2"), range(1, 64, 1, 1, 1)
rslider  bounds(710, 91, 70, 70), text("Smoothing"),colour( 30, 30 ,30),	trackercolour("white"), fontcolour("white"), channel("LFOport2"), range(0, 0.1, 0.001, 0.25, 0.000001)
checkbox bounds(405,111, 80, 12), text("Link Rates"), channel("RateLink"),colour(yellow), fontcolour("white"),  value(0)

label   bounds(220,150, 170, 12), text("Author: Iain McCurdy |2013|"), fontcolour("grey")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2013)

opcode	resony2,a,akkikii
	ain, kbf, kbw, inum, ksep , isepmode, iscl	xin

	;IF 'Octaves (Total)' MODE SELECTED...
	if isepmode==0 then
	 irescale	divz	inum,inum-1,1	;PREVENT ERROR IF NUMBER OF FILTERS = ZERO
	 ksep = ksep * irescale			;RESCALE SEPARATION
	
	;IF 'Hertz' MODE SELECTED...	
	elseif isepmode==1 then
	 inum	=	inum + 1
	 ksep	=	inum

	;IF 'Octaves (Adjacent)' MODE SELECTED...
	elseif isepmode==2 then 
	 irescale	divz	inum,inum-1,1	;PREVENT ERROR IF NUMBER OF FILTERS = ZERO
	 ksep = ksep * irescale			;RESCALE SEPARATION
	 ksep = ksep * (inum-1)			;RESCALE SEPARATION INTERVAL ACCORDING TO THE NUMBER OF FILTERS CHOSEN
	 isepmode	=	0
	endif

	aout 		resony 	ain, kbf, kbw, inum, ksep , isepmode, iscl, 0
			xout	aout
endop


instr	1
	kporttime	linseg	0,0.001,1

	kcf		chnget	"cf"				;
	kcf	portk	kcf,kporttime*0.05
	kres		chnget	"res"				;
	kmodel		chnget	"model"				;
	ktype		chnget	"type"				;
	kresync		chnget	"resync"				;

	kmix		chnget	"mix"				;
	klevel		chnget	"level"				;

	kpbr		chnget	"pbr"				;
	kpbr		init	1
	knpol		chnget	"npol"				;
	knpol		init	2

	kq		chnget	"q"					;
	kmode		chnget	"mode"					;
	kmode		init	1
	kmode		init	i(kmode)-1
	ksep		chnget	"sep"					;
	kfeedback	chnget	"feedback"				;
	kord		chnget	"ord"					;

	;resony
	kbw	chnget	"bw"
	knum	chnget	"num"
	ksepR	chnget	"sepR"
	ksepR2	chnget	"sepR2"
	ksepmode	chnget	"sepmode"
	ksepmode	=	ksepmode - 1
	ksepmode	init	1
	kscl	chnget	"scl"
	kscl	=	kscl - 1
	kscl	init	1

	;kbalance	chnget	"balance"			;

	kLFOtype	chnget	"LFOtype"
	kLFOamp		chnget	"LFOamp"
	kLFOamp		portk	kLFOamp, kporttime*0.05
	kLFOBPM		chnget	"LFOBPM"
	kLFOBPMDiv	chnget	"LFOBPMDiv"
	kLFOcps		=	(kLFOBPM*4)/(60*kLFOBPMDiv)
	kLFOport	chnget	"LFOport"

	kLFOtype2	chnget	"LFOtype2"
	kLFOamp2	chnget	"LFOamp2"
	kLFOamp2	portk	kLFOamp2, kporttime*0.05
	kLFOBPM2	chnget	"LFOBPM2"
	kLFOBPMDiv2	chnget	"LFOBPMDiv2"
	kLFOcps2	=	(kLFOBPM2*4)/(60*kLFOBPMDiv2)
	kLFOport2	chnget	"LFOport2"
	
	kRateLink		chnget	"RateLink"
	if kRateLink=1 then
	 ktrig1	changed	kLFOBPM
	 ktrig2	changed	kLFOBPM2
	 if ktrig1=1 then
	  chnset	kLFOBPM,"LFOBPM2"
	 elseif ktrig2=1 then
	  chnset	kLFOBPM2,"LFOBPM"
	 endif
	endif
	/* INPUT */
	kinput		chnget	"input"
	if kinput=1 then
	 aL,aR	ins
	elseif kinput=2 then
	 aL	vco2	0.2, 150
	 aR	=	aL
	else
	 aL	pinkish	0.2
	 aR	pinkish	0.2
	endif

	; RETRIGGERING FOR I-RATE VARIABLE
	kLFOtype	init	1
	kLFOtype2	init	1

	ktrig	changed	knpol,kpbr,kLFOtype,kLFOtype2,kmodel,ktype,kord,kmode, kscl, knum, ksepmode, kresync,kLFOBPMDiv,kLFOBPMDiv2,kRateLink
	if ktrig==1 then
	 reinit UPDATE
	endif
	UPDATE:
	
	; LFO
	if i(kLFOtype)==7 then
	 klfo	randomh	-kLFOamp, kLFOamp, kLFOcps
	elseif	i(kLFOtype)==8 then
	 klfo	jspline	kLFOamp, kLFOcps, kLFOcps*5
	else
	 klfo		lfo	kLFOamp, kLFOcps, i(kLFOtype)-1
	endif
	klfo		portk	klfo,kporttime*kLFOport
	;kcf		limit	kcf * octave(klfo),20,sr/2

	; LFO2
	if i(kLFOtype2)==7 then
	 klfo2	randomh	-kLFOamp2, kLFOamp2, kLFOcps2
	elseif	i(kLFOtype2)==8 then
	 klfo2	jspline	kLFOamp2, kLFOcps2, kLFOcps2*5
	else
	 klfo2		lfo	kLFOamp2, kLFOcps2, i(kLFOtype2)-1
	endif
	klfo2		portk	klfo2,kporttime*kLFOport2
	kcf		limit	kcf * octave(klfo) * octave(klfo2),20,sr/2


	; FILTER MODEL SELECT
	if i(kmodel)==1 then
	 if i(ktype)==1 then			; tone
	  aFiltL	tone	aL, kcf
	  aFiltR	tone	aR, kcf
	 else
	  aFiltL	atone	aL, kcf
	  aFiltR	atone	aR, kcf
	 endif
	elseif i(kmodel)==2 then		; butterworth
	 if i(ktype)==1 then
	  aFiltL	butlp	aL, kcf
	  aFiltR	butlp	aR, kcf
	 else
	  aFiltL	buthp	aL, kcf
	  aFiltR	buthp	aR, kcf        
	 endif
	elseif i(kmodel)==3 then			; moogladder
	 kres	scale		kres,0.95,0
	 aFiltL	moogladder	aL,kcf,kres
	 aFiltR	moogladder	aR,kcf,kres        
	elseif i(kmodel)==4 then			; cl-butterworth
	 if i(ktype)==1 then
	  aFiltL	clfilt	aL, kcf, 0, i(knpol)
	  aFiltR	clfilt	aR, kcf, 0, i(knpol)
	 else
	  aFiltL	clfilt	aL, kcf, 1, i(knpol)
	  aFiltR	clfilt	aR, kcf, 1, i(knpol)
	 endif
	elseif i(kmodel)==5 then			; cl-chebychev I
	 if i(ktype)==1 then
	  aFiltL	clfilt	aL, kcf, 0, i(knpol), 1, i(kpbr)
	  aFiltR	clfilt	aR, kcf, 0, i(knpol), 1, i(kpbr)
	 else
	  aFiltL	clfilt	aL, kcf, 1, i(knpol), 1, i(kpbr)
	  aFiltR	clfilt	aR, kcf, 1, i(knpol), 1, i(kpbr)
	 endif
	elseif i(kmodel)==6 then			; resonz
	 kres	logcurve	kres,4
	 kbw	scale	1-kres,3,0.1
	 aFiltL	resonz	aL, kcf, kcf*kbw, 1
	 aFiltR	resonz	aR, kcf, kcf*kbw, 1
	elseif i(kmodel)==7 then			; phaser2
	 kfeedback	scale	kres,0.99,0
	 aFiltL	phaser2		aL, kcf, kq, kord, kmode, ksep, kfeedback	; PHASER2 IS APPLIED TO THE LEFT CHANNEL
	 aFiltR	phaser2		aR, kcf, kq, kord, kmode, ksep, kfeedback	; PHASER1 IS APPLIED TO THE RIGHT CHANNEL
	elseif i(kmodel)==8 then			; resony	
	 ;CALL resony2 UDO
	 aFiltL 		resony2 aL, kcf, kbw, i(knum), ksepR , i(ksepmode), i(kscl)
	 aFiltR 		resony2	aR, kcf, kbw, i(knum), ksepR , i(ksepmode), i(kscl)
	endif
	
	rireturn

	/*
	if kbalance==1 then
	 aFiltL	balance	aFiltL,aL
	 aFiltR	balance	aFiltR,aR
	endif
	*/

	
	aL	ntrpol	aL,aFiltL,kmix
	aR	ntrpol	aR,aFiltR,kmix
		outs	aL*klevel,aR*klevel
endin

instr	UpdateWidgets
	ksepR	chnget	"sepR"
	ksepR2	chnget	"sepR2"
	ktrig1	changed	ksepR
	ktrig2	changed	ksepR2
	if ktrig1==1 then
	 chnset	ksepR*12, "sepR2"
	elseif  ktrig2==1 then
	 chnset	ksepR2/12, "sepR"
	endif
endin

instr 1000				; launches plant popups

klaunch	init	0

#define LAUNCH_PLANT(name)
#
kpressed	chnget "$name.Button"
if changed(kpressed)==1 then
  Smsg sprintfk "show(%d), pos(1, 19)", klaunch
  chnset Smsg, "$name.Plant"
endif
#

$LAUNCH_PLANT(clfilt)
$LAUNCH_PLANT(phaser2)
$LAUNCH_PLANT(resony)

klaunch	=	1

endin
	
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
i "UpdateWidgets" 0 [3600*24*7]
i 1000 0 [60*60*24*7]	; plant pop-ups
</CsScore>

</CsoundSynthesizer>
; FilterShaper.csd
; Iain McCurdy, 2015

; Gestural shaping using rspline random function generators applied to lowpass filter, highpass filter, panning and amplitude

<Cabbage>
form caption("Filter Shaper") size(595, 200), pluginid("FlSh") style("legacy")
image               bounds(  0, 0, 595, 200), colour("Chocolate"), outlinecolour("white"), outlinethickness(2), shape("sharp")

line     bounds( 15,  4,125, 15)
label    bounds( 15,  5,125, 12), fontcolour("white"), text("R A T E")
rslider  bounds(  5, 20, 75, 75), text("Min"),  channel("RateMin"), range(0.01,20,0.5,0.5,0.01), textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds( 75, 20, 75, 75), text("Max"),  channel("RateMax"), range(0.01,20,3,0.5,0.01), textcolour("white"), colour(37,59,59), trackercolour("Silver")
checkbox bounds(160, 20, 75, 15), text("Bypass"),  channel("Bypass"), fontcolour("white")

image    bounds(220,  0,145, 95), colour(0,0,0,0), plant("panning") {
line     bounds( 15,  4,125, 15)
label    bounds( 15,  5,125, 12), fontcolour("white"), text("P A N N I N G")
rslider  bounds(  5, 20, 75, 75), text("Width"),channel("PanWidth"), range(0,1,1), textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds( 75, 20, 75, 75), text("Depth"),channel("PanDepth"), range(0,1,1), textcolour("white"), colour(37,59,59), trackercolour("Silver")
}

image    bounds(445,  0,145, 95), colour(0,0,0,0), plant("amplitude") {
line     bounds( 10,  4,125, 15)
label    bounds( 10,  5,125, 12), fontcolour("white"), text("A M P L I T U D E")
rslider  bounds(  0, 20, 75, 75), text("Min."),channel("AmpMin"), range(0,2,0.4,0.5,0.01), textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds( 70, 20, 75, 75), text("Max."),channel("AmpMax"), range(0,2,0.8,0.5,0.01), textcolour("white"), colour(37,59,59), trackercolour("Silver")
}

image    bounds( 15,100,285, 95), colour(0,0,0,0), plant("lowpass") {
line     bounds(  0,  4,275, 15)
label    bounds(  0,  5,275, 12), fontcolour("white"), text("L O W P A S S   F I L T E R")
label    bounds(  0, 28, 75, 12), fontcolour("white"), text("LPF Type"), fontcolour(100,100,100)
combobox bounds(  0, 40, 75, 20), channel("LPFtype"), text("Bypass","6 db/oct","12 db/oct","24 db/oct","Resonant"), textcolour("white"), colour(37,59,59), value(3)
rslider  bounds( 70, 20, 75, 75), text("Res."),channel("LPFres"), range(0,1,0.3,0.5,0.01), textcolour("white"), colour(37,59,59), trackercolour("Silver"), identchannel("LPFresID")
rslider  bounds(140, 20, 75, 75), text("Min."),channel("LPFmin"), range(4,14, 6), textcolour("white"), colour(37,59,59), trackercolour("Silver"), identchannel("LPFminID")
rslider  bounds(210, 20, 75, 75), text("Max."),channel("LPFmax"), range(4,14,14), textcolour("white"), colour(37,59,59), trackercolour("Silver"), identchannel("LPFmaxID")
}

image    bounds(305,100,285, 95), colour(0,0,0,0), plant("highpass") {
line     bounds(  0,  4,275, 15)
label    bounds(  0,  5,275, 12), fontcolour("white"), text("H I G H P A S S   F I L T E R")
label    bounds(  0, 28, 75, 12), fontcolour("white"), text("HPF Type"), fontcolour(100,100,100)
combobox bounds(  0, 40, 75, 20), channel("HPFtype"), text("Bypass","6 db/oct","12 db/oct","24 db/oct","Resonant"), textcolour("white"), colour(37,59,59), value(3)
rslider  bounds( 70, 20, 75, 75), text("Res."),channel("HPFres"), range(0,1,0.3,0.5,0.01), textcolour("white"), colour(37,59,59), trackercolour("Silver"), identchannel("HPFresID")
rslider  bounds(140, 20, 75, 75), text("Min."),channel("HPFmin"), range(4,14, 4), textcolour("white"), colour(37,59,59), trackercolour("Silver"), identchannel("HPFminID")
rslider  bounds(210, 20, 75, 75), text("Max."),channel("HPFmax"), range(4,14, 6), textcolour("white"), colour(37,59,59), trackercolour("Silver"), identchannel("HPFmaxID")
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1                                                         
 kRateMin	chnget "RateMin"
 kRateMax	chnget "RateMax"
 kLPFtype	chnget "LPFtype"
 kLPFres	chnget "LPFres"
 kLPFmin	chnget "LPFmin"
 kLPFmax	chnget "LPFmax"

 kHPFtype	chnget "HPFtype"
 kHPFres	chnget "HPFres"
 kHPFmin	chnget "HPFmin"
 kHPFmax	chnget "HPFmax"

 kPanWidth	chnget "PanWidth"
 kPanDepth	chnget "PanDepth"

 kAmpMin	chnget "AmpMin"
 kAmpMax	chnget "AmpMax"

 kBypass	chnget	"Bypass"
 
 aL,aR	ins
 
 if kBypass==1 then
  	outs	aL,aR
  	kgoto BYPASS
 endif
 
 ;aL	vco2	0.1,100
 ;aR	vco2	0.1,100
 
 kLPFoct	rspline	kLPFmin,kLPFmax,kRateMin,kRateMax
 kHPFoct	rspline	5,14,kRateMin,kRateMax

 kLPFoct	limit	kLPFoct,4,14
 kHPFoct	limit	kHPFoct,4,14
 
 if kLPFtype==2 then
  aL	tone	aL,cpsoct(kLPFoct)
  aR	tone	aR,cpsoct(kLPFoct)
 elseif kLPFtype==3 then
  aLPFoct	interp	kLPFoct
  aL	butlp	aL,cpsoct(aLPFoct)
  aR	butlp	aR,cpsoct(aLPFoct)
 elseif kLPFtype==4 then
  aLPFoct	interp	kLPFoct
  aL	butlp	aL,cpsoct(aLPFoct)
  aR	butlp	aR,cpsoct(aLPFoct)
  aL	butlp	aL,cpsoct(aLPFoct)
  aR	butlp	aR,cpsoct(aLPFoct)
 elseif kLPFtype==5 then
  aL	moogladder	aL,cpsoct(kLPFoct),kLPFres
  aR	moogladder	aR,cpsoct(kLPFoct),kLPFres
 endif

 if kHPFtype==2 then
  aL	atone	aL,cpsoct(kHPFoct)
  aR	atone	aR,cpsoct(kHPFoct)
 elseif kHPFtype==3 then
  aHPFoct	interp	kHPFoct
  aL	buthp	aL,cpsoct(aHPFoct)
  aR	buthp	aR,cpsoct(aHPFoct)
 elseif kHPFtype==4 then
  aHPFoct	interp	kHPFoct
  aL	buthp	aL,cpsoct(aHPFoct)
  aR	buthp	aR,cpsoct(aHPFoct)
  aL	buthp	aL,cpsoct(aHPFoct)
  aR	buthp	aR,cpsoct(aHPFoct)
 elseif kHPFtype==5 then
  aL	bqrez	aL,cpsoct(kHPFoct),1+(kHPFres*40),1
  aR	bqrez	aR,cpsoct(kHPFoct),1+(kHPFres*40),1
 endif

 aPan	rspline	-kPanWidth, kPanWidth, kRateMin, kRateMax
 aPan	=	(aPan*0.5) + 0.5 
 aOutL  =     aL * sin((aPan + 0.5) * $M_PI_2)
 aOutR  =     aR * cos((aPan + 0.5) * $M_PI_2)

 if kPanDepth>0 then
  aOutL	vdelay	aOutL, 0.1+(aPan*kPanDepth*3), 20
  aOutR	vdelay	aOutR, 0.1+((1-aPan)*kPanDepth*3), 20
 endif

 aAmp	rspline	kAmpMin, kAmpMax, kRateMin, kRateMax

	outs	aOutL*aAmp,aOutR*aAmp
 BYPASS:
endin

</CsInstruments>

<CsScore>                                              
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>                                                  ; FormantFilter.csd

; reson 1 uses reson with scaling method 1.
; reson 2 uses reson with scaling method 2.
; 'gain' controls the gain the the bandpass filtered sound only.
; 'BW.Mult' is a factor which all five bandwidth values are multiplied by.
; 'Freq.Mult.' is a factor by which all cutoff frequencies are multiplied by.

<Cabbage>
form caption("Formant Filter"), colour("SlateGrey"), size(550, 280), pluginid("form")   style("legacy")

xypad bounds(5, 5, 350, 260), channel("x", "y"), rangex(0, 1, 0.5), rangey(0, 1, 0), text("upper edge:A E I | lower :U O"), fontcolour("white")

vslider bounds(360,  0, 30,140), text("f1"), channel("f1"), range(0, 1.00, 1), textcolour("white")
vslider bounds(380,  0, 30,140), text("f2"), channel("f2"), range(0, 1.00, 1), textcolour("white")
vslider bounds(400,  0, 30,140), text("f3"), channel("f3"), range(0, 1.00, 1), textcolour("white")
vslider bounds(420,  0, 30,140), text("f4"), channel("f4"), range(0, 1.00, 1), textcolour("white")
vslider bounds(440,  0, 30,140), text("f5"), channel("f5"), range(0, 1.00, 1), textcolour("white")
combobox bounds(365, 150,100, 20), channel("voice"), value(1), text("bass", "tenor", "countertenor", "alto", "soprano")
combobox bounds(365, 180,100, 20), channel("filter"), value(1), text("reson 1", "reson 2", "butterworth")
checkbox bounds(365, 210,100, 15), colour("yellow"), channel("balance"),  value(0), text("Balance"), fontcolour("white")

label    bounds(365, 227,100, 12), text("Input Source"), fontcolour("white")
combobox bounds(365, 240,100, 20), channel("input"), value(1), text("Live", "Noise")

rslider bounds(480,  5, 60, 60), text("BW.Mult"),   channel("BWMlt"),  range(0.01, 4, 1, 0.4), textcolour("white")
rslider bounds(480, 70, 60, 60), text("Freq.Mult"), channel("FrqMlt"), range(0.25, 4, 1, 0.4), textcolour("white")
rslider bounds(480,140, 60, 60), text("Mix"),       channel("mix"),    range(0, 1.00, 1),      textcolour("white")
rslider bounds(480,210, 60, 60), text("Gain"),      channel("gain"),   range(0, 5.00, 1, 0.5), textcolour("white")
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>
<CsInstruments>
sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	2
0dbfs	=	1

;Author: Iain McCurdy (2012)

;FUNCTION TABLES STORING DATA FOR VARIOUS VOICE FORMANTS
;THE FIRST VALUE OF EACH TABLE DEFINES THE NUMBER OF DATA ELEMENTS IN THE TABLE
; THIS IS NEEDED BECAUSE TABLES SIZES MUST BE POWERS OF 2 TO FACILITATE INTERPOLATED TABLE READING (tablei) 
;BASS
giBFA	ftgen	0,  0, 8, -2,	4, 600,		400,	250,	350	;FREQ
giBFE	ftgen	0,  0, 8, -2,	4, 1040,	1620,	1750,	600	;FREQ
giBFI	ftgen	0,  0, 8, -2,	4, 2250,	2400,	2600,	2400	;FREQ
giBFO	ftgen	0,  0, 8, -2,	4, 2450,	2800,	3050,	2675	;FREQ
giBFU	ftgen	0,  0, 8, -2,	4, 2750,	3100,	3340,	2950	;FREQ

giBDbA	ftgen	0, 0, 8, -2,	4, 0,	0,	0,	0	;dB
giBDbE	ftgen	0, 0, 8, -2,	4, -7,	-12,	-30,	-20	;dB
giBDbI	ftgen	0, 0, 8, -2,	4, -9,	-9,	-16,	-32	;dB
giBDbO	ftgen	0, 0, 8, -2,	4, -9,	-12,	-22,	-28	;dB
giBDbU	ftgen	0, 0, 8, -2,	4, -20,	-18,	-28,	-36	;dB

giBBWA	ftgen	0, 0, 8, -2,	4, 60,	40,	60,	40	;BAND WIDTH
giBBWE	ftgen	0, 0, 8, -2,	4, 70,	80,	90,	80	;BAND WIDTH
giBBWI	ftgen	0, 0, 8, -2,	4, 110,	100,	100,	100	;BAND WIDTH
giBBWO	ftgen	0, 0, 8, -2,	4, 120,	120,	120,	120	;BAND WIDTH
giBBWU	ftgen	0, 0, 8, -2,	4, 130,	120,	120,	120	;BAND WIDTH
;TENOR
giTFA	ftgen	0, 0, 8, -2,	5, 650, 	400,	290,	400,	350	;FREQ
giTFE	ftgen	0, 0, 8, -2,	5, 1080, 	1700,   1870,	800,	600	;FREQ
giTFI	ftgen	0, 0, 8, -2,	5, 2650,	2600,   2800,	2600,	2700	;FREQ
giTFO	ftgen	0, 0, 8, -2,	5, 2900,	3200,   3250,	2800,	2900	;FREQ
giTFU	ftgen	0, 0, 8, -2,	5, 3250,	3580,   3540,	3000,	3300	;FREQ

giTDbA	ftgen	0, 0, 8, -2,	5, 0,	0,	0,	0,	0	;dB
giTDbE	ftgen	0, 0, 8, -2,	5, -6,	-14,	-15,	-10,	-20	;dB
giTDbI	ftgen	0, 0, 8, -2,	5, -7,	-12,	-18,	-12,	-17	;dB
giTDbO	ftgen	0, 0, 8, -2,	5, -8,	-14,	-20,	-12,	-14	;dB
giTDbU	ftgen	0, 0, 8, -2,	5, -22,	-20,	-30,	-26,	-26	;dB

giTBWA	ftgen	0, 0, 8, -2,	5, 80,	70,	40,	40,	40	;BAND WIDTH
giTBWE	ftgen	0, 0, 8, -2,	5, 90,	80,	90,	80,	60	;BAND WIDTH
giTBWI	ftgen	0, 0, 8, -2,	5, 120,	100,	100,	100,	100	;BAND WIDTH
giTBWO	ftgen	0, 0, 8, -2,	5, 130,	120,	120,	120,	120	;BAND WIDTH                                         
giTBWU	ftgen	0, 0, 8, -2,	5, 140,	120,	120,	120,	120	;BAND WIDTH
;COUNTER TENOR
giCTFA	ftgen	0, 0, 8, -2,	5, 660,		440,	270,	430,	370	;FREQ
giCTFE	ftgen	0, 0, 8, -2,	5, 1120,	1800,	1850,	820,	630	;FREQ
giCTFI	ftgen	0, 0, 8, -2,	5, 2750,	2700,	2900,	2700,	2750	;FREQ
giCTFO	ftgen	0, 0, 8, -2,	5, 3000,	3000,	3350,	3000,	3000	;FREQ
giCTFU	ftgen	0, 0, 8, -2,	5, 3350,	3300,	3590,	3300,	3400	;FREQ

giTBDbA	ftgen	0, 0, 8, -2,	5, 0,	0,	0,	0,	0	;dB
giTBDbE	ftgen	0, 0, 8, -2,	5, -6,	-14,	-24,	-10,	-20	;dB
giTBDbI	ftgen	0, 0, 8, -2,	5, -23,	-18,	-24,	-26,	-23	;dB
giTBDbO	ftgen	0, 0, 8, -2,	5, -24,	-20,	-36,	-22,	-30	;dB
giTBDbU	ftgen	0, 0, 8, -2,	5, -38,	-20,	-36,	-34,	-30	;dB

giTBWA	ftgen	0, 0, 8, -2,	5, 80,	70,	40,	40,	40	;BAND WIDTH
giTBWE	ftgen	0, 0, 8, -2,	5, 90,	80,	90,	80,	60	;BAND WIDTH
giTBWI	ftgen	0, 0, 8, -2,	5, 120,	100,	100,	100,	100	;BAND WIDTH
giTBWO	ftgen	0, 0, 8, -2,	5, 130,	120,	120,	120,	120	;BAND WIDTH
giTBWU	ftgen	0, 0, 8, -2,	5, 140,	120,	120,	120,	120	;BAND WIDTH
;ALTO
giAFA	ftgen	0, 0, 8, -2,	5, 800,		400,	350,	450,	325	;FREQ
giAFE	ftgen	0, 0, 8, -2,	5, 1150,	1600,	1700,	800,	700	;FREQ
giAFI	ftgen	0, 0, 8, -2,	5, 2800,	2700,	2700,	2830,	2530	;FREQ
giAFO	ftgen	0, 0, 8, -2,	5, 3500,	3300,	3700,	3500,	2500	;FREQ
giAFU	ftgen	0, 0, 8, -2,	5, 4950,	4950,	4950,	4950,	4950	;FREQ

giADbA	ftgen	0, 0, 8, -2,	5, 0,	0,	0,	0,	0	;dB
giADbE	ftgen	0, 0, 8, -2,	5, -4,	-24,	-20,	-9,	-12	;dB
giADbI	ftgen	0, 0, 8, -2,	5, -20,	-30,	-30,	-16,	-30	;dB
giADbO	ftgen	0, 0, 8, -2,	5, -36,	-35,	-36,	-28,	-40	;dB
giADbU	ftgen	0, 0, 8, -2,	5, -60,	-60,	-60,	-55,	-64	;dB

giABWA	ftgen	0, 0, 8, -2,	5, 50,	60,	50,	70,	50	;BAND WIDTH
giABWE	ftgen	0, 0, 8, -2,	5, 60,	80,	100,	80,	60	;BAND WIDTH
giABWI	ftgen	0, 0, 8, -2,	5, 170,	120,	120,	100,	170	;BAND WIDTH
giABWO	ftgen	0, 0, 8, -2,	5, 180,	150,	150,	130,	180	;BAND WIDTH
giABWU	ftgen	0, 0, 8, -2,	5, 200,	200,	200,	135,	200	;BAND WIDTH
;SOPRANO
giSFA	ftgen	0, 0, 8, -2,	5, 800,		350,	270,	450,	325	;FREQ
giSFE	ftgen	0, 0, 8, -2,	5, 1150,	2000,	2140,	800,	700	;FREQ
giSFI	ftgen	0, 0, 8, -2,	5, 2900,	2800,	2950,	2830,	2700	;FREQ
giSFO	ftgen	0, 0, 8, -2,	5, 3900,	3600,	3900,	3800,	3800	;FREQ
giSFU	ftgen	0, 0, 8, -2,	5, 4950,	4950,	4950,	4950,	4950	;FREQ

giSDbA	ftgen	0, 0, 8, -2,	5, 0,	0,	0,	0,	0	;dB
giSDbE	ftgen	0, 0, 8, -2,	5, -6,	-20,	-12,	-11,	-16	;dB
giSDbI	ftgen	0, 0, 8, -2,	5, -32,	-15,	-26,	-22,	-35	;dB
giSDbO	ftgen	0, 0, 8, -2,	5, -20,	-40,	-26,	-22,	-40	;dB
giSDbU	ftgen	0, 0, 8, -2,	5, -50,	-56,	-44,	-50,	-60	;dB

giSBWA	ftgen	0, 0, 8, -2,	5, 80,	60,	60,	70,	50	;BAND WIDTH
giSBWE	ftgen	0, 0, 8, -2,	5, 90,	90,	90,	80,	60	;BAND WIDTH
giSBWI	ftgen	0, 0, 8, -2,	5, 120,	100,	100,	100,	170	;BAND WIDTH
giSBWO	ftgen	0, 0, 8, -2,	5, 130,	150,	120,	130,	180	;BAND WIDTH
giSBWU	ftgen	0, 0, 8, -2,	5, 140,	200,	120,	135,	200	;BAND WIDTH

instr	1
	gkx		chnget	"x"
	gky		chnget	"y"
	gkf1		chnget	"f1"
	gkf2		chnget	"f2"
	gkf3		chnget	"f3"
	gkf4		chnget	"f4"
	gkf5		chnget	"f5"
	gkvoice		chnget	"voice"
	gkvoice		init	1
	gkBWMlt		chnget	"BWMlt"
	gkFrqMlt	chnget	"FrqMlt"
	gkmix		chnget	"mix"
	gkgain		chnget	"gain"
	gkfilter	chnget	"filter"
	gkbalance	chnget	"balance"
	gkinput		chnget	"input"
	gkinput		init	1
endin

instr	2	
	kporttime	linseg	0,0.001,0.1                                                     
	
	if gkinput==1 then
	 asigL,asigR	ins
	else
	 asigL	pinkish	1
	 asigR	pinkish	1
	endif
		
	kx	portk	gkx,kporttime
	ky	portk	gky,kporttime	
	
	kSwitch		changed	gkvoice	;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
	if	kSwitch=1	then		;IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
		reinit	START			;BEGIN A REINITIALISATION PASS FROM LABEL 'START'
	endif
	START:		
	;A TEXT MACRO IS DEFINED THAT WILL BE THE CODE FOR DERIVING DATA FOR EACH FORMANT. A MACRO IS USED TO AVOID HAVING TO USING CODE REPETITION AND TO EASIER FACICLITATE CODE MODIFICATION
#define	FORMANT_DATA(N)	
	#
	invals		table		0, giBFA+((i(gkvoice)-1)*15)+$N-1					;NUMBER OF DATA ELEMENTS IN EACH TABLE
	invals	=	invals-1									;
	kfreq$N._U	tablei		1+(kx*(3/5)*invals),giBFA+((i(gkvoice)-1)*15)+$N-1			;READ DATA FOR FREQUENCY (UPPER EDGE OF PANEL)
	kfreq$N._L	tablei		1+(((1-kx)*(1/5))+(4/5)*invals),giBFA+((i(gkvoice)-1)*15)+$N-1	;READ DATA FOR FREQUENCY (LOWER EDGE OF PANEL)
	kfreq$N		ntrpol		kfreq$N._L, kfreq$N._U, ky					;INTERPOLATE BETWEEN UPPER VALUE AND LOWER VALUE (DETERMINED BY Y-LOCATION ON PANEL)                          
	kfreq$N		=		kfreq$N * gkFrqMlt						;MULTIPLY FREQUENCY VALUE BY VALUE FROM 'Frequency Multiply' SLIDER
	kdbamp$N._U	tablei		1+(kx*(3/5)*invals),giBDbA+((i(gkvoice)-1)*15)+$N-1		;READ DATA FOR INTENSITY (UPPER EDGE OF PANEL)                                      
	kdbamp$N._L	tablei		1+(((1-kx)*(1/5))+(4/5)*invals),giBDbA+((i(gkvoice)-1)*15)+$N-1	;READ DATA FOR INTENSITY (LOWER EDGE OF PANEL)                                      
	kdbamp$N	ntrpol		kdbamp$N._L, kdbamp$N._U, ky                   			;INTERPOLATE BETWEEN UPPER VALUE AND LOWER VALUE (DETERMINED BY Y-LOCATION ON PANEL)
	kbw$N._U	tablei		1+(kx*(3/5)*invals),giBBWA+((i(gkvoice)-1)*15)+$N-1		;READ DATA FOR BANDWIDTH (UPPER EDGE OF PANEL)                                      
	kbw$N._L	tablei		1+(((1-kx)*(1/5))+(4/5)*invals),giBBWA+((i(gkvoice)-1)*15)+$N-1	;READ DATA FOR BANDWIDTH (LOWER EDGE OF PANEL)                                      
	kbw$N		ntrpol		kbw$N._L, kbw$N._U, ky						;INTERPOLATE BETWEEN UPPER VALUE AND LOWER VALUE (DETERMINED BY Y-LOCATION ON PANEL)
	kbw$N		=		kbw$N * gkBWMlt							;MULTIPLY BANDWIDTH VALUE BY VALUE FROM 'Bandwidth Multiply' SLIDER
	#												;END OF MACRO!

;READING DATA FOR FORMANTS (MACROS IMPLEMENTED)
	$FORMANT_DATA(1)
	$FORMANT_DATA(2)
	$FORMANT_DATA(3)
	$FORMANT_DATA(4)
	$FORMANT_DATA(5)

	rireturn	;RETURN FROM REINITIALISATION PASS TO PERFORMANCE TIME PASSES
	
	if gkfilter==1 then
	 aBPF1L	reson	asigL, kfreq1, kbw1, 1			;FORMANT 1
	 aBPF1R	reson	asigR, kfreq1, kbw1, 1			;FORMANT 1
	 ;                                                        
	 aBPF2L	reson	asigL, kfreq2, kbw2, 1			;FORMANT 2
	 aBPF2R	reson	asigR, kfreq2, kbw2, 1			;FORMANT 2
	 ;                                                       
	 aBPF3L	reson	asigL, kfreq3, kbw3, 1			;FORMANT 3
	 aBPF3R	reson	asigR, kfreq3, kbw3, 1			;FORMANT 3
	 ;                                                        
	 aBPF4L	reson	asigL, kfreq4, kbw4, 1			;FORMANT 4
	 aBPF4R	reson	asigR, kfreq4, kbw4, 1			;FORMANT 4
	 ;                                                       
	 aBPF5L	reson	asigL, kfreq5, kbw5, 1			;FORMANT 5
	 aBPF5R	reson	asigR, kfreq5, kbw5, 1			;FORMANT 5
	elseif gkfilter==2 then
	 aBPF1L	reson	asigL, kfreq1, kbw1, 2			;FORMANT 1
	 aBPF1R	reson	asigR, kfreq1, kbw1, 2			;FORMANT 1
	 ;                                                        
	 aBPF2L	reson	asigL, kfreq2, kbw2, 2			;FORMANT 2
	 aBPF2R	reson	asigR, kfreq2, kbw2, 2			;FORMANT 2
	 ;                                                       
	 aBPF3L	reson	asigL, kfreq3, kbw3, 2			;FORMANT 3
	 aBPF3R	reson	asigR, kfreq3, kbw3, 2			;FORMANT 3
	 ;                                                        
	 aBPF4L	reson	asigL, kfreq4, kbw4, 2			;FORMANT 4
	 aBPF4R	reson	asigR, kfreq4, kbw4, 2			;FORMANT 4
	 ;                                                       
	 aBPF5L	reson	asigL, kfreq5, kbw5, 2			;FORMANT 5
	 aBPF5R	reson	asigR, kfreq5, kbw5, 2			;FORMANT 5
	else
	 aBPF1L	butbp	asigL, kfreq1, kbw1			;FORMANT 1
	 aBPF1R	butbp	asigR, kfreq1, kbw1			;FORMANT 1
	 ;                                                        
	 aBPF2L	butbp	asigL, kfreq2, kbw2			;FORMANT 2
	 aBPF2R	butbp	asigR, kfreq2, kbw2			;FORMANT 2
	 ;                                                       
	 aBPF3L	butbp	asigL, kfreq3, kbw3			;FORMANT 3
	 aBPF3R	butbp	asigR, kfreq3, kbw3			;FORMANT 3
	 ;                                                        
	 aBPF4L	butbp	asigL, kfreq4, kbw4			;FORMANT 4
	 aBPF4R	butbp	asigR, kfreq4, kbw4			;FORMANT 4
	 ;                                                       
	 aBPF5L	butbp	asigL, kfreq5, kbw5			;FORMANT 5
	 aBPF5R	butbp	asigR, kfreq5, kbw5			;FORMANT 5
	endif	
	
	if gkbalance==1 then
	 aBPF1L	balance	aBPF1L,asigL,0.1
	 aBPF1R	balance	aBPF1R,asigR,0.1
	 aBPF2L	balance	aBPF2L,asigL,0.1
	 aBPF2R	balance	aBPF2R,asigR,0.1
	 aBPF3L	balance	aBPF3L,asigL,0.1
	 aBPF3R	balance	aBPF3R,asigR,0.1
	 aBPF4L	balance	aBPF4L,asigL,0.1
	 aBPF4R	balance	aBPF4R,asigR,0.1
	 aBPF5L	balance	aBPF5L,asigL,0.1
	 aBPF5R	balance	aBPF5R,asigR,0.1
	endif

	;FORMANTS ARE MIXED AND MULTIPLIED BOTH BY INTENSITY VALUES DERIVED FROM TABLES AND BY THE ON-SCREEN GAIN CONTROLS FOR EACH FORMANT 
	aMixL	sum	aBPF1L*(ampdbfs(kdbamp1))*gkf1, aBPF2L*(ampdbfs(kdbamp2))*gkf2, aBPF3L*(ampdbfs(kdbamp3))*gkf3, aBPF4L*(ampdbfs(kdbamp4))*gkf4, aBPF5L*(ampdbfs(kdbamp5))*gkf5
	aMixR	sum	aBPF1R*(ampdbfs(kdbamp1))*gkf1, aBPF2R*(ampdbfs(kdbamp2))*gkf2, aBPF3R*(ampdbfs(kdbamp3))*gkf3, aBPF4R*(ampdbfs(kdbamp4))*gkf4, aBPF5R*(ampdbfs(kdbamp5))*gkf5

	aOutMixL	ntrpol	asigL, aMixL*gkgain, gkmix	;MIX BETWEEN DRY AND WET SIGNALS
	aOutMixR	ntrpol	asigR, aMixR*gkgain, gkmix	;MIX BETWEEN DRY AND WET SIGNALS

		outs	aOutMixL, aOutMixR				;SEND AUDIO TO OUTPUTS
endin

instr	99			; fix cabbage bug
	kon	=	1
		chnset	kon,"f1"
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
i 2 0 [3600*24*7]
;i 99 0 0.03			; fix for cabbage bug
</CsScore>

</CsoundSynthesizer>
; HarpFilter.csd

; Creates a stack of waveguides simulating a resonating bank of strings
; ** WARNING ** 	THIS EFFECT CAN APPLY VAST AMOUNTS OF RESONATING FEEDBACK THEREFORE LARGE AMOUNTS OF GAIN ARE POSSIBLE.
;					TAKE PARTICULAR CARE WHEN USING A LIVE AUDIO INPUT.
;					IF IN DOUBT, REDUCE THE FEEDBACK VALUE.

; Tunings of strings are not controlled individually but are instead defined using several global controls.

; Frequency		-	Base frequency of the stack of waveguide filters
; Cutoff		-	Cutoff frequency of a 1st order lowpass filter within the feedback loop of each waveguide unit
; Spacing		-	The spacing method used between adjacent waveguide filters: Geometric or Arithmetic
; Interval		-	Interval factor between adjacent filters.
;				 If 'Spacing' is geometric then Interval is applied geometrically, each time multiplying it to the previous frequency to derive the next.
;				 In this mode the value Interval actually defines an interval in semitones so an interval of 12 will produce a ratio of 2
;				 e.g. if base frequency is 200 and interval is 12, the sequence is 200,400,800,1600 
;				 If 'Spacing' is 'Arithmetic' then this is applied arithmetically each time adding base_frequency to the frequency of the previous filter to derive the frequency of the next.
;				 e.g. if base frequency is 200, interval is 1, the sequence is 200,400,600,800 etc... i.e. harmonic
; Number		-	The number of waveguides to be created
; Lowest		-	The Lowest filter in the sequence. i.e. shift the stacks up in steps as this is increased.
; Reflect		-	If activated, additional waveguide filters are created at frequencies reflected beneath the base frequency according to the geometric or arithmetric rules. Activating 'Reflect' will double the number of filters used.
; Strength		-	number of series iterations of the filters (single/double/triple). Increasing numbers of iterations sharpens the filtering effect and increases the resonance.
; Filter Type	-	choose between wguide1 and streson. streson will provide better tuning but wguide1 will provide smoother results when modulating its cutoff frequency.
; Width			-	offsets the frequencies of the left and right channels to imbue added stereo width
; Random		-	range of random offsets added to waveguide frequencies
; Lowcut		-	Inserts a 24dB/oct highpass filter after each waveguide, the cutoff of which corresponds to the cutoff of that filter.
; Port.			-	Portamento time applied to changes made to frequency for each waveguide (and by extension also changes made to 'Interval'). Large portamento times are possible thereby permitting slow morphs. 
; Feedback		-	feedback ratio of each waveguide unit.
;				 negative feedback will shift the fundemental down one octave and only odd harmonics will be preset
; Attack		-	Attack time of each new note played 
; Decay			-	Decay time of the input sound once a note is released
; Release		-	Release time of the outputs of the waveguides after a note is released
; Level			-	Output amplitude control

<Cabbage>
form caption("Harp Filter") size(1080,205), pluginid("HaFi") style("legacy")
image             bounds(  0,  0,1080,125), colour("silver"), shape("sharp")

;checkbox  bounds(  7,  5, 70, 12), text("Keyboard"), channel("input"), fontcolour("black")

label     bounds(  7, 20, 80, 13), text("Freq.Input"), fontcolour("black")
combobox  bounds(  7, 34, 80, 16), text("Freq.","Note Number","Keyboard"), channel("input"), value(1)  

label     bounds(  7, 60, 80, 13), text("Audio Input"), fontcolour("black")
combobox  bounds(  7, 74, 80, 16), text("Live","Dust","P.Noise","W.Noise"), channel("InSigMode"), value(2)  

label     bounds( 92, 42, 66, 13), text("Frequency"), fontcolour("black"), identchannel("freqID0")
rslider   bounds(102, 58, 42, 42),  channel("freq"), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(1,5000,150,0.5,0.01), identchannel("freqID1")
nslider bounds( 93,100, 60, 17),  channel("freq"), colour("white"), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(1,5000,150,0.5,0.01), identchannel("freqID2")

label     bounds( 92, 42, 66, 13), text("Note Num."), fontcolour("black"), identchannel("NNID0"), visible(0)
rslider   bounds(102, 58, 42, 42),  channel("NoteNumber"), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(10,110,50,1,0.01), identchannel("NNID1"), visible(0)
nslider bounds( 93,100, 60, 17),  channel("NoteNumber"), colour("white"), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(10,110,50,1,0.01), identchannel("NNID2"), visible(0)

image    bounds(160,  5, 75,115), outlinethickness(1), line(1), outlinecolour("darkslategrey"), shape("sharp"), plant("cutoff") {
label    bounds(  5,  3, 65, 11), text("Cutoff"), fontcolour("black")
combobox bounds(  5, 15, 65, 16), text("Fixed","Ratio"), channel("CutoffMode"), value(1)  
rslider  bounds(  0, 35, 75, 75), text("Hertz"),      channel("cutoff"),      valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(20,22000,8000,0.5,1), identchannel("cutoff_ident")
rslider  bounds(  0, 35, 75, 75), text("Ratio"),      channel("CutoffRatio"), valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(1,60,21,1,1), identchannel("CutoffRatio_ident")
}

image    bounds(245,  5,395,115), outlinethickness(1), line(1), outlinecolour("darkslategrey"), shape("sharp")
label    bounds(260,  8, 80, 11), text("Spacing"), fontcolour("black")
combobox bounds(260, 20, 80, 16), text("Geometric","Arithmetic"), channel("type"), value(2)  
checkbox bounds(360, 20, 55, 12), text("Reflect"),      channel("dual"),  fontcolour("black")
label    bounds(440,  8,  80, 11), text("Strength"), fontcolour("black")
combobox bounds(440, 20, 80, 16), text("Single","Double","Triple","Quadruple"), channel("Iterations")
label    bounds(545,  8,  80, 11), text("Filter Type"), fontcolour("black")
combobox bounds(545, 20, 80, 16), text("wguide1","streson"), channel("FilterType"), value(1)
rslider   bounds(250, 40, 75, 75), text("Interval"),  channel("interval"),   valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(-12,12,0.25)
nslider bounds(260,100, 55, 16),                    channel("interval"),   range(-24,24,0.25,1,0.0001), colour("white"), fontcolour("black")
rslider  bounds(320, 40, 75, 75), text("Number"),     channel("max"),         valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(1,100,11,1,1)
rslider  bounds(380, 40, 75, 75), text("Lowest"),     channel("min"),      valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(1,100,1,1,1)
rslider  bounds(440, 41, 75, 75), text("Width"),      channel("StWidth"),   range(-0.5, 0.5, 0, 1,0.001), valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey")
rslider  bounds(500, 41, 75, 75), text("Random"),     channel("RndFactor"),   range(0, 5, 0, 0.5,0.001), valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey")
rslider  bounds(560, 41, 75, 75), text("Tune"),       channel("Tune"),       range(-100,100, 0, 1,1), valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey")

checkbox bounds(660, 20, 70, 12), text("Low Cut"),     channel("LowCut"),  fontcolour("black")
rslider  bounds(640, 40, 75, 75), text("Port."),   channel("Portamento"), valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(0.1,99,0.1,0.5,0.01)
nslider bounds(710, 55, 55, 35), text("Feedback"),  channel("feedback"), range(-0.99999,0.99999,0.99,1,0.00001), colour("white"), fontcolour("black"), textcolour("black")
rslider  bounds(760, 40, 75, 75), text("Attack"), channel("Att"),         valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(0.05,10,0.05,0.5)
rslider  bounds(820, 40, 75, 75), text("Decay"),  channel("Dec"),         valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(0.05,2,0.05,0.5)
rslider  bounds(880, 40, 75, 75), text("Release"),channel("Rel"),         valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(0.05,20,15,0.5,0.01)
rslider  bounds(940, 40, 75, 75), text("Mix"),    channel("Mix"),         valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(0,1,1,0.5,0.001)
rslider  bounds(1000, 40, 75, 75), text("Level"),  channel("amp"),        valuetextbox(1), textbox(1), fontcolour("black"), textcolour("black"), trackercolour("DarkSlateGrey"), range(0,2,0.7,0.5,0.001)

keyboard bounds(  0,125,1080, 80)

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1
		seed	0
		massign	0,2

giTriDist	ftgen	0,0,1024,21,3,1

gkFilterType	init	1

;A RECURSIVE UDO IS USED TO CREATE THE STACK OF WGUIDE1S
opcode	filterstack, a, akkkkkkkkii					;OPCODE DEFINITION
ain,kfreq,kRndFactor,kcutoff,kLowCut,kfeedback,kint,kPortTime,ktype,icount,imax	xin		;INPUT ARG NAMES
	amix	=	0
	iRnd	trirand	1
	kRnd	=	iRnd * kRndFactor
	if ktype==0 then						;IF GEOMETRIC MODE HAS BEEN CHOSEN...
	 kfreq2	=	kfreq*semitone(kint*(icount-1) + kRnd)			;DEFINE FREQUENCY FOR THIS WGUIDE1 ACCORDING TO THE BASE FREQUENCY, INTERVAL AND THE COUNTER (LOCATION IN SERIES)
	else								;OTHERWISE MUST BE ARITHMETIC MODE
	 kfreq2	=	(kfreq+(kfreq*(icount-1)*kint)) * semitone(kRnd)			;DEFINE FREQUENCY FOR THIS WGUIDE1 ACCORDING TO THE BASE FREQUENCY, INTERVAL AND THE COUNTER (LOCATION IN SERIES)
	endif								;END OF CONDITIONAL
	if abs(kfreq2)>sr/3||abs(kfreq2)<20 then			;IF FREQUENCY IS OUTSIDE OF A SENSIBLE RANGE JUMP THE CREATION OF THE WGUIDE1 ALTOGETHER
	 asig	=	0
	else
	 kramp	linseg	0,0.001,1
	 kfreq2	portk	kfreq2,kPortTime*kramp
	 if gkFilterType==1 then
	  asig	wguide1 ain, kfreq2, kcutoff, kfeedback			;CREATE THE WGUIDE1 SIGNAL
	 else
	  asig	streson	ain, kfreq2, kfeedback
;	  asig	butlp	asig,a(kcutoff)
	  asig	clfilt	asig,kcutoff,0,2
	 endif
	 if kLowCut==1 then
	  asig	buthp	asig,kfreq2
	  asig	buthp	asig,kfreq2	  
	 endif
	endif
	if icount<imax then						;IF THERE ARE STILL MORE WGUIDES TO CREATE IN THE STACK...
	  amix		filterstack	ain,kfreq,kRndFactor,kcutoff,kLowCut,kfeedback,kint,kPortTime,ktype,icount+1,imax	;CALL THE UDO AGAIN
	endif								;END OF CONDITIONAL
	skip:								;LABEL - SKIP TO HERE IF THE FREQUENCY WAS OUT OF RANGE
			xout		asig + amix			;SEND MIX OF ALL AUDIO BACK TO CALLER INSTRUMENT
endop									;END OF UDO


instr	1
	gkInSigMode		chnget	"InSigMode"				; input audio signal
	gkinput		chnget		"input"					; frequency input method (slider/keyboard)
	gkinput		init		1
	if gkInSigMode==1 then
	 gasigL,gasigR	ins
	elseif gkInSigMode==2 then						; &&gkinput!=1(temporaraily shelved) ; don't generate dust if 'keyboard' input is selected. It will be generated in instr 2.
	 gasigL	dust2	0.5,10*randomh:k(0.5,2,4)
	 gasigR	dust2	0.5,10*randomh:k(0.5,2,4)
	 gasigL	tone	gasigL,cpsoct(randomh:k(4,14,50))
	 gasigR	tone	gasigR,cpsoct(randomh:k(4,14,50))
	elseif gkInSigMode==3 then
	 gasigL		=	pinker()*0.2
	 gasigR		=	pinker()*0.2
	else
	 gasigL	noise	0.2,0
	 gasigR	noise	0.2,0
	endif
	
	kporttime	linseg		0,0.001,0.03
	
	gkfreq		chnget		"freq"
	gkNoteNumber		chnget		"NoteNumber"
	;gkfreq		portk		gkfreq,kporttime
	gkCutoffMode	chnget		"CutoffMode"
	gkcutoff	chnget		"cutoff"
	gkcutoff	portk		gkcutoff,kporttime
	gkCutoffRatio	chnget		"CutoffRatio"
	gkfeedback	chnget		"feedback"
	gkfeedback	portk		gkfeedback,kporttime
	gkinterval	chnget		"interval"
	;gkinterval	portk		gkinterval,kporttime
	gkmax		chnget		"max"
	gkmin		chnget		"min"
	ktype		chnget		"type"
	ktype		init		2
	gktype		=		ktype - 1	; COMBOBOX TO 0-1
	gkAtt		chnget		"Att"
	gkDec		chnget		"Dec"
	gkRel		chnget		"Rel"
	gkMix		chnget		"Mix"
	gkamp		chnget		"amp"
	gkPortamento	chnget		"Portamento"
	gkdual		chnget		"dual"
	gkLowCut	chnget		"LowCut"
	gkStWidth	chnget		"StWidth"
	gkRndFactor	chnget		"RndFactor"
	gkTune		chnget		"Tune"
	gkTune		*=		0.01				; CONVERT FROM CENTS TO SEMITONES
	gkLDiff		=		semitone(-gkStWidth+gkTune)
	gkRDiff		=		semitone(gkStWidth+gkTune)	
    gkIterations	chnget	"Iterations"
    gkFilterType	chnget	"FilterType"
	if changed(gkCutoffMode)==1 then
	 if gkCutoffMode==1 then
	  chnset	"visible(1)","cutoff_ident"
	  chnset	"visible(0)","CutoffRatio_ident"
	 else
	  chnset	"visible(0)","cutoff_ident"
	  chnset	"visible(1)","CutoffRatio_ident"
	 endif   
	endif

	if changed(gkinput)==1 then
	 if gkinput==1 then					; frequency
	  chnset	"visible(1)","freqID0"
	  chnset	"visible(1)","freqID1"
	  chnset	"visible(1)","freqID2"
	  chnset	"visible(0)","NNID0"
	  chnset	"visible(0)","NNID1"
	  chnset	"visible(0)","NNID2"
	 elseif gkinput==2 then				; note number
	  chnset	"visible(0)","freqID0"
	  chnset	"visible(0)","freqID1"
	  chnset	"visible(0)","freqID2"
	  chnset	"visible(1)","NNID0"
	  chnset	"visible(1)","NNID1"
	  chnset	"visible(1)","NNID2"
	 else								; keyboard
	  chnset	"visible(0)","freqID0"
	  chnset	"visible(0)","freqID1"
	  chnset	"visible(0)","freqID2"
	  chnset	"visible(0)","NNID0"
	  chnset	"visible(0)","NNID1"
	  chnset	"visible(0)","NNID2"	 
	 endif   
	endif
	
	event_i	"i",2,0.001,-1				; start instr 2 at startup

	if changed(gkinput)==1 then			; 
	 if gkinput<3 then
	  event	"i",2,0,-1
	 endif
	endif
endin
		
instr	2
	/* MIDI AND GUI INTEROPERABILITY */
	iMIDIflag	=	0			; IF MIDI ACTIVATED = 1, NON-MIDI = 0
	mididefault	1, iMIDIflag			; IF NOTE IS MIDI ACTIVATED REPLACE iMIDIflag WITH '1'

	if iMIDIflag==1 then				; IF THIS IS A MIDI ACTIVATED NOTE...
	 inum	notnum
	 ivel	veloc	0,1
	 p1	=	p1 + (rnd(1000)*0.0001)
	 if gkinput<3 then
	  turnoff
	 endif
	 icps	cpsmidi					; READ MIDI PITCH VALUES - THIS VALUE CAN BE MAPPED TO GRAIN DENSITY AND/OR PITCH DEPENDING ON THE SETTING OF THE MIDI MAPPING SWITCHES
	 kfreq	init		icps
	else
	 if gkinput==1 then						; frequency input
	  kfreq	=		gkfreq
	 elseif gkinput==2 then					; note number input
	  kfreq	=		cpsmidinn(gkNoteNumber)
	 endif
	endif						; END OF THIS CONDITIONAL BRANCH

	if trigger:k(gkinput,2.5,0)==1&&iMIDIflag==0 then		; turnoff non-midi notes if keyboard mode is selected
	 turnoff
	endif
	
	kRelease	release
	
	/* INPUT SIGNAL ENVELOPE */
	aenv		linsegr	0,i(gkAtt),1,i(gkDec),0
	
	
	; generating asig within MIDI instrument seems unreliable so is shelved in the meantime...
	/*
	;print	i(gkInSigMode)
	if i(gkInSigMode)==2&&iMIDIflag==1 then				; ensure a unique dust distribution if keyboard mode is selected
	 ;asigL	dust2	0.5,10*randomh:k(0.5,2,4)			; dust2 seems unreliable at the moment, use gausstrig instead...
	 ;asigR	dust2	0.5,10*randomh:k(0.5,2,4)
	 asigL	gausstrig 0.5, 15, 5
	 asigR	gausstrig 0.5, 15, 5
	 asigL	tone	asigL,cpsoct(randomh:k(4,14,50))
	 asigR	tone	asigR,cpsoct(randomh:k(4,14,50))
	 asigL	=		asigL*aenv
	 asigR	=		asigR*aenv
	else
	 asigL	=		gasigL * aenv
	 asigR	=		gasigR * aenv
	endif
	*/
	
	asigL	=		gasigL * aenv
	asigR	=		gasigR * aenv
	
	
	/* DERIVE LOWPASS FILETR CUTOFF DEPENDING UPON MODE SELECTION */
	if gkCutoffMode==2 then
	 kcutoff	limit	gkCutoffRatio*kfreq,20,sr/2
	else
	 kcutoff	=	gkcutoff
	endif	

	/*PORTAMENTO TIME FUNCTION*/
	kPortTime	linseg	0,0.001,1
	kPortTime	*=	gkPortamento

	kchange		changed		gkmax,gkmin,gkIterations,gkdual,gkFilterType,gkLowCut		;reiniting can also smooths interruptions and prevent very loud clicks
	if kchange==1 then					;IF NUMBER OF WGUIDE1S NEEDED OR THE START POINT IN THE SERIES HAS CHANGED...
	  reinit	update					;REINITIALISE THE STACK CREATION
	endif			
	update:							;REINIT FROM HERE
	;CALL THE UDO. (ONCE FOR EACH CHANNEL.)
	aresL		filterstack	asigL, kfreq*gkLDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, gkinterval, kPortTime, gktype, i(gkmin), i(gkmax)+i(gkmin)-1
	aresR		filterstack	asigR, kfreq*gkRDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, gkinterval, kPortTime, gktype, i(gkmin), i(gkmax)+i(gkmin)-1
	if i(gkIterations)>1 then
	 aresL		filterstack	aresL*0.03, kfreq*gkLDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, gkinterval, kPortTime, gktype, i(gkmin), i(gkmax)+i(gkmin)-1
	 aresR		filterstack	aresR*0.03, kfreq*gkRDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, gkinterval, kPortTime, gktype, i(gkmin), i(gkmax)+i(gkmin)-1
	endif
	if i(gkIterations)>2 then
	 aresL		filterstack	aresL*0.03, kfreq*gkLDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, gkinterval, kPortTime, gktype, i(gkmin), i(gkmax)+i(gkmin)-1
	 aresR		filterstack	aresR*0.03, kfreq*gkRDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, gkinterval, kPortTime, gktype, i(gkmin), i(gkmax)+i(gkmin)-1
	endif
	if i(gkIterations)>3 then
	 aresL		filterstack	aresL*0.03, kfreq*gkLDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, gkinterval, kPortTime, gktype, i(gkmin), i(gkmax)+i(gkmin)-1
	 aresR		filterstack	aresR*0.03, kfreq*gkRDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, gkinterval, kPortTime, gktype, i(gkmin), i(gkmax)+i(gkmin)-1
	endif

	if i(gkdual)==1 then	;DUAL DIRECTION WGUIDE1S SELECTED (NOTE NEGATIVE 'kinterval'
	 if i(gkmin)==1 then	;DON'T DOUBLE UP FUNDEMENTAL IF 'Lowest' IS '1'
	  imin	=	i(gkmin)+1
	  imax	=	i(gkmax)+i(gkmin)-2
	 else
	  imin	=	i(gkmin)
	  imax	=	i(gkmax)+i(gkmin)-1
	 endif
	 if gkmin==1&&gkmax==1 kgoto skip	;IF 'Num.wguides' AND 'Lowest' ARE BOTH '1', DON'T CREATE ANY REFLECTED WGUIDE1S AT ALL 	
	 aresL2	filterstack	asigL, kfreq*gkLDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, -gkinterval, kPortTime, gktype, imin, imax
	 aresR2	filterstack	asigR, kfreq*gkRDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, -gkinterval, kPortTime, gktype, imin, imax
	 if i(gkIterations)>1 then
	  aresL2	filterstack	aresL2*0.03, kfreq*gkLDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, -gkinterval, kPortTime, gktype, imin, imax
	  aresR2	filterstack	aresR2*0.03, kfreq*gkRDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, -gkinterval, kPortTime, gktype, imin, imax
	 endif
	 if i(gkIterations)>2 then
	  aresL2	filterstack	aresL2*0.03, kfreq*gkLDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, -gkinterval, kPortTime, gktype, imin, imax
	  aresR2	filterstack	aresR2*0.03, kfreq*gkRDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, -gkinterval, kPortTime, gktype, imin, imax
	 endif
	 if i(gkIterations)>3 then
	  aresL2	filterstack	aresL2*0.03, kfreq*gkLDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, -gkinterval, kPortTime, gktype, imin, imax
	  aresR2	filterstack	aresR2*0.03, kfreq*gkRDiff, gkRndFactor, kcutoff, gkLowCut, gkfeedback, -gkinterval, kPortTime, gktype, imin, imax
	 endif
	 aresL	+=				aresL2
	 aresR	+=				aresR2
	 skip:
	endif
	aresL	dcblock2	aresL
	aresR	dcblock2	aresR
	rireturn						;RETURN FROM REINIT
	

	/* EXTEND RELEASE */
	kenv		linsegr	1,i(gkRel),0
	aresL		=	aresL * kenv
	aresR		=	aresR * kenv
	ktime		timeinsts
	krms		rms	aresL,3
	if krms<0.00001&&ktime>0.2&&iMIDIflag==1 then
	 turnoff2	p1,4,0
	endif

	/* WET_DRY MIX */
	aOutL	ntrpol	asigL, aresL, gkMix
	aOutR	ntrpol	asigR, aresR, gkMix
	
			outs	aOutL*gkamp, aOutR*gkamp	;SEND wguide OUTPUT TO THE AUDIO OUTPUTS AND SCALE USING THE FLTK SLIDER VARIABLE gkamp
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>; HighpassFilter.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("Highpass Filter"), size(435, 90), pluginid("HPFl") style("legacy")
image pos(0, 0),                size(435, 90), colour(  70,120, 90), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
label    bounds(17, 22, 40, 11), text("INPUT"), fontcolour("white")
combobox bounds(10, 33, 60, 20), channel("input"), value(1), text("Live","Tone","Noise")
rslider  bounds( 75, 11, 70, 70), channel("cf"),        text("Freq."), colour(  0, 60, 30), trackercolour(200,255,200), 	textcolour("white"), 	range(20, 20000, 20, 0.333)
rslider  bounds(140, 11, 70, 70), channel("res"),       text("Res."),  colour(  0, 60, 30), trackercolour(200,255,200), 	textcolour("white"),	range(0,1.00,0)
rslider  bounds(205, 11, 70, 70), channel("mix"),       text("Mix"),   colour(  0, 60, 30), trackercolour(200,255,200),		textcolour("white"), 	range(0,1.00,1)
button  bounds(280,  10, 80, 20), text("12dB/oct","24dB/oct"), channel("steepness"), value(0)
label   bounds(280,  30, 80, 12), text("Steepness"), fontcolour("white")
checkbox bounds(280, 50, 80, 15), channel("ResType"),colour(yellow), fontcolour("white"),  value(0), text("Resonant")
rslider  bounds(360, 11, 70, 70), text("Level"),    colour(  0, 60, 30), trackercolour(200,255,200),		textcolour("white"), 	channel("level"), 	range(0, 1.00, 1)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 	= 	48000	;SAMPLE RATE
ksmps 	= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 	= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs	=	1
 
;Author: Iain McCurdy (2012)

instr	1
	kporttime	linseg	0,0.001,0.05
	/* READ IN WIDGETS */
	kcf			chnget	"cf"
	kres		chnget	"res"
	kmix		chnget	"mix"
	ksteepness	chnget	"steepness"
	kResType	chnget	"ResType"
	klevel		chnget	"level"
	klevel		portk	klevel,kporttime
	alevel		interp	klevel
	kcf	portk	kcf,kporttime
	acf	interp	kcf
	/* INPUT */
	kinput		chnget	"input"
	if kinput=1 then
	 aL,aR	ins
	elseif kinput=2 then
	 aL	vco2	0.2, 100
	 aR	=	aL
	else
	 aL	pinkish	0.2
	 aR	pinkish	0.2
	endif
	/* FILTER */
	if ksteepness==0&&kResType!=1 then
	 aFiltL	atone	aL,kcf
	 aFiltR	atone	aR,kcf
        elseif ksteepness==1&&kResType!=1 then
	 aFiltL	buthp	aL,acf
	 aFiltR	buthp	aR,acf
        elseif kResType==1 then
	 aFiltL	bqrez	aL,acf,1+(kres*40),1
	 aFiltR	bqrez	aR,acf,1+(kres*40),1
	endif
	aL	ntrpol	aL,aFiltL,kmix
	aR	ntrpol	aR,aFiltR,kmix
		outs	aL*alevel,aR*alevel
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
e
</CsScore>

</CsoundSynthesizer>
; LowpassFilter.csd
; Written by Iain McCurdy, 2012

<Cabbage>
form caption("Lowpass Filter") size(435, 90), pluginid("LPFl") style("legacy")
image    bounds(0, 0, 435, 90), colour(  70, 90,100), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
label    bounds( 22, 22, 38, 11), text("INPUT:"), fontcolour("white")
combobox bounds( 10, 33, 60, 20), channel("input"), value(1), text("Live","Tone","Noise")
rslider  bounds( 75, 11, 70, 70), channel("cf"),        text("Freq."), colour(  0, 40, 50), trackercolour(200,240,250), 	textcolour("white"), 	range(20, 20000, 20000, 0.333)
rslider  bounds(140, 11, 70, 70), channel("res"),       text("Res."),  colour(  0, 40, 50), trackercolour(200,240,250), 	textcolour("white"),	range(0,1.00,0)
rslider  bounds(205, 11, 70, 70), channel("mix"),       text("Mix"),   colour(  0, 40, 50), trackercolour(200,240,250),		textcolour("white"), 	range(0,1.00,1)
label    bounds(285, 10, 70, 12), text("Steepness:"), fontcolour("white")
button   bounds(280, 23, 80, 20), channel("steepness"), text("12dB/oct","24dB/oct"), value(0)
checkbox bounds(280, 50, 80, 15), channel("ResType"), fontcolour("white"),  value(0), text("Resonant"), colour(yellow)
rslider  bounds(360, 11, 70, 70), text("Level"),                       colour(  0, 40, 50), trackercolour(200,240,250),		textcolour("white"), 		channel("level"), 	range(0, 1.00, 1)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	48000	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

instr	1
	kporttime	linseg	0,0.001,0.05
	kcf		chnget	"cf"				;
	kres		chnget	"res"				;
	kmix		chnget	"mix"				;
	ksteepness	chnget	"steepness"			;
	kResType	chnget	"ResType"			;
	klevel		chnget	"level"				;
	klevel		portk	klevel,kporttime
	alevel		interp	klevel
	kcf	portk	kcf,kporttime
	acf	interp	kcf
	/* INPUT */
	kinput		chnget	"input"
	if kinput=1 then
	 aL,aR	ins
	elseif kinput=2 then
	 aL	vco2	0.2, 100
	 aR	=	aL
	else
	 aL	pinkish	0.2
	 aR	pinkish	0.2
	endif
	if ksteepness==0&&kResType!=1 then
	 aFiltL	tone	aL,kcf
	 aFiltR	tone	aR,kcf
        elseif ksteepness==1&&kResType!=1 then
	 aFiltL	butlp	aL,acf
	 aFiltR	butlp	aR,acf
        elseif kResType==1 then
	 aFiltL	moogladder	aL,acf,kres
	 aFiltR	moogladder	aR,acf,kres        
	endif
	aL	ntrpol	aL,aFiltL,kmix
	aR	ntrpol	aR,aFiltR,kmix
		outs	aL*alevel,aR*alevel
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; phaser1.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("phaser1") size(400, 90), pluginid("phs1") style("legacy")
image        pos(0, 0), size(400, 90), colour(80,20,20), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
label     bounds( 10, 15, 55, 12), text("INPUT"), fontcolour("white")
checkbox  bounds( 10, 30, 55, 12), text("Live"),  fontcolour("white"), channel("input"),  value(1), radiogroup(1)
checkbox  bounds( 10, 45, 55, 12), text("Noise"), fontcolour("white"), channel("input2"), value(0), radiogroup(1)
rslider  bounds( 60, 11, 70, 70),  text("Frequency"), channel("freq"),     range(20.0, 5000, 160, 0.25), colour(160,40,40), textcolour("white"), trackercolour(white)
rslider  bounds(125, 11, 70, 70),  text("Feedback"),  channel("feedback"), range(-0.99, 0.99, 0.9),      colour(160,40,40), textcolour("white"), trackercolour(white)
rslider  bounds(190, 11, 70, 70), text("N.Ords."),   channel("ord"),      range(1, 256, 32, 0.5,1),     colour(160,40,40), textcolour("white"), trackercolour(white)
rslider  bounds(255, 11, 70, 70), text("Mix"),       channel("mix"),      range(0, 1.00, 1),            colour(160,40,40), textcolour("white"), trackercolour(white)
rslider  bounds(320, 11, 70, 70), text("Level"),     channel("level"),    range(0, 1.00, 0.7),          colour(160,40,40), textcolour("white"), trackercolour(white)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

instr	1
	gkfreq		chnget	"freq"					;READ WIDGETS...
	gkfeedback	chnget	"feedback"				;
	gkord		chnget	"ord"					;
	gkmix		chnget	"mix"					;
	gklevel		chnget	"level"					;

	gkinput		chnget	"input"					;
	if gkinput==1 then
	 asigL,asigR	ins
	else
	 asigL	pinker
	 asigR	pinker
	endif

	kporttime	linseg	0,0.01,0.03				;CREATE A VARIABLE THAT WILL BE USED FOR PORTAMENTO TIME
	kfreq		portk	gkfreq, kporttime			;PORTAMENTO IS APPLIED TO 'SMOOTH' SLIDER MOVEMENT	
	kSwitch		changed	gkord					;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
	if	kSwitch=1	then					;IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
		reinit	UPDATE						;BEGIN A REINITIALISATION PASS FROM LABEL 'UPDATE'
	endif								;END OF CONDITIONAL BRANCH
	UPDATE:								;BEGIN A REINITIALISATION PASS FROM HERE
	aphaserl	phaser1		asigL, kfreq, gkord, gkfeedback	;PHASER1 IS APPLIED TO THE LEFT CHANNEL
	aphaserr	phaser1		asigR, kfreq, gkord, gkfeedback	;PHASER1 IS APPLIED TO THE RIGHT CHANNEL
	rireturn							;RETURN FROM REINITIALISATION PASS TO PERFORMANCE TIME PASSES
	amixL		ntrpol	asigL,aphaserl,gkmix
	amixR		ntrpol	asigR,aphaserr,gkmix
			outs	amixL*gklevel, amixR*gklevel		;PHASER OUTPUT ARE SENT TO THE SPEAKERS
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>


</CsoundSynthesizer>



























; phaser.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("phaser2") size(685, 90), pluginid("phs2") style("legacy")
image pos(0, 0),        size(685, 90), colour(0,0,25), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
label     bounds( 15, 15, 55, 12), text("INPUT"), fontcolour("white")
checkbox  bounds( 15, 30, 55, 12), text("Live"),  fontcolour("white"), channel("input"),  value(1), radiogroup(1)
checkbox  bounds( 15, 45, 55, 12), text("Noise"), fontcolour("white"), channel("input2"), value(0), radiogroup(1)
rslider  bounds( 70, 11, 70, 70),  text("Frequency"),  channel("freq"),     range(20.0, 5000, 100, 0.25), colour(100,100,200), trackercolour(silver), textcolour("white")
rslider  bounds(140, 16, 60, 60),  text("Port."),  channel("port"),     range(0, 30, 0.1, 0.5,0.01), colour(100,100,200), trackercolour(silver), textcolour("white")
rslider  bounds(195, 11, 70, 70),  text("Q"),          channel("q"),        range(0.01,10,1,0.5),            colour(100,100,200), trackercolour(silver), textcolour("white")
rslider  bounds(260, 11, 70, 70), text("N.Ords."),    channel("ord"),      range(1, 256, 8, 0.5,1),      colour(100,100,200), trackercolour(silver), textcolour("white")
label    bounds(335, 20, 61,12),  text("Sep. Mode:"), fontcolour("white")
rslider  bounds(410, 11, 70, 70), text("Separation"), channel("sep"),      range(-3, 3.00, 1),         colour(100,100,200), trackercolour(silver), textcolour("white")
rslider  bounds(475, 11, 70, 70), text("Feedback"),   channel("feedback"), range(-0.99, 0.99, 0.9),      colour(100,100,200), trackercolour(silver), textcolour("white")
rslider  bounds(540, 11, 70, 70), text("Mix"),        channel("mix"),      range(0, 1.00, 1),            colour(100,100,200), trackercolour(silver), textcolour("white")
rslider  bounds(605, 11, 70, 70), text("Level"),      channel("level"),    range(0, 1.00, 0.7),          colour(100,100,200), trackercolour(silver), textcolour("white")
combobox bounds(330, 34, 80,25), channel("mode"), value(1), text("Equal", "Power"), fontcolour("white")
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	48000	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

instr	1
	gkport		chnget	"port"
	kRampUp		linseg	0,0.001,1
	kfreq		chnget	"freq"					;READ WIDGETS...
	gkfreq		portk	kfreq,kRampUp*gkport
	kq		chnget	"q"					;
	gkq		portk	kq,kRampUp*gkport
	gkmode		chnget	"mode"					;
	gkmode		init	1
	gkmode		init	i(gkmode)-1
	ksep		chnget	"sep"					;
	gksep		portk	ksep,kRampUp*gkport
	gkfeedback	chnget	"feedback"				;
	gkord		chnget	"ord"					;
	gkmix		chnget	"mix"					;
	gklevel		chnget	"level"					;
	gkinput		chnget	"input"					;
	if gkinput==1 then
	 asigL,asigR	ins
	else
	 asigL	pinker
	 asigR	pinker
	endif
	kporttime	linseg	0,0.01,0.03				;CREATE A VARIABLE THAT WILL BE USED FOR PORTAMENTO TIME
	kfreq		portk	gkfreq, kporttime			;PORTAMENTO IS APPLIED TO 'SMOOTH' SLIDER MOVEMENT	
	kq		portk	gkq, kporttime				;PORTAMENTO IS APPLIED TO 'SMOOTH' SLIDER MOVEMENT
	ksep		portk	gksep, kporttime				;PORTAMENTO IS APPLIED TO 'SMOOTH' SLIDER MOVEMENT
	kSwitch		changed	gkord,gkmode				;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
	if	kSwitch=1	then					;IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
		reinit	UPDATE						;BEGIN A REINITIALISATION PASS FROM LABEL 'UPDATE'
	endif								;END OF CONDITIONAL BRANCH
	UPDATE:								;BEGIN A REINITIALISATION PASS FROM HERE
	aphaserl	phaser2		asigL, kfreq, kq, gkord, gkmode, ksep, gkfeedback	; PHASER2 IS APPLIED TO THE LEFT CHANNEL
	aphaserr	phaser2		asigR, kfreq, kq, gkord, gkmode, ksep, gkfeedback	; PHASER1 IS APPLIED TO THE RIGHT CHANNEL
	rireturn							;RETURN FROM REINITIALISATION PASS TO PERFORMANCE TIME PASSES

	aphaserl	dcblock2	aphaserl			;PHASER2 CAN TEND TO PRODUCE A DC OFFSET
	aphaserr	dcblock2	aphaserr
	
	amixL		ntrpol	asigL,aphaserl,gkmix
	amixR		ntrpol	asigR,aphaserr,gkmix
			outs	amixL*gklevel, amixR*gklevel		;PHASER OUTPUTS ARE SENT OUT
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>


</CsoundSynthesizer>



























; resony.csd
; Written by Iain McCurdy, 2012.

; Resony is an implementation of a stack of second-order bandpass filters whose centre frequencies are arithmetically 
; related. 
; The 'bandwidth' and 'scaling mode' parameters are as they are in the reson opcode. 

; CONTROLS
; --------
; 'Base Freq.' (base frequency) defines the centre frequency of the first filter. 

; 'Sep' (separation) normally defines the separation between the lowest and highest filter in the stack in octaves. 
; How this relates to what the actual frequencies of filters will be depends upon which separation mode has been selected. 
; This is explained below. Note that in this example the operation of 'ksep' has been modified slightly to allow the 
; opcode to be better controlled from the GUI. These modifications are clarified below. Separation can be defined in 
; octaves using the knob 'Sep.oct.' or in semitones using the 'Sep.semi.' knob.
; Making changes to 'Sep.Semi', either via the slider or the number box, will causes changes in the 'Sep.Oct' slider and 
; number box (but not vice versa).

; 'Separatation Mode' defines the the way additional reson filters are arranged according to the 'Sep' value'. In 
; 'oct.total' separation mode, the pitch interval between the base frequency and (base frequency + separation is divided 
; into equal intervals according to the number of filters that have been selected. Note that no filter is created at the 
; frequency of (base frequency + separation). For example: if separation=1 and num.filters=2, filters will be created at 
; the base frequency and a tritone above the base frequency (i.e. an interval of 1/2 and an octave). I suspect this is a 
; mistake in the opcode implementation so in this example I rescale the separation interval before passing it to the 
; resony opcode so that the interval between the lowest and highest filter in this mode will always be the interval 
; defined in the GUI. 
; If 'hertz' separation mode is selected behaviour is somewhat curious. I have made some other modifications to the 
; values passed to the opcode to make this mode more controllable. Without these modifications, if number of filters is 
; '1' no filters would be created. The frequency relationship between filters in the stack always follows the harmonic 
; series. Both 'Base Frequency' and 'Separation' normally shift this harmonic stack of filters up or down, for this reason 
; I have disabled user control of 'Separation' in this mode, instead a value equal to the 'Number of Filters' will always 
; be used for 'Separation'. This ensures that a harmonic stack will always be created built upon 'Base Frequency' as the 
; fundamental. Negative values for 'separation' are allowed whenever 'separation mode' is 'octaves' (if this is the case, 
; the stack of frequencies will extend below the base frequency). Negative values for 'separation' when 'separation mode' 
; is 'hertz' will cause filters to 'explode'. As 'Separation' is fixed at 'Number of Filters' in this example this 
; explosion will not occur.

; A third option I have provided allows the defined interval to be the interval between adjacent filters rather than the 
; interval from lowest to highest. In this mode it is probably wise to keep the separation value lowish, or reduce the 
; number of filters (or both), otherwise filters with very high frequencies might be being requested. This could potentially
; lead to some rather unpleasant distortion. In actuality there is some protection against this (discussed later on).

; 'B.width'	-	bandwidth of the filters (in hertz).

; 'Num.' (number of filters) defines the number of filters in the stack. 

; 'Scaling Mode'	-	provides options for scaling the amplitude of the filters. If 'none' is chosen output
; 				amplitude can increase greatly, particularly if bandwidth is narrow (a low value).
;				

; In addition a lowpass and highpass filter have been added after the resony filter
;
;         +--------+   +----------+   +---------+
; INPUT---+ RESONY +---+ HIGHPASS +---+ LOWPASS +---OUTPUT
;         +--------+   +----------+   +---------+
;
; The cutoff frequencies of each of these filters are defined as ratios relative to the base frequency. 
;
; Unpleasant sounds can result if reson filters are given too high cutoff frequencies. This can occur through a combination
; of the settings for 'BF' (base frequency), 'Num.' (number of filters), 'Sep.' (separation) and 'Separation Mode'. This 
; instrument features a safety measure whereby if this is going to happen the 'Num.' value will be reduced. If you notice
; the 'Num.' slider moving by itself while you are making adjustments to other controls this is the reason. This safety 
; mechanism is most likely to cut when 'Octs Adjacent' mode is selected. 


<Cabbage>
form caption("resony") size(750,180), pluginid("rsny"), colour(255,100,0) style("legacy")
image        bounds(  0,  0,750,180), colour("black"), shape("rounded"), outlinecolour(255,100,0), outlinethickness(2) 
label     bounds( 10, 20, 80, 12), text("INPUT:")
button    bounds( 10, 35, 80, 35), text("Live","Noise"),     channel("input"), value(0)
rslider   bounds( 90, 10, 70, 70), text("Base Freq"),       fontcolour("white"), channel("bf"),   range(20, 20000, 909, 0.5), colour(255,100,0,255), trackercolour(255,250,100)
nslider bounds(160, 15, 70, 40), text("Base Freq"),        channel("bf"),   range(20, 20000, 909, 0.5)
rslider   bounds(230, 10, 70, 70), text("B.width"),         fontcolour("white"), channel("bw"),   range(0.01, 500, 13, 0.375, 0.0001), colour(255,100,0,255), trackercolour(255,250,100)
rslider   bounds(300, 10, 70, 70), text("Num."),            fontcolour("white"), channel("num"),  range(1, 80, 10, 1,1),      colour(255,100,0,255), trackercolour(255,250,100)
rslider   bounds(370, 10, 70, 70), text("Sep.oct."),        fontcolour("white"), channel("sep"),  range(-11, 11, 2,1,0.001),          colour(255,100,0,255), trackercolour(255,250,100)
nslider bounds(440, 15, 70, 40), text("Sep.oct"),          channel("sep"),  range(-11, 11, 2,1,0.001)
rslider   bounds(510, 10, 70, 70), text("Sep.semi."),       fontcolour("white"), channel("sep2"), range(-48, 48, 24,1,1),     colour(255,100,0,255), trackercolour(255,250,100)
nslider bounds(580, 15, 70, 40), text("Sep.semi."),        channel("sep2"),  range(-48, 48, 24,1,0.001)

rslider   bounds(660, 10, 70, 70), text("Level"),           fontcolour("white"), channel("gain"), range(0,2,1,0.25,0.00001),  colour(255,100,0,255), trackercolour(255,250,100)

label     bounds(450,100,130, 13), text("Separation Mode")
combobox  bounds(450,115,130, 25), channel("sepmode"), value(1), text("octs.total", "hertz", "octs.adjacent")
label     bounds(600,100,130, 13), text("Scaling Mode")
combobox  bounds(600,115,130, 25), channel("scl"), value(2), text("none", "peak response", "RMS")


image    bounds( 30, 90,180, 80), colour(0,0,0,0), outlinecolour(150,150,150), outlinethickness(1), plant("highpass"), {
checkbox bounds( 20, 15,100, 20), text("Highpass"), channel("HPF_OnOff")
rslider  bounds(100,  5, 70, 70), text("Ratio"),           fontcolour("white"), channel("HPF_Ratio"), range(0.1, 16, 0.1, 0.5,0.0001),  colour(255,100,0,255), trackercolour(255,250,100)
}

image    bounds(240, 90,180, 80), colour(0,0,0,0), outlinecolour(150,150,150), outlinethickness(1), plant("lowpass"), {
checkbox bounds( 20, 15,100, 20), text("Lowpass"), channel("LPF_OnOff")
rslider  bounds(100,  5, 70, 70), text("Ratio"),           fontcolour("white"), channel("LPF_Ratio"), range(0.1, 32, 32, 0.25,0.00001),  colour(255,100,0,255), trackercolour(255,250,100)
}

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

;A UDO IS CREATED WHICH ENCAPSULATES THE MODIFICATIONS TO THE resony OPCODE DISCUSSED IN THIS EXAMPLE 
opcode	resony2,a,akkikii
	ain, kbf, kbw, inum, ksep , isepmode, iscl	xin

	;IF 'Octaves (Total)' MODE SELECTED...
	if isepmode==0 then
	 irescale	divz	inum,inum-1,1	;PREVENT ERROR IF NUMBER OF FILTERS = ZERO
	 ksep	=	ksep * irescale		;RESCALE SEPARATION
	  
	;IF 'Hertz' MODE SELECTED...	
	elseif isepmode==1 then
	 inum	=	inum + 1		;AMEND QUIRK WHEREBY NUMBER RESONANCES PRODUCED IN THIS MODE WOULD ACTUALLY BE 1 FEWER THAN THE VALUE DEMANDED
	 ksep	=	inum			;ksep IS NOT ESSESNTIAL IN THIS MODE, IT MERELY DOUBLES AS A BASE FREQUENCY CONTROL. THEREFORE SETTING IT TO NUMBER OF BANDS ENSURES THAT BASE FREQUENCY WILL ALWAYS BE DEFINED ACCURATELY BY kbf VALUE
			 
	;IF 'Octaves (Adjacent)' MODE SELECTED...
	elseif isepmode==2 then 
	 irescale	divz	inum,inum-1,1	;PREVENT ERROR IF NUMBER OF FILTERS = ZERO
	 ksep = ksep * irescale			;RESCALE SEPARATION
	 ksep = ksep * (inum-1)			;RESCALE SEPARATION INTERVAL ACCORDING TO THE NUMBER OF FILTERS CHOSEN
	 isepmode	=	0		;ESSENTIALLY WE ARE STILL USING MODE:0, JUST WITH THE ksep RESCALING OF THE PREVIOUS LINE ADDED	 

	endif
	
	aout 		resony 	ain, kbf, kbw, inum, ksep , isepmode, iscl
			xout	aout
endop


instr	1	
	kporttime	linseg	0,0.001,0.005,1,0.05	;CREATE A VARIABLE FUNCTION THAT RAPIDLY RAMPS UP TO A SET VALUE	
	
	loop:
	gkbf	chnget	"bf"
	gkbw	chnget	"bw"
	gkgain	chnget	"gain"
	gknum	chnget	"num"
	gksep	chnget	"sep"				; octaves
	gksepmode	chnget	"sepmode"
	gksepmode	=	gksepmode - 1
	gksepmode	init	1
	gkscl	chnget	"scl"
	gkscl	=	gkscl - 1
	gkscl	init	1
	gkinput		chnget	"input"
	gkHPF_OnOff	chnget	"HPF_OnOff"
	kHPF_Ratio	chnget	"HPF_Ratio"
	gkLPF_OnOff	chnget	"LPF_OnOff"
	kLPF_Ratio	chnget	"LPF_Ratio"
	
	kbf		portk	gkbf, kporttime		; SMOOTH MOVEMENT OF SLIDER VARIABLES
	ksep		portk	gksep, kporttime
	kLPF_Ratio	portk	kLPF_Ratio, kporttime
	kHPF_Ratio	portk	kHPF_Ratio, kporttime

	if gkinput==0 then
	 asigL,asigR	ins
	else
	 asigL	pinkish	1
	 asigR	pinkish	1
	endif

	; DISCERN FREQUENCY OF HIGHEST RESON DEPENDING ON SEPARATION MODE CHOSEN
	if gksepmode==0 then
	 kmax	=	gknum==1 ? kbf : kbf * abs(ksep) * 2
	elseif gksepmode==1 then
	 kmax	=	kbf * gknum
	else
	 kmax	=	gknum==1 ? kbf : kbf * (gknum-1) * abs(ksep) * 2
	endif

	; TEST HIGHEST RESON FREQUENCY. 
	; IF IT IS TOO HIGH, UNPLEASANT NOISE WILL BE PRODUCED SO REDUCE THE NUMBER OF RESONS THEN LOOP BACK (AND TEST AGAIN)
	if kmax>(sr/5) then	; things seems to start to sound unpleasant if resons are placed at frequencies sr/5 or higher	
	 chnset	gknum-1,"num"	; decrement 'Num.' slider...
	 kgoto	loop		; and loop back (in order to test again)
	endif


	kSwitch		changed	gkscl, gknum, gksepmode		;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
	if	kSwitch=1	then		;IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
		reinit	START			;BEGIN A REINITIALISATION PASS FROM LABEL 'START'
	endif
	START:
	
	isepmode	init	i(gksepmode)
	inum		init	i(gknum)	
	iscl		init	i(gkscl)
	
	;CALL resony2 UDO
	aresL 		resony2 asigL, kbf, gkbw, inum, ksep , isepmode, iscl
	aresR 		resony2	asigR, kbf, gkbw, inum, ksep , isepmode, iscl
		
	rireturn	;RETURN FROM REINITIALISATION PASS TO PERFORMANCE TIME PASSES

	if gkHPF_OnOff==1 then
	 aresL	buthp	aresL, kbf*kHPF_Ratio
	 aresR	buthp	aresR, kbf*kHPF_Ratio
	endif

	if gkLPF_OnOff==1 then
	 kcf	limit	kbf*kLPF_Ratio, 0, sr/2
	 aresL	butlp	aresL, kcf
	 aresR	butlp	aresR, kcf
	endif

			outs	aresL * gkgain, aresR * gkgain	;SEND FILTER OUTPUT TO THE AUDIO OUTPUTS AND SCALE USING THE FLTK SLIDER VARIABLE gkgain
endin

instr	UpdateWidgets
	ksep2	chnget	"sep2"
	ktrig2	changed	ksep2
	if  ktrig2==1 then
	 chnset	ksep2/12, "sep"
	endif
endin

</CsInstruments>

<CsScore>
i 1 0.1 [3600*24*7]
i "UpdateWidgets" 0 3600	;UPDATE SEPARATION DISPLAY BOX
</CsScore>

</CsoundSynthesizer>
; Vocoder.csd
; Written by Iain McCurdy, 2012

<Cabbage>
form caption("vocoder"), size(530, 230), pluginid("voco") style("legacy")

image pos(0, 0), size(530, 200), colour(255,255,150), shape("rounded"), outlinecolour("white"), line(1)

image 	bounds(140,  6,180, 31), colour( 10,225, 90,100), shape("ellipse"), outlinecolour(205,205, 70), line(1)
label   bounds(158,  5, 33, 33), text("v"), FontColour(100,100,100)
label   bounds(178,  5, 33, 33), text("o"), FontColour(100,100,100)
label   bounds(198,  5, 33, 33), text("c"), FontColour(100,100,100)
label   bounds(218,  5, 33, 33), text("o"), FontColour(100,100,100)
label   bounds(238,  5, 33, 33), text("d"), FontColour(100,100,100)
label   bounds(258,  5, 33, 33), text("e"), FontColour(100,100,100)
label   bounds(278,  5, 33, 33), text("r"), FontColour(100,100,100)
label   bounds(161,  4, 30, 30), text("v"), FontColour(255,  0,  0)
label   bounds(181,  4, 30, 30), text("o"), FontColour(235,  0, 20)
label   bounds(201,  4, 30, 30), text("c"), FontColour(215,  0, 40)
label   bounds(221,  4, 30, 30), text("o"), FontColour(195,  0, 60)
label   bounds(241,  4, 30, 30), text("d"), FontColour(175,  0, 80)
label   bounds(261,  4, 30, 30), text("e"), FontColour(155,  0,100)
label   bounds(281,  4, 30, 30), text("r"), FontColour(135,  0,120)

label    bounds( 12,  9, 75, 11), text("Carrier Source"), FontColour("black")
image 	 bounds(  9, 20, 87, 18), colour("black"), shape("sharp")
combobox bounds( 10, 21, 85, 16), channel("CarSource"), value(1), text("synth","external"), fontcolour(black), colour(255,255,200)
label    bounds( 10, 39, 85, 11), text("Filter Steepness"), FontColour("black")
image 	 bounds(  9, 50, 87, 18), colour("black"), shape("sharp")
combobox bounds( 10, 51, 85, 16), channel("steepness"), value(2), text("12dB/oct","24dB/oct"), fontcolour(black), colour(255,255,200)
label    bounds( 20, 69, 60, 11), text("Synth Type"), FontColour("black")
image 	 bounds(  9, 80, 87, 18), colour("black"), shape("sharp")
combobox bounds( 10, 81, 85, 16), channel("SynType"), value(1), text("saw","square","pulse","noise"), fontcolour(black), colour(255,255,200)

rslider bounds(105, 38, 70, 70), text("Base"),    colour( 55,105,50), textcolour("Black"), channel("base"),  range(24, 80, 40,1,1),  trackercolour(150,255,150)
rslider bounds(165, 38, 70, 70), text("Num."),    colour( 55,105,50), textcolour("Black"), channel("num"),   range(1, 100, 16,1,1),  trackercolour(150,255,150)
rslider bounds(225, 38, 70, 70), text("B.width"), colour( 55,105,50), textcolour("Black"), channel("bw"),    range(0.01, 1, 0.1,0.5),  trackercolour(150,255,150)
rslider bounds(285, 38, 70, 70), text("Spacing"), colour( 55,105,50), textcolour("Black"), channel("incr"),  range(1, 12, 5,0.5),  trackercolour(150,255,150)
rslider bounds(445, 38, 70, 70), text("Level"),   colour( 55,105,50), textcolour("Black"), channel("level"), range(0, 5.00, 1,0.5),  trackercolour(150,255,150)

vslider bounds(350, 10, 50, 90), colour( 55,105,50), textcolour("Black"), channel("BPGain"), range(0, 1, 0.6, 0.5),  trackercolour(150,255,150)
vslider bounds(400, 10, 50, 90), colour( 55,105,50), textcolour("Black"), channel("HPGain"), range(0, 1, 0.25, 0.5), trackercolour(150,255,150)
label   bounds(365, 95, 25, 12), text("BPF"), FontColour("black")
label   bounds(415, 95, 25, 12), text("HPF"), FontColour("black")

checkbox bounds(440, 10, 80, 13), channel("gate"), text("Gate Input"), value(0), shape("square"), fontcolour("black")

keyboard bounds(10, 112, 510,80)
infobutton bounds(5,205, 100, 20), text("Help"), file("VocoderHelp.html")
image bounds(105, 205, 320, 20), colour(75, 85, 90, 50), plant("credit"){
label bounds(0.03, 0.1, .6, .7), text("Author: Iain McCurdy |2012|"), FontColour("LightGreen")
}

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE
massign	0,2

gisine	ftgen	0,0,4096,10,1
gaSyn	init	0

opcode VocoderChannel, a, aakiiiii				;MODE UDO 
	aMod,aCar,ksteepness,ibase,ibw,iincr,icount,inum  xin	;NAME INPUT VARIABLES
	icf	=	cpsmidinn(ibase+(icount*iincr))		;DERIVE FREQUENCY FOR *THIS* BANDPASS FILTER BASED ON BASE FREQUENCY AND FILTER NUMBER (icount)
	icount	=	icount + 1				;INCREMENT COUNTER IN PREPARTION FOR NEXT FILTER
	
	if	icf>15000 goto SKIP				;IF FILTER FREQUENCY EXCEEDS A SENSIBLE LIMIT SKIP THE CREATION OF THIS FILTER AND END RECURSION
	
	aModF	butbp	aMod,icf,ibw*icf			;BANDPASS FILTER MODULATOR
	
	if ksteepness=2 then					;IF 24DB PER OCT MODE IS CHOSEN...
	  aModF	butbp	aModF,icf,ibw*icf			;...BANDPASS FILTER AGAIN TO SHARPEN CUTOFF SLOPES
	endif							;END OF THIS CONDITIONAL BRANCH
	aEnv 	follow2	aModF, 0.05, 0.05			;FOLLOW THE ENVELOPE OF THE FILTERED AUDIO

	aCarF	butbp	aCar,icf,ibw*icf			;BANDPASS FILTER CARRIER
	if ksteepness=2 then					;IF 24 DB PER OCT IS CHOSEN...
	  aCarF	butbp	aCarF,icf,ibw*icf			;...BANDPASS FILTER AGAIN TO SHARPEN CUTOFF SLOPES
	endif							;END OF THIS CONDITIONAL BRANCH

	amix	init	0					;INITIALISE MIX VARIABLE CONTAINING ALL SUBSEQUENT BANDS
	
	if	icount < inum	then					;IF MORE FILTERS STILL NEED TO BE CREATED...
		amix	VocoderChannel	aMod,aCar,ksteepness,ibase,ibw,iincr,icount,inum	;...CALL UDO AGAIN WITH INCREMENTED COUNTER
	endif								;END OF THIS CONDITIONAL BRANCH
	SKIP:							;LABEL
		xout	amix + (aCarF*aEnv)			;MIX LOCAL BAND WITH SUBSEQUENT BANDS GENERATED VIA RECURSION
endop								;END OF UDO

instr	1	;READ IN WIDGETS
	gkCarSource	chnget	"CarSource"
	gkbase		chnget	"base"
	gknum           chnget	"num"
	gkbw            chnget	"bw" 	
	gkincr          chnget	"incr"	
	gkBPGain        chnget	"BPGain"
	gkHPGain        chnget	"HPGain"
	gksteepness     chnget	"steepness"
	gkSynType	chnget	"SynType"
	gkgate		chnget	"gate"
	gklevel		chnget	"level"
endin

instr	2	;SIMPLE SYNTH
	icps	cpsmidi				;READ MIDI NOTE IN CPS FORMAT
	icps	=	icps*0.5		;TRANSPOSE DOWN AND OCTAVE
	aenv	linsegr	0,0.01,1,0.02,0		;CREATE A SIMPLE GATE-TYPE ENVELOPE

	if gkSynType==1 then			;IF SYNTH TYPE CHOSEN FROM BUTTON BANK GUI IS SAWTOOTH...
	 a1	vco2	1,icps			;...CREATE A SAWTOOTH WAVE TONE
	 a1	tone	a1,12000		;LOWPASS FILTER THE SOUND
	elseif gkSynType=2 then			;IF SYNTH TYPE CHOSEN FROM BUTTON BANK GUI IS SQUARE...
	 a1	vco2	1,icps,2,0.5		;...CREATE A SQUARE WAVE TONE
	 a1	tone	a1,12000		;LOWPASS FILTER THE SOUND
	elseif gkSynType=3 then			;IF SYNTH TYPE CHOSEN FROM BUTTON BANK GUI IS PULSE...
	 a1	vco2	1,icps,2,0.1		;...CREATE A PULSE WAVE TONE
	 a1	tone	a1,12000		;LOWPASS FILTER THE SOUND
	else					;OTHERWISE...
	 a1	pinkish	10			;...CREATE SOME PINK NOISE
	 a1	butbp	a1,icps,icps		;BANDPASS FILTER THE SOUND. BANDWIDTH = 1 OCTAVE. NARROW BANDWIDTH IF YOU WANT MORE OF A SENSE OF PITCH IN THE NOISE SIGNAL.
	endif					;END OF THIS CONDITIONAL BRANCH
	gaSyn	=	gaSyn + (a1*aenv)	;APPLY ENVELOPE
endin

instr	3
	ktrig	changed	gkbase,gkbw,gknum,gkincr	;IF ANY OF THE INPUT VARIABLE ARE CHANGED GENERATE A MOMENTARY '1' VALUE (A BANG IN MAX-MSP LANGUAGE)
	if ktrig=1 then					;IF A CHANGED VALUE TRIGGER IS RECEIVED...
	  reinit UPDATE					;REINITIALISE THIS INSTRUMENT FROM THE LABEL 'UPDATE'
	endif						;END OF THIS CONDITIONAL BRANCH
	UPDATE:						;LABEL
	ibase	init	i(gkbase)			;CREATE AN INITIALISATION TIME VARIABLE FROM FLTK GUI CONTROL
	inum	init	i(gknum)			;CREATE AN INITIALISATION TIME VARIABLE FROM FLTK GUI CONTROL
	ibw	init	i(gkbw)				;CREATE AN INITIALISATION TIME VARIABLE FROM FLTK GUI CONTROL
	iincr	init	i(gkincr)			;CREATE AN INITIALISATION TIME VARIABLE FROM FLTK GUI CONTROL
	
	aMod	inch	1				;READ LIVE AUDIO FROM THE COMPUTER'S LEFT INPUT CHANNEL
	
	;GATE MODULATOR SIGNAL
	if gkgate==1 then				;IF 'Gate Modulator' SWITCH IS ON....
	 krms	rms	aMod				;SCAN RMS OF MODUALTOR SIGNAL
	 kgate	=	(krms<0.05?0:1)			;IF RMS OF MODULATOR SIGNAL IS BELOW A THRESHOLD, GATE WILL BE CLOSED (ZERO) OTHERWISE IT WILL BE OPEN ('1'). LOWER THE THRESHOLD IF THE GATE IS CUTTING OUT TOO MUCH DESIRED SIGNAL, RAISE IT IF TOO MUCH EXTRANEOUS NOISE IS ENTERING THE OUTPUT SIGNAL.
	 kgate	port	kgate,0.01			;DAMP THE OPENING AND CLOSING OF THE GATE SLIGHTLY
	 agate	interp	kgate				;INTERPOLATE GATE VALUE AND CREATE AN A-RATE VERSION
	 aMod	=	aMod * agate			;APPLY THE GATE TO THE MODULATOR SIGNAL
	endif
	
	if gkCarSource==1 then				;IF 'SYNTH' IS CHOSEN AS CARRIER SOURCE...
	 aCar	=	gaSyn				;...ASSIGN SYNTH SIGNAL FROM INSTR 2 AS CARRIER SIGNAL
	else						;OTHERWISE...
	 aCar	inch	2				;READ AUDIO FROM RIGHT INPUT CHANNEL FOR CARRIER SIGNAL
	endif
		
	icount	init	0				;INITIALISE THE FILTER COUNTER TO ZERO
		amix	VocoderChannel	aMod,aCar,gksteepness,ibase,ibw,iincr,icount,inum	;CALL 'VocoderChannel' UDO - (WILL RECURSE WITHIN THE UDO ITSELF FOR THEW REQUIRED NUMBER OF FILTERS
		
	;HIGH-PASS CHANNEL
	iHPcf	=	cpsmidinn(ibase+(inum*iincr)+1)	;HIGHPASS FILTER CUTOFF (ONE INCREMENT ABOVE THE HIGHEST BANDPASS FILTER)
	iHPcf	limit	iHPcf,2000,18000		;LIMIT THE HIGHPASS FILTER TO BE WITHIN SENSIBLE LIMITS

	aModHP	buthp	aMod, iHPcf			;HIGHPASS FILTER THE MODULATOR
	aEnv	follow2	aModHP,0.01,0.01		;FOLLOW THE HIGHPASS FILTERED MODULATOR'S AMPLITUDE ENVELOPE
	aCarHP	buthp	aCar, iHPcf			;HIGHPASS FILTER THE CARRIER
	amix	=	((amix*gkBPGain*5)+(aCarHP*aEnv*gkHPGain*3))*gklevel	;MIX THE HIGHPASS FILTERED CARRIER WITH THE BANDPASS FILTERS. APPLY THE MODULATOR'S ENVELOPE.

		outs	amix,amix			;SEND AUDIO TO THE OUTPUTS
		clear	gaSyn				;CLEAR THE INTERNAL SYNTH ACCUMULATING GLOBAL VARIABLE, READ FOR THE NEXT PERF. PASS
	rireturn					;RETURN FROM REINITIALISATION PASS. (NOT REALLY NEED AS THE endin FULFILS THE SAME FUNCTION.)
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]	;READ IN WIDGETS
i 3 0 [60*60*24*7]	;VOCODER
</CsScore>

</CsoundSynthesizer>; wguide1.csd
; Written by Iain McCurdy, 2013,2015.

; Encapsulation of the 'wguide1' opcode, used for filtering and synthesis.
; A waveguide filter produces resonance peaks that follow the frequencies of the harmonic series with diminishing strength above its defined base frequency.

; frequency of the wave guide can be determined either in hertz of as a note number

; Activating the 'Keyboard Input' switch will allow frequency control from the keyboard (internal or external) and polyphony. 
;  In this mode, 'Frequency' and 'Note Num.' controls will be disabled.

; Source input sound can be either 'live audio input', or synthetic gravel, dust, air, a click or a pluck.
;  Click and pluck are intended to used with 'Keyboard Input' activated.

; Frequency	-	frequency of the waveguide
; Note Num.	-	frequency of the waveguide expressed as a note number
; Width		-	offsets the frequencies of the left and right channels to imbue added stereo width
; Cutoff	-	cutoff frequency of a lowpass filter within the feedback loop of the waveguide
;			 cutoff can be defined as a fixed value (in hertz) or as a ratio with the frequency of the waveguide (Ratio x Frequency = cutoff)
; Feedback	-	feedback ratio of the waveguide unit.
;			 negative feedback will shift the fundemental down one octave and only odd harmonics will be preset

; Bandpass Filter
; ---------------
; A double butterworth bandpass filter can be inserted, the cutoff frequency of which relates to the frequency defined for the waveguide.
; Bandpass On/Off	-	turns the bandpass filter on and off
; Balance	-	inserts a dynamic balancing to compensate for power loss on account of the bandpass filtering
; Width		-	bandwidth of the filters
; Harm.		-	ratio of bandpass filter cutoff to waveguide frequency: Harm x Frequency = bandpass cutoff frequency

; Mix	-	dry/wet mix
; Level	-	amplitude scaling

<Cabbage>
form caption("wguide1") size(650,200), pluginid("WGu1"), scrollbars(0) style("legacy")
image           bounds(0, 0, 650,120), colour(125, 95, 55), shape("sharp"), outlinecolour(225,195,155), outlinethickness(2) 
label   bounds(505,  4,136, 17), align("centre"), text("W A V E G U I D E"), fontcolour(silver), align("left")
image   bounds(510,  7,125,  1), colour(200,170,130), shape("sharp"), outlinecolour(silver), outlinethickness(1)
image   bounds(512, 18,124,  1), colour(200,170,130), shape("sharp"), outlinecolour(silver), outlinethickness(1)
checkbox bounds( 20,  7,120, 12), text("Keyboard Input"), channel("input"), fontcolour("white"), colour(yellow)
checkbox bounds( 20, 22,120, 12), text("Low Cut"), channel("LowCut") fontcolour("white") colour(yellow) value(0)
label    bounds(140,  5, 62, 11), text("Source"), fontcolour("white")
combobox bounds(140, 16, 62, 16), channel("source"), value(1), text("Live","Gravel","Dust","Air","Click","Pluck")
image    bounds( 10, 41,145, 70), colour(0,0,0,0), plant("GUIcontrol"), identchannel("NoKeyboardID"), visible(1) {
rslider  bounds(  0,  0, 70, 70),  text("Frequency"),  channel("freq"),      trackercolour(225,195,155), range(8.2, 12542, 160, 0.25),  colour( 85, 55,15), textcolour(white), fontcolour("silver")
rslider  bounds( 65,  0, 70, 70),  text("Note Num."),  channel("notnum"),    trackercolour(225,195,155), range(0, 127, 51, 1,1),        colour( 85, 55,15), textcolour(white), fontcolour("silver")
}
rslider  bounds(140, 41, 70, 70),  text("Width"),      channel("StWidth"),   trackercolour(225,195,155), range(-0.2, 0.2, 0, 1,0.001),        colour( 85, 55,15), textcolour(white), fontcolour("silver")

image    bounds(207,  4, 66,112), colour(125, 95, 55), outlinecolour("silver"), outlinethickness(1), line(1)
label    bounds(212,  8, 56, 11),  text("Cutoff"), fontcolour("white")
combobox bounds(212, 20, 56, 15),  text("Fixed","Ratio"),channel("CutoffMode"), value(1)
rslider  bounds(205, 41, 70, 70),  text("Hertz"),     channel("cutoff"),     trackercolour(225,195,155), range(20,20000,8000,0.25), visible(1), colour( 85, 55,15), textcolour(white), fontcolour("silver"), identchannel("cutoff_ident")
rslider  bounds(205, 41, 70, 70),  text("Ratio"),     channel("CutoffRatio"),trackercolour(225,195,155), range(1,40,8),             visible(0), colour( 85, 55,15), textcolour(white), fontcolour("silver"), identchannel("CutoffRatio_ident")

rslider  bounds(270, 41, 70, 70),  text("Feedback"),   channel("feedback"),   trackercolour(225,195,155), range(-0.9999999, 0.9999999, 0.8), colour( 85, 55,15), textcolour(white), fontcolour("silver")

line     bounds(345,  5,  2,110)
checkbox bounds(365,  7,120, 12), text("Bandpass On/Off"), channel("BPFOnOff") fontcolour("white") colour(yellow) value(0)
checkbox bounds(365, 22,120, 12), text("Balance"),         channel("BalanceOnOff") fontcolour("white") colour(yellow) value(0)
rslider  bounds(355, 41, 70, 70),  text("Bandwidth"),      channel("Bandwidth"),   trackercolour(225,195,155), range(0.001,100.00,0.2,0.5,0.001),             colour( 85, 55,15), textcolour(white), fontcolour("silver")
rslider  bounds(420, 41, 70, 70),  text("Harm."),          channel("HarmRatio"),trackercolour(225,195,155), range(1,48,1,1,1),             colour( 85, 55,15), textcolour(white), fontcolour("silver")
line     bounds(495,  5,  2,110)

rslider  bounds(505, 41, 70, 70),  text("Mix"),        channel("mix"),       trackercolour(225,195,155), range(0, 1.00, 1),             colour( 85, 55,15), textcolour(white), fontcolour("silver")
rslider  bounds(570, 41, 70, 70),  text("Level"),      channel("level"),     trackercolour(225,195,155), range(0, 5.00, 0.7,0.5,0.001),           colour( 85, 55,15), textcolour(white), fontcolour("silver")

keyboard bounds(  0,210, 650, 80), visible(1), identchannel("keyboardID")

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
;-d -n
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1
massign	0,2

; Author: Iain McCurdy (2012)


instr	1
	kporttime	linseg	0,0.01,0.03				; CREATE A VARIABLE THAT WILL BE USED FOR PORTAMENTO TIME
	gkinput		chnget	"input"					; READ WIDGETS...
	gkLowCut	chnget	"LowCut"
	gkfreq		chnget	"freq"
	gknotnum	chnget	"notnum"
	gkBPFOnOff	chnget	"BPFOnOff"
	gkBalanceOnOff	chnget	"BalanceOnOff"
	gkBandwidth	chnget	"Bandwidth"
	gkHarmRatio	chnget	"HarmRatio"
	gkHarmRatio	port	gkHarmRatio,0.5
	gkCutoffMode	chnget	"CutoffMode"
	gkCutoffMode	init	1
	gkcutoff	chnget	"cutoff"
	gkCutoffRatio	chnget	"CutoffRatio"
	gkfeedback	chnget	"feedback"
	gkmix		chnget	"mix"
	gkmix		portk	gkmix,kporttime
	gklevel		chnget	"level"
	gklevel		portk	gklevel,kporttime
	gkfreq		portk	gkfreq,kporttime
	gafreq		interp	gkfreq
	gkStWidth	chnget	"StWidth"

	if changed(gkinput)==1||timeinstk()==1 then
	 chnset	sprintfk("visible(%d)",1-gkinput),"NoKeyboardID"
;	 chnset	sprintfk("visible(%d)",gkinput),"keyboardID"	 
	endif

	schedkwhen	trigger(gkinput,0.5,0),0,0,99,0,1,210,115
	schedkwhen	trigger(gkinput,0.5,1),0,0,99,0,1,120,210

	ktrig1		changed	gkfreq
	ktrig2		changed	gknotnum
	if ktrig1==1 then						; DUAL FREQUENCY AND NOTE NUMBER CONTROLS
	 koct	=	octcps(gkfreq)
	 chnset	(koct-3)*12,"notnum"
	elseif ktrig2==1 then
	 chnset	cpsmidinn(gknotnum),"freq"
	endif
	
	event_i	"i",2,0,-1
	ktrig	trigger	gkinput,0.5,2
	if ktrig=1 then
	 if gkinput=0 then
	  event	"i",2,0,-1
	 else
	  turnoff2	2,0,0
	 endif
	endif

	/* SOURCE SOUND */
	gksource	chnget	"source"
	if gksource==1 then
 	 gasigL, gasigR	ins
 	elseif gksource==2 then
 	 gasigL	gausstrig	0.5, 100, 8, 0
 	 gasigR	gausstrig	0.5, 100, 8, 0
 	elseif gksource==3 then
 	 kdens	random	475,525
	 gasigL	dust2	0.5, kdens
 	 kdens	random	525,475
	 gasigR	dust2	0.5, kdens
 	elseif gksource==4 then
	 gasigL	pinkish	0.2
	 gasigR	pinkish	0.2
	endif	
endin


instr	2
	/* MIDI AND GUI INTEROPERABILITY */
	iMIDIflag	=	0			; IF MIDI ACTIVATED = 1, NON-MIDI = 0
	mididefault	1, iMIDIflag			; IF NOTE IS MIDI ACTIVATED REPLACE iMIDIflag WITH '1'

	if iMIDIflag==1 then				; IF THIS IS A MIDI ACTIVATED NOTE...
	 inum	notnum
	 ivel	veloc	0,1
	 p1	=	p1 + (rnd(1000)*0.0001)
	 if gkinput=0 then
	  turnoff
	 endif
	 icps	cpsmidi					; READ MIDI PITCH VALUES - THIS VALUE CAN BE MAPPED TO GRAIN DENSITY AND/OR PITCH DEPENDING ON THE SETTING OF THE MIDI MAPPING SWITCHES
	 kfreq	init		icps
	 afreq	init		icps
	else
	 kfreq	=		gkfreq
	 afreq	=		gafreq 
	endif						; END OF THIS CONDITIONAL BRANCH

	if gksource==5 then
	 asigL	mpulse	ivel*5,0,0.001
	 asigR	=	asigL
	elseif gksource==6 then
 	 kenv	expseg	1,0.08,0.001,1,0.001
 	 asigL	dust2	20*(kenv-0.001),100
 	 icf	=	icps*(1+(4*ivel))
 	 icf	limit	icf,20,4000
 	 asigL	butlp	asigL,icf
 	 asigR	=	asigL
	else
	 aenv		linsegr	0,0.05,1,0.05,0
	 asigL	=	gasigL*aenv
	 asigR	=	gasigR*aenv
	endif
	
	if changed(gkCutoffMode)==1 then
	 if gkCutoffMode==1 then
	  chnset	"visible(1)","cutoff_ident"
	  chnset	"visible(0)","CutoffRatio_ident"
	 else
	  chnset	"visible(0)","cutoff_ident"
	  chnset	"visible(1)","CutoffRatio_ident"
	 endif
	endif


	if gkCutoffMode==2 then
	 kcutoff	limit	gkCutoffRatio*kfreq,20,sr/2
	else
	 kcutoff	=	gkcutoff
	endif	

	kLDiff		=	semitone(-gkStWidth)
	kRDiff		=	semitone(gkStWidth)	
	
	aresL 		wguide1 asigL, afreq*kLDiff, kcutoff, gkfeedback
	aresR 		wguide1 asigR, afreq*kRDiff, kcutoff, gkfeedback
	aresL 		dcblock	aresL
	aresR 		dcblock	aresR
	
	/* LOW CUT */
	if gkLowCut==1 then
	 aresL		buthp	aresL, kfreq
	 aresR		buthp	aresR, kfreq
	 aresL		buthp	aresL, kfreq
	 aresR		buthp	aresR, kfreq
	endif
	
	/* BANDPASS FILTER */
	if gkBPFOnOff==1 then
	 aFiltL		butbp	aresL,kfreq*gkHarmRatio,kfreq*gkBandwidth
	 aFiltR		butbp	aresR,kfreq*gkHarmRatio,kfreq*gkBandwidth
	 aFiltL		butbp	aFiltL,kfreq*gkHarmRatio,kfreq*gkBandwidth
	 aFiltR		butbp	aFiltR,kfreq*gkHarmRatio,kfreq*gkBandwidth
	 if gkBalanceOnOff==1 then
	  aresL	balance	aFiltL,aresL
	  aresR	balance	aFiltR,aresR
	 else
	  aresL	=	aFiltL
	  aresR	=	aFiltR
	 endif
	endif
	
	amixL		ntrpol	gasigL*aenv, aresL, gkmix
	amixR		ntrpol	gasigR*aenv, aresR, gkmix

	kenv		linsegr	1,15,0
	amixL		=	amixL * gklevel * kenv
	amixR		=	amixR * gklevel * kenv
	ktime		timeinsts
	krms		rms	amixL,3
	if krms<0.00001&&ktime>0.2&&iMIDIflag==1 then
	 turnoff2	p1,4,0
	endif

			outs	amixL, amixR		; WGUIDE1 OUTPUTS ARE SENT OUT
endin

instr	99
	ky	line	p4,p3,p5
	if metro(16)==1 then
	 chnset	sprintfk("pos(0,%d)",ky),"keyboardID"
	endif
endin
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>


</CsoundSynthesizer>



























; wguide2.csd
; Written by Iain McCurdy, 2013.

; For a more extensive use of this opcode see the example "Harmonics.csd"

<Cabbage>
form caption("wguide2") size(595, 90), pluginid("WGu2") style("legacy")
image        pos(0, 0), size(595, 90), colour(25,0,25), shape("rounded"), outlinecolour("white"), outlinethickness(4)
button  bounds( 10, 30, 55, 25), text("PLUCK"), channel("pluck"), toggle(0)
rslider bounds( 65, 11, 70, 70), text("Freq. 1"),   channel("freq1"),     range(20, 8000, 160, 0.25), colour(150,110,110), trackercolour(white)
rslider bounds(130, 11, 70, 70), text("Freq. 2"),   channel("freq2"),     range(20, 8000, 160, 0.25), colour(150,110,110), trackercolour(white)
rslider bounds(195, 11, 70, 70), text("Cutoff 1"), channel("cutoff1"),   range(20,20000,8000,0.25),  colour(150,110,110), trackercolour(white)
rslider bounds(260, 11, 70, 70), text("Cutoff 1"), channel("cutoff2"),   range(20,20000,8000,0.25),  colour(150,110,110), trackercolour(white)
rslider bounds(325, 11, 70, 70), text("F.back 1"), channel("feedback1"), range(-0.999, 0.999, 0.2),  colour(150,110,110), trackercolour(white)
rslider bounds(390, 11, 70, 70), text("F.back 2"), channel("feedback2"), range(-0.999, 0.999, 0.2),  colour(150,110,110), trackercolour(white)
rslider bounds(455, 11, 70, 70), text("Mix"),      channel("mix"),       range(0, 1.00, 0.7),        colour(150,110,110), trackercolour(white)
rslider bounds(520, 11, 70, 70), text("Level"),    channel("level"),     range(0, 1.00, 0.7),        colour(150,110,110), trackercolour(white)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

instr	1
	kporttime	linseg	0,0.001,0.05
	gkfreq1		chnget	"freq1"					;READ WIDGETS...
	gkfreq1		portk	gkfreq1,kporttime
	afreq1		interp	gkfreq1
	gkfreq2		chnget	"freq2"					;READ WIDGETS...
	gkfreq2		portk	gkfreq2,kporttime
	afreq2		interp	gkfreq2
	gkcutoff1	chnget	"cutoff1"				;
	gkcutoff2	chnget	"cutoff2"				;
	gkfeedback1	chnget	"feedback1"				;
	gkfeedback2	chnget	"feedback2"				;
	gkmix		chnget	"mix"					;
	gklevel		chnget	"level"					;
	;asigL, asigR	diskin2	"Seashore.wav",1,0,1			;USE SOUND FILE FOR TESTING
	asigL, asigR	ins

 	kFBtot	=	gkfeedback1 + gkfeedback2		; protect against combined feedbacks greater than 0.5
 	if kFBtot>0.5 then
 	 gkfeedback1	=	gkfeedback1 / (kFBtot*2)
 	 gkfeedback2	=	gkfeedback2 / (kFBtot*2)
 	else
 	 gkfeedback1	=	gkfeedback1
 	 gkfeedback2	=	gkfeedback2
 	endif

	aplk	init	0
	kpluck	chnget	"pluck"					; pluck button
	if changed(kpluck)==1 then
	 aplk	=	1
	 asigL	+=	aplk
	 asigR	+=	aplk
	endif

	aresL	wguide2 asigL, afreq1, afreq2, gkcutoff1, gkcutoff2, gkfeedback1, gkfeedback2
	aresR	wguide2 asigR, afreq1, afreq2, gkcutoff1, gkcutoff2, gkfeedback1, gkfeedback2
	aresL	dcblock2	aresL	;BLOCK DC OFFSET
	aresR	dcblock2	aresR	;BLOCK DC OFFSET
	amixL		ntrpol	asigL,aresL,gkmix
	amixR		ntrpol	asigR,aresR,gkmix
			outs	amixL*gklevel, amixR*gklevel		;WGUIDE1 OUTPUTS ARE SENT OUT
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>


</CsoundSynthesizer>
; AutopanTremolo.csd
; 
; An autopan/tremolo effect in which a variety of LFO shapes can be employed.
; 
; LFO Shapes
; ----------
; sine
; triangle
; square
; Randomi	-	an interpolating random function
; Randomh	-	a 'sample and hold' type function
; Rspline	-	random spline
; User	-	an LFO shape (best understood when using tremolo function) 
; 		in which the user can define the bias (percussive type : reverse percussive) 
; 		and duty emphasis (emphasis of high state/loud against low state/quiet)

<Cabbage>
form caption("Autopan / Tremolo") size(565, 102), pluginid("aptr"), guirefresh(32) style("legacy")
image pos( 0,  0),                size(565, 102),     colour("Maroon"), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
rslider  bounds(  5,  6, 90, 90), text("Freq.[Hz]"),  channel("rate"),  range(0.1, 50, 0.5, 0.5),   valuetextbox(1), textbox(1), trackercolour("tomato")
rslider  bounds( 80,  6, 90, 90), text("Tempo[BPM]"), channel("tempo"), range(6, 3000, 30, 0.5, 1), valuetextbox(1), textbox(1), trackercolour("tomato")
rslider  bounds(175,  6, 90, 90), text("Depth"),      channel("depth"), range(0, 1.00, 1, 0.5),     valuetextbox(1), textbox(1), trackercolour("tomato")

line     bounds(360, 10, 107, 2), colour("Grey")
label    bounds(393,  5, 43, 12), text("USER"), colour("Maroon")
rslider  bounds(345, 16, 80, 80), text("Bias"),      channel("bias"), range(-1, 1.00, 0),          valuetextbox(1), textbox(1), trackercolour("tomato")
rslider  bounds(405, 16, 80, 80), text("Duty"),      channel("duty"), range(0.01, 2000.00, 1, 0.25, 0.001),          valuetextbox(1), textbox(1), trackercolour("tomato")

rslider  bounds(470,  6, 90, 90), text("Level"),      channel("level"), range(0, 1.00, 1),          valuetextbox(1), textbox(1), trackercolour("tomato")

checkbox bounds(160, 40, 25, 25), colour("yellow"), channel("indicator"),  value(0), shape("ellipse"), active(0)
combobox bounds(260, 13,  90,20), channel("mode"), value(1), text("Autopan", "Tremolo")
combobox bounds(260, 38,  90,20), channel("wave"), value(1), text("Sine", "Triangle", "Square", "Randomi", "Randomh", "Rspline", "User")
checkbox bounds(260, 63, 90, 15), text("TEST TONE"), colour("lime"), channel("test"),  value(0)
</Cabbage>

<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;Author: Iain McCurdy (2012)

gihanning	ftgen	0, 0, 8192, 20, 2, 1

opcode	PanTrem,aa,aakkkKkK
	ainL,ainR,krate,kdepth,kmode,kwave,kbias,kduty	xin	;READ IN INPUT ARGUMENTS
	ktrig	changed	kwave				;IF LFO WAVEFORM TYPE IS CHANGED GENERATE A MOMENTARY '1' (BANG)
	if ktrig=1 then					;IF A 'BANG' HAS BEEN GENERATED IN THE ABOVE LINE
		reinit	UPDATE				;BEGIN A REINITIALIZATION PASS FROM LABEL 'UPDATE' SO THAT LFO WAVEFORM TYPE CAN BE UPDATED
	endif						;END OF THIS CONDITIONAL BRANCH
	UPDATE:						;LABEL CALLED UPDATE
	iwave	init		i(kwave)
	iwave	limit	iwave,	0, 6			;
	if iwave==3 then				;if 'randomi' is chosen...
	 klfo	randomi	-kdepth,kdepth,krate,1
	elseif iwave==4 then				;or if 'randomh' is chosen...
	 klfo	randomh	-kdepth,kdepth,krate,1		
	elseif iwave==5 then				;or if 'rspline' is chosen...
	 klfo	rspline	-kdepth,kdepth,krate,krate*2		
	elseif iwave==6 then				;or if 'user' has been chosen...
	 aphs	phasor	krate				;create a linear pointer from 0 to 1 
	 aphs 	pdhalf	aphs, kbias			;distort the linearity using pdhalf
	 kphs	downsamp	aphs			;downsample to krate
	 klfo	tablei	kphs,gihanning,1		;read 
	 klfo	pow	klfo,kduty
	 klfo	=	((klfo*2)-1)*kdepth
	else						;otherwise (use lfo opcode)
	 klfo	lfo	kdepth, krate, iwave		;CREATE AN LFO
	endif
	rireturn					;RETURN FROM REINITIALIZATION PASS
	klfo	=	(klfo*0.5)+0.5			;RESCALE AND OFFSET LFO SO IT STAYS WITHIN THE RANGE 0 - 1 ABOUT THE VALUE 0.5
	if iwave=2||iwave==4 then			;IF SQUARE WAVE MODULATION HAS BEEN CHOSEN...
		klfo	portk	klfo, 0.001		;SMOOTH THE SQUARE WAVE A TINY BIT TO PREVENT CLICKS
	endif						;END OF THIS CONDITIONAL BRANCH	
	if kmode=0 then	;PAN				;IF PANNING MODE IS CHOSEN FROM BUTTON BANK...
		alfo	interp	klfo			;INTERPOLATE K-RATE LFO AND CREATE A-RATE VARIABLE
		aoutL	=	ainL*sqrt(alfo)		;REDEFINE GLOBAL AUDIO LEFT CHANNEL SIGNAL WITH AUTO-PANNING
		aoutR	=	ainR*(1-sqrt(alfo))	;REDEFINE GLOBAL AUDIO RIGHT CHANNEL SIGNAL WITH AUTO-PANNING
		kindicator	=	(klfo>0.5?1:0)
		chnset	kindicator,"indicator"
	elseif kmode=1 then	;TREM			;IF TREMOLO MODE IS CHOSEN FROM BUTTON BANK...
		kindicator	=	(klfo>0.5?1:0)
		if changed:k(kindicator)==1 then
		 chnset	kindicator,"indicator"
		endif
		klfo	=	klfo+(0.5-(kdepth*0.5))	;MODIFY LFO AT ZERO DEPTH VALUE IS 1 AND AT MAX DEPTH CENTRE OF MODULATION IS 0.5
		alfo	interp	klfo			;INTERPOLATE K-RATE LFO AND CREATE A-RATE VARIABLE
		aoutL	=	ainL*(alfo^2)		;REDEFINE GLOBAL AUDIO LEFT CHANNEL SIGNAL WITH TREMELO
		aoutR	=	ainR*(alfo^2)		;REDEFINE GLOBAL AUDIO RIGHT CHANNEL SIGNAL WITH TREMELO
	endif						;END OF THIS CONDITIONAL BRANCH
		xout	aoutL,aoutR			;SEND AUDIO BACK TO CALLER INSTRUMENT
endop

instr 1
krate chnget "rate"
ktempo chnget "tempo"
kdepth chnget "depth"
kmode chnget "mode"
kwave chnget "wave"
kbias chnget "bias"
kduty chnget "duty"
klevel chnget "level"
ktest	chnget	"test"

ktrig	changed	krate
ktrig2	changed	ktempo
if ktrig=1 then
 chnset	krate*60,"tempo"
elseif ktrig2=1 then
 chnset	ktempo/60,"rate"
endif

if ktest=1 then
 a1	vco2	0.2,300,4,0.5
 a2	=	a1
else
 a1,a2	ins
endif

a1,a2	PanTrem	a1,a2,krate,kdepth,kmode-1,kwave-1,kbias,kduty
a1	=	a1 * klevel
a2	=	a2 * klevel
	outs	a1,a2
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; doppler.csd
; Written by Iain McCurdy, 2013

; CONTROLS
; Input		-	select input: either left channel, right channel, or a mix of both channels
; Shape		-	shape of the LFO moving the source: either sine, triangle, random spline OR manual
			   note, if 'random' is chosen, 'speed' can take a little while to respond to changes
			   made to the 'speed' control is the speed was previously slow
			   If 'manual' is selected source position is controlled using the on screen slider
; Room Size	-	effectively the dpeth of the doppler pitch modulating effect
; Speed		-	speed of the LFO moving the source with respect to the mic. position
; Depth		-	amplitude of the LFO moving the source
; Smoothing	-	a smoothing filter applied to doppler pitch modulation. Its effect can be subtle.
; Mix		-	a dry/wet mixer. Mixing the dry and wet signals can be used to create chorus effects.
; Ampscale	-	amount of amplitude drop off as the source moves away from the source. 
			 Kind of like another room size control
; Pan Depth	-	Amount of left-right movement in the output as the source swings past the microphone
; Out Amp	-	scales the output signal
; Mic.Position	-	Position of the microphone
; Source Position-	Location of the source (for display only unless 'manual' shape is chosen)

<Cabbage>
form caption("-oOo-"), size(610, 180), pluginid("dopp")   style("legacy")
label    bounds(20, 10, 35,11), text("Input:")
combobox bounds(10, 22, 60,18), channel("input"), value(4), text("left","right","mixed","test")
label    bounds(20, 50, 35,11), text("Shape:")
combobox bounds(10, 62, 60,18), channel("shape"), value(1), text("sine","triangle","random","manual")

rslider bounds( 75, 10, 80, 80), channel("RoomSize"), range(0.1,100,40,0.5,0.5), text("Room Size"), textbox(1), valuetextbox(1), colour( 45, 45, 45), trackercolour(200,200,200)
rslider bounds(140, 10, 80, 80), channel("speed"), range(0,10,0.08,0.5,0.01), text("Speed"), textbox(1), valuetextbox(1),        colour( 45, 45, 45), trackercolour(200,200,200)
rslider bounds(205, 10, 80, 80), channel("depth"), range(0,0.5,0.5,0.5,0.01), text("Depth"), textbox(1), valuetextbox(1),        colour( 45, 45, 45), trackercolour(200,200,200)
rslider bounds(270, 10, 80, 80), channel("filtercutoff"), range(1,20,6,1,1), text("Smooth"), textbox(1), valuetextbox(1),     colour( 45, 45, 45), trackercolour(200,200,200)
rslider bounds(335, 10, 80, 80), channel("ampscale"), range(0,1,0.98), text("Amp.Scl."), textbox(1), valuetextbox(1),           colour( 45, 45, 45), trackercolour(200,200,200)
rslider bounds(400, 10, 80, 80), channel("PanDep"), range(0,0.5,0.4), text("Pan Depth"), textbox(1), valuetextbox(1),            colour( 45, 45, 45), trackercolour(200,200,200)
rslider bounds(465, 10, 80, 80), channel("mix"), range(0,1,1), text("Mix"), textbox(1), valuetextbox(1),                         colour( 45, 45, 45), trackercolour(200,200,200)
rslider bounds(530, 10, 80, 80), channel("OutAmp"), range(0,1,0.5), text("Level"), textbox(1), valuetextbox(1),                  colour( 45, 45, 45), trackercolour(200,200,200)

hslider bounds( 10, 86,590, 40), channel("microphone"), range(0,1.00,0.5), text("Mic. Position"),   textbox(1), valuetextbox(1), colour(100,100,100), trackercolour(200,200,200)
hslider bounds( 10,111,590, 40), channel("source"),     range(0,1.00,0.5), text("Source Position"), textbox(1), valuetextbox(1), colour(100,100,100), trackercolour(200,200,200)

label    bounds( 7, 155,120,18), text("D O P P L E R"),  fontcolour(100,100,100)
label    bounds( 5, 153,120,18), text("D O P P L E R"),  fontcolour(180,180,180)

label   bounds(232,160, 165, 12), text("Author: Iain McCurdy |2013|"), FontColour("grey")

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1	;MAXIMUM AMPLITUDE VALUE

;AMPLITUDE SCALING CURVE
giampcurve	ftgen	0,0,131072,5,0.01,131072*0.5,1,131072*0.5,0.01

instr	1
	gkinput      	chnget  "input"  
	gkRoomSize      chnget  "RoomSize"  
	gkspeed         chnget  "speed"     
	gkdepth		chnget	"depth"     
	gkfiltercutoff	chnget	"filtercutoff"
	gkfiltercutoff	init	6
	gkampscale	chnget	"ampscale"
	gkPanDep	chnget	"PanDep"
	kmix		chnget	"mix"				;READ IN DRY/WET CROSSFADER WIDGET
	gkOutAmp	chnget	"OutAmp"
	gkmicrophone	chnget	"microphone"
	gkshape		chnget	"shape"
	gkshape		init	1
	
	/* INPUT */
	aL,aR		ins
	if gkinput=1 then
	 asig	=	aL
	elseif gkinput=2 then
	 asig	=	aR
	elseif gkinput=3 then
	 asig	=	(aL+aR)*0.677
	else
 	 ;INPUT TONE=============================================(for testing)
	 asig		vco2	.5, 300		;GENERATE TONE
	 asig		tone	asig, 1200	;LOW PASS FILTER TO SOFTEN THE TONE
	 ;=======================================================
	endif	 

	
	;LFO(modulates source position)=========================
	ktrig		changed	gkshape				;IF I-RATE VARIABLE SLIDER IS CHANGED GENERATE A '1'
	if ktrig=1 then						;IF TRIGGER IS '1'...
		reinit RESTART_LFO				;BEGIN A REINITIALISATION PASS FROM LABEL 'UPDATE' 
	endif							;END OF THIS CONDITIONAL BRANCH
	RESTART_LFO:						;LABEL CALLED 'UPDATE'
	if i(gkshape)=3 then					;IF 'RANDOM' SHAPE IS SELECTED...
	 gksource	rspline	0.5-gkdepth, 0.5+gkdepth, gkspeed,gkspeed*2
	elseif i(gkshape)=4 then				;IF 'MANUAL' SHAPE IS SELECTED...
	 gksource	chnget	"source"			;READ SOURCE POSITION FROM SLIDER 
	else
	 gksource	lfo	gkdepth, gkspeed, i(gkshape)-1	;LFO
	 gksource	=	gksource + 0.5			;OFFSET INTO THE POSITIVE DOMAIN
	endif
	rireturn
	chnset	gksource,"source"
	;======================================================
	
	kporttime	linseg	0, 0.001, 0.1		;RAMPING UP PORTAMENTO TIME VARIABLE	
	
	;DOPPLER================================================
	ispeedofsound   init	340.29				;SPEED OF SOUND DEFINED
	if gkshape==4 then
	 ksource	portk	gksource,kporttime		;SMOOTH SOURCE POSITION MOVEMENT
	else
	 ksource	=	gksource
	endif
	kmicrophone	portk	gkmicrophone, kporttime		;SMOOTH MICROPHOPNE POSITION MOVEMENT
	ktrig		changed	gkfiltercutoff			;IF I-RATE VARIABLE SLIDER IS CHANGED GENERATE A '1'
	if ktrig=1 then						;IF TRIGGER IS '1'...
		reinit UPDATE					;BEGIN A REINITIALISATION PASS FROM LABEL 'UPDATE' 
	endif							;END OF THIS CONDITIONAL BRANCH
	UPDATE:							;LABEL CALLED 'UPDATE'
	kdisp		limit	ksource-(kmicrophone-0.5), 0, 1	;CALCULATE DISPLACEMENT (DISTANCE) BETWEEN SOURCE AND MICROPHONE AND LIMIT VALUE TO LIE BETWEEN ZERO AND 1
	kamp		table	kdisp, giampcurve,1		;READ AMPLITUDE SCALING VALUE FROM TABLE
	kamp		ntrpol	1, kamp, gkampscale		;CALCULATE AMOUNT OF AMPLITUDE SCALING DESIRED BY THE USER FROM THE ON SCREEN SLIDER
	aout		doppler	asig*kamp, ksource*gkRoomSize, kmicrophone*gkRoomSize, ispeedofsound, i(gkfiltercutoff)	;APPLY DOPPLER EFFECT
	rireturn						;RETURN FROM REINITIALISATION PASS
	kpan		=	(gksource<gkmicrophone?0.5+gkPanDep:0.5-gkPanDep)	;CALCULATE PAN VALUE ACCORDING TO SOURCE AND MIC POSITION
	kpan		portk	kpan, kporttime			;APPLY PORTAMENTO SMOOTHING TO PAN POSITION VALUE 
	aL		ntrpol	asig,aout*sqrt(kpan)*gkOutAmp,kmix	;DRY/WET MIX LEFT CHANNEL
	aR		ntrpol	asig,aout*sqrt(1-kpan)*gkOutAmp,kmix	;DRY/WET MIX RIGHT CHANNEL
			outs	aL, aR				;SEND AUDIO TO OUTPUTS AND APPLY PANNING
endin

</CsInstruments>

<CsScore>
i 1 0 3600	;DUMMY SCORE EVENT - PERMITS REAL-TIME PERFORMANCE FOR 1 HOUR
</CsScore>

</CsoundSynthesizer>; DopplerSpin.csd
; Written by Iain McCurdy, 2013

; CONTROLS

; Speed				--	Frequency of the spinning
; Loc.				--	Listening position in relation to the circular motion (range from ('centre' to 'edge'). Can be thought of as a control for the amount of amplitude modulation.
; Orient.			--	direction of listening (in radians)
; Width				--	width of panning directionality in the modulation 
; Depth				--	depth of doppler effect (circle size).
; (Reverb) Scaling		--	a dry/wet mixer. Mixing the dry and wet signals can be used to create chorus effects.
; (Reverb) Time			--	amount of amplitude drop off as the source moves away from the source. 
; (Reverb) Damping		--	Amount of left-right movement in the output as the source swings past the microphone
; Mix				--	scales the output signal
; Level				--	Output Level
; Auto-Frequency		--	If this button is activated the frequency of the spinning moves randomly between -Frequency of Rotation and +Frequency of Rotation

; This example uses three LFOs to create the effect of a sound moving in a circle around the listener. 
; The three parameters controlled by these LFOs are amplitude, panning and delay time.
; The modulation of the delay time also results in a modulation of pitch which is sometimes referred to as the Doppler effect.                                             
; Note that in this example the 'vdelayxw' opcode is used to implement the delay and doppler shift. 
; This opcode is unique in that the delay time of the write pointer rather than the read pointer is modulated. 
; This is appropriate here as it is the sound source that is moving, not the listener.          
; Crucial to this effect is that that all three LFOs share the same frequency value. 
; Negative frequency values are also allowed - this would represent a change in direction of the source sounds motion around us.                             
; Also of crucial importance is the phase relationship between the three LFOs as this defines exactly where the sound source is in relation to the listener.                             
; The panning LFO should be at its points of minimum rate of change when the sound source is moving parallel to the direction in which the listener is facing, i.e. directly to the left or to the right of the listener.                   
; The delay time LFO (pitch modulation/doppler) should be at its points of minimum rate of change when the sound source is  moving perpendicular to the direction in which the listener is facing, i.e. directly in front of or behind the listener.
; The phase difference between these two LFOs is either 90 or 270 degrees, depending on whether the source sound is moving in a clockwise or anticlockwise direction around us.        
; Amplitude modulation comes into play whenever we are not listening from the centre of the circle of motion. 
; The close to the edge of the circle we are the greater the amount of amplitude modulation we will experience. 
; If the amplitude modulation is extreme then the circle of the source sound's motion must be extremely large. The phase of the amplitude modulation LFO is also adjustable ('Orientation' slider -   
; this define which edge of the circle we are closest to, e.g. upper, lower, left, right etc. It is probably best to always include at least a small amount of amplitude modulation as we perceive sounds directly to our left or to our right to be
; louder, even if they remain equidistant from us. In this case the amplitude LFO phase ('Orientation') should be 0.5 (radians).                                                  
; The waveform for all three LFOs is a sine wave. 
; This defines the object's motion as being circular. 
; If we were to use a different waveform this would model non-circular motion. 
; There is interesting potential in experimentation in this direction with this example.                                
; Finally as the moving signal becomes more distant, i.e. when the amplitude scaling function is at its minimum, a reverberated version of the signal can become more evident. 
; The degree to which this is present can be scaled using the 'Reverb Scaling' slider.                                    

<Cabbage>
form caption("Doppler Spin"), size(700,265), pluginid("SDop") style("legacy")

label    bounds( 8 , 4, 70, 15), text("i  n  p  u  t"), fontcolour("white")
combobox bounds(10, 30, 60,20), channel("input"), value(1), text("left","right","mixed","test")

line     bounds( 85,  5,  2, 70), colour("Grey")
label    bounds(185,  4, 90, 15), text("r  e  v  e  r  b"), fontcolour("white")
checkbox bounds(100, 33,110, 20), text("Reverb On/Off") channel("RvbOnOff"), FontColour("White"), colour("lime")  value(1)
rslider  bounds(210, 23, 55, 55), channel("RvbScaling"), range(0,1.000,0.3,1,0.001),     text("Scaling"),               TextBox(0), colour( 95, 45,115), trackercolour(white)
rslider  bounds(270, 23, 55, 55), channel("RvbTime"),    range(0.3,0.990,0.7,1,0.001),   text("Time"),                  TextBox(0), colour( 85, 45,125), trackercolour(white)
rslider  bounds(330, 23, 55, 55), channel("RvbFilt"), range(20,20000,4000,0.5,0.001),    text("Damping"),               TextBox(0), colour( 75, 45,135), trackercolour(white)

line     bounds(390,  5,  2, 70), colour("Grey")
label    bounds(410,  4, 90, 15), text("o  u  t  p  u  t"), fontcolour("white")
rslider  bounds(400, 23, 55, 55), channel("mix"),        range(0,1.000,1,1,0.001),       text("Mix"),                   TextBox(0), colour( 65, 45,145), trackercolour(white)
rslider  bounds(460, 23, 55, 55), channel("OutGain"),    range(0,1.000,0.7,1,0.001),     text("Level"),                 TextBox(0), colour( 55, 45,155), trackercolour(white)
line     bounds(520,  5,  2, 70), colour("Grey")

checkbox bounds(530, 33,120, 20), text("Random Speed") channel("RandSpeed"), FontColour("White"), colour("lime")  value(0)

hslider bounds(  5, 80,690, 35), channel("freq"),        range(-10,10.0,0.2,1,0.01),     text("Speed"),         TextBox(1), colour(145, 45, 65), trackercolour(white)	;Frequency of Rotation
hslider bounds(  5,110,690, 35), channel("AmpDepth"),    range(0,1.000,0.7,1,0.001),        text("Loc."),          TextBox(1), colour(135, 45, 75), trackercolour(white)	;Central/Edge
hslider bounds(  5,140,690, 35), channel("AmpPhase"),    range(0,1.000,0.5,1,0.001),        text("Orient."),       TextBox(1), colour(125, 45, 85), trackercolour(white)	;Orientation [radians]
hslider bounds(  5,170,690, 35), channel("PanDepth"),    range(0,1.000,1,1,0.001),          text("Width"),         TextBox(1), colour(115, 45, 95), trackercolour(white)	;Panning Width
hslider bounds(  5,200,690, 35), channel("DopDep"),      range(0,0.030,0.003,1,0.0001), text("Depth"),         TextBox(1), colour(105, 45,105), trackercolour(white)	;Doppler Depth

label   bounds( 5,247, 170, 12), text("Author: Iain McCurdy |2013|"), FontColour("grey")

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1	;MAXIMUM AMPLITUDE VALUE

gisine	ftgen	0,0,131072,10,1

instr	1
	gkinput      	chnget  "input"  
	kfreq      	chnget	"freq"
	kAmpDepth  	chnget	"AmpDepth"  	
	kAmpPhase  	chnget	"AmpPhase"  	
	kPanDepth  	chnget	"PanDepth"  	
	kDopDep    	chnget	"DopDep"    	
	kRvbScaling	chnget	"RvbScaling"	
	kRvbTime   	chnget	"RvbTime"   	
	kRvbFilt   	chnget	"RvbFilt"   	
	kmix  	 	chnget	"mix"   	
	kOutGain   	chnget	"OutGain"   	
	kRvbOnOff	chnget	"RvbOnOff"
	kRandSpeed   	chnget	"RandSpeed"   	
	
	/* INPUT */
	aL,aR		ins
	if gkinput=1 then
	 asig	=	aL
	elseif gkinput=2 then
	 asig	=	aR
	elseif gkinput=3 then
	 asig	=	(aL+aR)*0.677
	else
 	 ;INPUT TONE=============================================(for testing)
	 asig		vco2	.5, 300		;GENERATE TONE
	 asig		tone	asig, 1200	;LOW PASS FILTER TO SOFTEN THE TONE
	 ;=======================================================
	endif	 

	if kRandSpeed=1 then
	 kfreq	jspline	kfreq,1,4
	endif


	
	kporttime	linseg	0,0.001,0.1			;CREATE 'PORTAMENTO TIME'. A FUNCTION THAT RISES QUICKLY FROM ZERO TO A HELD VALUE.
	kAmpPhase	portk	kAmpPhase, kporttime		;APPLY PORTAMENTO TO gkAmpPhase. CREATE NEW OUTPUT VARIABLE kAmpPhase (GLOBAL VARIABLES CAN'T BE BOTH INPUT AND OUTPUT)
	kDopDep		portk	kDopDep, kporttime		;APPLY PORTAMENTO TO gkDopDep. CREATE NEW OUTPUT VARIABLE kDopDep (GLOBAL VARIABLES CAN'T BE BOTH INPUT AND OUTPUT)

	aAmp 		osciliktp kfreq, gisine, kAmpPhase	;AN LFO DEFINES A VARIABLE USED TO MODULATE AMPLITUDE (NOTE: VARIABLE PHASE). THIS MODELS THE LOCATION WITHIN THE CIRCLE FROM WHICH WE ARE LISTENING. NO AMPLITUDE MODULATION REPRESENT REPRESENTS OUR LISTENING POSITION BEING EXACTLY CENTRAL, MAXIMUM MODULATION REPRESENTS US BEING NEAR TO THE EDGE OF A LARGE CIRCLE. THE CONTROL OVER PHASE OF THIS LFO REPRESENTS WHICH EDGE WE ARE CLOSER TO.
	aAmp		=	(aAmp * 0.5 * kAmpDepth) + 0.5	;RESCALE AND OFFSET AMPLITUDE MODULATION LFO
	
	aPan		oscili	(kPanDepth * 0.5), kfreq, gisine, 0.75	;AN LFO DEFINES A VARIABLE FOR PANNING CONTROL - I.E. WHETHER SOUND IS CURRENTLY TO OUT LEFT OR TO OUT RIGHT. NOTE THAT PHASE IS 0.75 AND THEREFORE 0.75 RADIANS (OR 270 DEGREES OUT OF PHASE) WITH THE DELAY MODULATION 
	aPan		=	aPan + 0.5					;OFFSET PANNING LFO

	iMaxDelay	=	1		;DEFINE A VARIABLE THAT WILL BE USE FOR 'MAXIMUM DELAY TIME' (BUFFER LENGTH)
	aDelTim		oscili	kDopDep, kfreq, gisine, 0	;AN LFO DEFINES A VARIABLE FOR DELAY TIME (NOTE PHASE AT ZERO)
	aDelTim		=	aDelTim + kDopDep		;DELAY TIME  VARIABLE 'aDelay' IS OFFSET TO STAY WITHIN THE POSITIVE DOMAIN	
		
	;vdelayxw IS USED FOR THE DELAY READ/WRITE AS IT MODULATES THE WRITE POINTER RATHER THAN THE READ POINTER.
	;THIS IS MORE APPROPRIATE IN THIS EXAMPLE AS THE SOURCE IS MOVING BUT THE POINT OF LISTENING IS STATIONARY
	aDelTap	vdelayxw	asig, aDelTim, iMaxDelay, 16
	
	aL, aR	pan2 	aDelTap, aPan, 1	;APPLY PANNING TO SIGNAL OUTPUT FROM DELAY USING pan2 OPCODE. CREATE A NEW 

	aL	=	aL * (aAmp^0.5)		;APPLY AMPLITUDE MODULATION (CREATE A NEW AUDIO SIGNAL - DRY (UN-REVERBERATED) SIGNAL)
	aR	=	aR * (aAmp^0.5)		;APPLY AMPLITUDE MODULATION (CREATE A NEW AUDIO SIGNAL - DRY (UN-REVERBERATED) SIGNAL)

	if kRvbOnOff=1 then
	 aRvbL, aRvbR	reverbsc	aL, aR, kRvbTime, kRvbFilt	;REVERB (UNAFFECTED BY AMPLITUDE MODULATION)
	 aL	=	(aL+(aRvbL*kRvbScaling))
	 aR	=	(aR+(aRvbL*kRvbScaling))
	endif
	
	aL	ntrpol	asig,aL,kmix
	aR	ntrpol	asig,aR,kmix
	
	outs	aL * kOutGain , aR * kOutGain 	;SEND AUDIO TO OUTPUTS. MIX DRY AND REVERBERATED SIGNALS.
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7*52]
</CsScore>

</CsoundSynthesizer>; Flanger.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("Flanger") size(510,100), pluginid("flan") style("legacy")
image pos(0, 0), size(510,100), colour("lightgreen"), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
line	 bounds( 15, 10,190,  2)
label    bounds( 75,  7, 70, 10), text("MODULATION"), fontcolour("white"), colour(100,110,130)
rslider  bounds(  5, 20, 70, 70), text("Rate"),     channel("rate"),  range(0.001, 40, 0.15, 0.5, 0.001),      colour("DarkGreen"), trackercolour( 50,150, 50), textcolour(  0, 30,  0)
rslider  bounds( 75, 20, 70, 70), text("Depth"),    channel("depth"), range(0, 0.01, 0.005,1,0.0001),          colour("DarkGreen"), trackercolour( 50,150, 50), textcolour(  0, 30,  0)
rslider  bounds(145, 20, 70, 70), text("Offset"),    channel("delay"), range(0.00002, 0.1, 0.0001, 0.5, 0.0001), colour("DarkGreen"), trackercolour( 50,150, 50), textcolour(  0, 30,  0)
rslider  bounds(215, 20, 70, 70), text("Feedback"), channel("fback"), range(-1, 1, 0),                         colour("DarkGreen"), trackercolour( 50,150, 50), textcolour(  0, 30,  0)
checkbox bounds(290, 20, 80, 15), colour("yellow"), channel("ThruZero"),  value(1), text("Thru.Zero"), fontcolour(  0, 30,  0)
label    bounds(295, 47, 65, 12), text("LFO Shape:"), fontcolour(  0, 30,  0)
combobox bounds(290, 60, 80, 18), channel("lfoshape"), value(1), text("parabola", "sine", "triangle", "randomi", "randomh")
rslider  bounds(370, 20, 70, 70), text("Mix"),      channel("mix"),   range(0, 1.00, 0.5),                     colour("DarkGreen"), trackercolour( 50,150, 50), textcolour(  0, 30,  0)
rslider  bounds(435, 20, 70, 70), text("Level"), channel("level"), range(0, 1.00, 1), colour("DarkGreen"), trackercolour( 50,150, 50), textcolour(  0, 30,  0)
</Cabbage>

<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;Author: Iain McCurdy (2012)

opcode	Flanger,a,akkkkk
	ain,krate,kdepth,kdelay,kfback,klfoshape	xin			;read in input arguments
	iparabola	ftgentmp	0, 0, 131072, 19, 0.5, 1, 180, 1	;u-shape parabola for lfo
	isine		ftgentmp	0, 0, 131072, 19, 1, 0.5, 0,   0.5 	;sine-shape for lfo
	itriangle	ftgentmp	0, 0, 131072, 7, 0,131072/2,1,131072/2,0;triangle-shape for lfo
	adlt		interp		kdelay							;a new a-rate variable 'adlt' is created by interpolating the k-rate variable 'kdlt'
	if klfoshape==1 then
	 amod		oscili		kdepth, krate, iparabola			;oscillator that makes use of the positive domain only u-shape parabola
	elseif klfoshape==2 then
	 amod		oscili		kdepth, krate, isine			;oscillator that makes use of the positive domain only sine wave
	elseif klfoshape==3 then
	 amod		oscili		kdepth, krate, itriangle			;oscillator that makes use of the positive domain only triangle
	elseif klfoshape==4 then	
	 amod		randomi		0,kdepth,krate,1
	else	
	 amod		randomh		0,kdepth,krate,1
	endif
	adlt		sum		adlt, amod				;static delay time and modulating delay time are summed
	adelsig		flanger 	ain, adlt, kfback , 1.2			;flanger signal created
	adelsig		dcblock		adelsig
	aout		sum		ain*0.5, adelsig*0.5			;create dry/wet mix 
			xout		aout					;send audio back to caller instrument
endop

instr 1
	krate chnget "rate"				;read in widgets
	kdepth chnget "depth"
	kdelay chnget "delay"
	kfback chnget "fback"
	klevel chnget "level"
	klfoshape chnget "lfoshape"
	kThruZero chnget "ThruZero"
	kmix chnget "mix"
	
	a1,a2	ins					;read live stereo audio input
	;a1	pinkish	0.2				;for testing...
	;a2	pinkish	0.2

	kporttime	linseg	0,0.001,0.1
	kdelay	portk	kdelay,kporttime

	afla1	Flanger	a1,krate,kdepth,kdelay,kfback,klfoshape	;call udo (left channel)
	afla2	Flanger	a2,krate,kdepth,kdelay,kfback,klfoshape	;call udo (right channel)

	if kThruZero==1 then				;if 'Thru.Zero' mode is selected...
	 a1	delay	a1,0.00002
	 a2	delay	a2,0.00002
	 a1	ntrpol	-a1,afla1,kmix			;invert delayed dry signal and mix with flanger signal
	 a2	ntrpol	-a2,afla2,kmix
	else						;otherwise... (standard flanger)
	 a1	ntrpol	a1,afla1,kmix			;create mix between dry signal and flanger signal
	 a2	ntrpol	a2,afla2,kmix
	endif
		outs	a1*klevel,a2*klevel		;send audio to outputs, scale amplitude according to GUI knob value
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; LeslieSpeaker.csd
; Written by Iain McCurdy, 2016.

; An emulation of a Leslie rotating speaker as commonly used with a Hammond organ

; A Leslie speaker consists of two speaker drivers, a high frequency tweeter and a low frequency woofer, which rotate at on of two speed according to a switch.
;  (For clarification, the woofer itself does not actually spin, instead a baffle rotates around it.)

; The main interface is simply two main switches which switch between the slow and fast speeds, and a 'setup' button which accesses advanced controls.
; The default advanced settings represent typical characteristics for a real Leslie speaker.

; This .csd works as an effect upon the audio input, but it can also be tested by playing a basic built-in organ using a connected MIDI keyboard

; Setup
; -----
; The same set of parameters are provided for the woofer and the tweeter.

; Cutoff	-	the cutoff frequency of the crossover (lowpass for the woofer, highpass for the tweeter)
; Damping	-	change from one speed to the other is not instantaneous.
;				'Damping' defines the amount of mechanical resistance to changing speed.
;				Typically the woofer takes longer to change speed (higher damping).
; RPM Slow	-	speed (in revolutions per minute) when speed is 'Slow'
; RPM Fast	-	speed (in revolutions per minute) when speed is 'Fast'
; Doppler	-	amount of doppler shift (pitch shift) during rotation
; Panning	-	width of panning modulation
; Amplitude	-	amount of amplitude modulation

<Cabbage>
form caption("Leslie Speaker") size(260,120), pluginid("Lsli") style("legacy")

image     bounds(  0,  0,260,120), outlinethickness(4), outlinecolour("white"), file("DarkWood.jpg");, colour(75,50,50)
image     bounds(  0,  0,260,120), outlinethickness(4), outlinecolour("silver"), colour(0,0,0,0)
button    bounds( 40, 85, 60, 25), fontcolour:0(80,55,55), fontcolour:1(255,245,245), colour:0(75,50,50), colour:1(250,170,170), text("Slow","Slow"), channel("Slow"), latched(1), radiogroup(1), value(1)
button    bounds(100, 85, 60, 25), fontcolour:0(80,55,55), fontcolour:1(255,245,245), colour:0(75,50,50), colour:1(250,170,170), text("Stop","Stop"), channel("Stop"), latched(1), radiogroup(1)
button    bounds(160, 85, 60, 25), fontcolour:0(80,55,55), fontcolour:1(255,245,245), colour:0(75,50,50), colour:1(250,170,170), text("Fast","Fast"), channel("Fast"), latched(1), radiogroup(1)

image     bounds( 132,  7,16,16), identchannel("TweeterID"), shape("ellipse"), colour(170,150,150)
image     bounds( 110, 30,40,40), identchannel("WooferID"),  shape("ellipse"), colour(170,150,150)

button bounds(200,10,50, 18), colour:0(80,55,55), colour:1(80,55,55), channel("setup_Button"), text("SETUP"), fontcolour:0(200,200,200), fontcolour:1(200,200,200)
groupbox bounds(360,28,340,190), plant("Setup"), outlinethickness(0), popup(1), identchannel("setupPlant")
{
image     bounds(0,0,340,190), outlinethickness(4), outlinecolour("silver"), colour(75,50,50), file("DarkWood.jpg")

image     bounds(0,0,170,190), outlinethickness(4), outlinecolour("silver"), colour(0,0,0,0)
label     bounds(0,4,170, 14), text("Woofer"), fontcolour(200,200,200)
nslider bounds(10, 20,70,40), channel("CF_Low"), text("Cutoff"),     range(20,8000,800,1,1)
nslider bounds(90, 20,70,40), channel("LF_Damp"), text("Damping"),   range(0.01,8,1.5,1,0.01)
nslider bounds(10, 60,70,40), channel("LF_Slow"), text("RPM Slow"),  range(5,1000, 40,1,1)
nslider bounds(90, 60,70,40), channel("LF_Fast"), text("RPM Fast"),  range(5,1000,342,1,1)
nslider bounds(10,100,70,40), channel("LF_Dop"), text("Doppler"),    range(0,2,0.1)
nslider bounds(90,100,70,40), channel("LF_Pan"), text("Panning"),    range(0,1,0.2,1,0.01)
nslider bounds(10,140,70,40), channel("LF_Amp"), text("Amplitude"),  range(0,1,0.3,1,0.01)

image     bounds(170,0,170,190), outlinethickness(4), outlinecolour("silver"), colour(0,0,0,0)
label     bounds(170,4,170, 14), text("Tweeter"), fontcolour(200,200,200)
nslider bounds(180, 20,70,40), channel("CF_High"), text("Cutoff"),    range(20,8000,800,1,1)
nslider bounds(260, 20,70,40), channel("HF_Damp"), text("Damping"),   range(0.01,8,0.5,1,0.01)
nslider bounds(180, 60,70,40), channel("HF_Slow"), text("RPM Slow"),  range(5,1000, 48,1,1)
nslider bounds(260, 60,70,40), channel("HF_Fast"), text("RPM Fast"),  range(5,1000,400,1,1)
nslider bounds(180,100,70,40), channel("HF_Dop"), text("Doppler"),    range(0,2,0.2)
nslider bounds(260,100,70,40), channel("HF_Pan"), text("Panning"),    range(0,1,0.4,1,0.01)
nslider bounds(180,140,70,40), channel("HF_Amp"), text("Amplitude"),  range(0,1,0.3,1,0.01)
}

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 	= 	32
nchnls 	= 	2
0dbfs	=	1
massign	0,1

;Author: Iain McCurdy (2016)

opcode	DopplerSpin,aa,akkkkki
	asig,kfreq,kAmpDepth,kAmpPhase,kPanDepth,kDopDep,ishape	xin
	
	isine		ftgen	0,0,1024,10,1
	aAmp 		osciliktp kfreq, ishape, kAmpPhase		; AN LFO DEFINES A VARIABLE USED TO MODULATE AMPLITUDE (NOTE: VARIABLE PHASE). THIS MODELS THE LOCATION WITHIN THE CIRCLE FROM WHICH WE ARE LISTENING. NO AMPLITUDE MODULATION REPRESENT REPRESENTS OUR LISTENING POSITION BEING EXACTLY CENTRAL, MAXIMUM MODULATION REPRESENTS US BEING NEAR TO THE EDGE OF A LARGE CIRCLE. THE CONTROL OVER PHASE OF THIS LFO REPRESENTS WHICH EDGE WE ARE CLOSER TO.
	aAmp		=	(aAmp * 0.5 * kAmpDepth) + 0.5		; RESCALE AND OFFSET AMPLITUDE MODULATION LFO
	
	aPan		oscili	(kPanDepth * 0.5), kfreq, ishape, 0.75	; AN LFO DEFINES A VARIABLE FOR PANNING CONTROL - I.E. WHETHER SOUND IS CURRENTLY TO OUT LEFT OR TO OUT RIGHT. NOTE THAT PHASE IS 0.75 AND THEREFORE 0.75 RADIANS (OR 270 DEGREES OUT OF PHASE) WITH THE DELAY MODULATION 
	aPan		=	aPan + 0.5				; OFFSET PANNING LFO

	iMaxDelay	=	4					; DEFINE A VARIABLE THAT WILL BE USE FOR 'MAXIMUM DELAY TIME' (BUFFER LENGTH)
	aDelTim		oscili	kDopDep, kfreq, ishape, 0		; AN LFO DEFINES A VARIABLE FOR DELAY TIME (NOTE PHASE AT ZERO)
	aDelTim		=	aDelTim + kDopDep			; DELAY TIME  VARIABLE 'aDelay' IS OFFSET TO STAY WITHIN THE POSITIVE DOMAIN	
		
	;vdelayxw IS USED FOR THE DELAY READ/WRITE AS IT MODULATES THE WRITE POINTER RATHER THAN THE READ POINTER.
	;THIS IS MORE APPROPRIATE IN THIS EXAMPLE AS THE SOURCE IS MOVING BUT THE POINT OF LISTENING IS STATIONARY
	aDelTap		vdelay	asig*aAmp, aDelTim, iMaxDelay;, 16
	
	aL, aR	pan2 	aDelTap, aPan, 1	;APPLY PANNING TO SIGNAL OUTPUT FROM DELAY USING pan2 OPCODE. CREATE A NEW 

		xout	aL,aR	
endop


gisine		ftgen	0,0,4096,10,1													; sine wave
gitri	ftgen	0,0,1024,-7,0,512,1,512,0											; triangle wave

giSrc		ftgen	0,0,4096,10,1,0.5,0.4,0.01,0.01,0.01,0.01,0,0.01				; waveform of a single tonewheel (not quite a sine wave)
;giAllOut	ftgen	0,0,4096,31, giSrc, 1,1,0, 2,1,0, 3,1,0, 4,1,0, 8,1,0	; composite of several tonewheels
giAllOut	ftgen	0,0,4096,9, 1,1,0, 2,1,0, 3,1,0, 4,1,0, 5,.1,0, 6,.1,0, 7,.1,0, 8,1,0	; composite of several tonewheels

instr	1	; a basic MIDI triggered organ sound
 aEnv		linsegr	0,0.005,1,0.01,0					; anti-click envelope
 aMix		poscil	0.5*aEnv,cpsmidi(),giAllOut			; basic organ sound
 chnmix		aMix,"send"									; mix into send 'channel'
endin

instr	99	; a Leslie speaker effect
 kSlow	chnget	"Slow"									; read 'Slow' button widget
 kStop	chnget	"Stop"									; read 'Stop' button widget
 kFast	chnget	"Fast"									; read 'Faset' button widget
 
 if kSlow==1 then
  kSpeed	=	0
 elseif kStop==1 then
  kSpeed	=	1
 else
  kSpeed	=	2
 endif
 														; 0=slow 1=stop 2=fast
 aMix		chnget	"send"								; read in organ sound from instr 1

 aL,aR		ins											; read live audio in
 aMix		+=	aL+aR									; mix both live audio in channels into the organ sound
 
 kCF_High	chnget	"CF_High"							;crossover cutoff frequencies
 kCF_Low	chnget	"CF_Low"
 
 kHF_Slow	=	chnget:k("HF_Slow")/60					; tweeter chorale (slow) speed
 kHF_Fast	=	chnget:k("HF_Fast")/60					; tweeter tremolo (fast) speed

 kLF_Slow	=	chnget:k("LF_Slow")/60					; tweeter chorale (slow) speed
 kLF_Fast	=	chnget:k("LF_Fast")/60					; woofer tremolo (fast) speed
 
 kHF_Damp	chnget	"HF_Damp"							; tweeter speed change time
 kLF_Damp	chnget	"LF_Damp"							; woofer speed change time
 
 kHF_Trem	chnget	"HF_Trem"							; tremolo modulation depth
 kLF_Trem	chnget	"LF_Trem"
 
 kHF_Dop	chnget	"HF_Dop"							; doppler modulation depth
 kLF_Dop	chnget	"LF_Dop"
 
 kHF_Pan	chnget	"HF_Pan"							; panning modulation depth
 kLF_Pan	chnget	"HF_Pan"
 
 kHF_Amp	chnget	"HF_Amp"							; amplitude modulation depth
 kLF_Amp	chnget	"LF_Amp"

 aLF		butlp	aMix,kCF_Low						; woofer audio signal
 aHF		buthp	aMix,kCF_High						; tweeter audio signal

 if kSpeed==0 then										; if speed is slow
  kLF_Speed	=	kLF_Slow								; set woofer speed to slow speed as defined in the set-up pop-up
  kHF_Speed	=	kHF_Slow								; set tweeter speed to slow speed as defined in the set-up pop-up
 elseif kSpeed==2 then
  kLF_Speed	=	kLF_Fast								; set woofer speed to slow speed as defined in the set-up pop-up
  kHF_Speed	=	kHF_Fast								; set tweeter speed to slow speed as defined in the set-up pop-up
 else
  kLF_Speed	=	0										; set woofer speed to slow speed as defined in the set-up pop-up
  kHF_Speed	=	0										; set tweeter speed to slow speed as defined in the set-up pop-up
 endif
 
 kportramp	linseg	0,0.01,1							; portamento time ramps up quickly from zero
 kLF_Speed	portk	kLF_Speed,kLF_Damp					; damp speed change from 
 kHF_Speed	portk	kHF_Speed,kHF_Damp

 aHF_L,aHF_R	DopplerSpin	aHF,kHF_Speed,kHF_Amp,0.5,kHF_Pan,kHF_Dop,gisine	; call UDO
 aLF_L,aLF_R	DopplerSpin	aLF,kLF_Speed,kLF_Amp,0.5,kLF_Pan,kLF_Dop,gisine
 
		outs	aHF_L,aHF_R
 		outs	aLF_L,aLF_R

 ; GRAPHICAL ROTATING SPEAKERS 
 kPhsTweeter	poscil	1,kHF_Speed,gitri				
 kPhsWoofer	poscil	1,kLF_Speed,gitri
 ktrig	metro	16
 if ktrig==1 then
  Smsg	sprintfk	"bounds(%d,10,%d,16)",122+(8*(1-kPhsTweeter)),kPhsTweeter*16
  	chnset		Smsg,"TweeterID"
  Smsg	sprintfk	"bounds(%d,33,%d,40)",110+(20*(1-kPhsWoofer)),kPhsWoofer*40
  	chnset		Smsg,"WooferID"
 endif 
 		
 		chnclear	"send" 								; clear audio send channel (organ)
endin


instr 1000				; launches plant popups
 klaunch	init		0
 #define LAUNCH_PLANT(name)
 #
 kpressed	chnget 		"$name._Button"
 if changed(kpressed)==1 then
   Smsg 	sprintfk 	"show(%d), pos(1, 19)", klaunch
   		chnset 		Smsg, "$name.Plant"
 endif
 #
 $LAUNCH_PLANT(setup)
 klaunch	=		1
endin

</CsInstruments>

<CsScore>
i 99   0 [3600*24*7]
i 1000 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>; PhaserLFO.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("Phaser LFO") size(580, 95), pluginid("phsr") style("legacy")
image          bounds(0, 0, 580, 95), colour( 100, 110, 130), shape("rounded"), outlinecolour("white"), outlinethickness(4)
label    bounds(10,  8, 75, 10), text("INPUT"), fontcolour(0,10,30)
combobox bounds(10, 18, 75, 20), channel("input"), value(1), text("Live","Tone","Noise")
label    bounds(10, 43, 75, 10), text("LFO SHAPE"), fontcolour(0,10,30)
combobox bounds(10, 53, 75, 20), channel("shape"), value(1), text("Triangle","Sine","Square","Saw Up","Saw Down","Rand.Int","Rand.S&H")
line	bounds( 95, 10,190,  2)
label   bounds(155,  7, 70, 10), text("MODULATION"), fontcolour("white"), colour(100,110,130)
rslider bounds( 85, 20, 70, 70), text("Rate"), 		channel("rate"), 	range(0,100.00,0.5,0.5, 0.0001),    colour(50,40,110), textcolour(0,10,30), trackercolour(255,255,200), midiCtrl(1,1)
rslider bounds(155, 20, 70, 70), text("Depth"), 	channel("depth"), 	range(0, 1.00, 0.5, 1, .01),       colour(50,40,110), textcolour(0,10,30), trackercolour(255,255,200)
rslider bounds(225, 20, 70, 70), text("Offset"), 	channel("freq"), 	range(0, 1.00, 0.4, 1, .01),       colour(50,40,110), textcolour(0,10,30), trackercolour(255,255,200)
rslider bounds(295, 20, 70, 70), text("Feedback"), 	channel("fback"), 	range(0, 1.00, 0.4, 1, .01),       colour(50,40,110), textcolour(0,10,30), trackercolour(255,255,200)
rslider bounds(365, 20, 70, 70), text("Stages"),	channel("stages"), 	range(1, 64,8, 1, 1),              colour(50,40,110), textcolour(0,10,30), trackercolour(255,255,200)
rslider bounds(435, 20, 70, 70), text("Mix"), 	        channel("mix"), 	range(0, 1.00,0.5, 1, .01),        colour(50,40,110), textcolour(0,10,30), trackercolour(255,255,200)
rslider bounds(505, 20, 70, 70), text("Level"), 	channel("level"), 	range(0, 1.00, 1, 1, .01),         colour(50,40,110), textcolour(0,10,30), trackercolour(255,255,200)
</Cabbage>

<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;Author: Iain McCurdy (2012)
;http://iainmccurdy.org/csound.html


opcode	Phaser,a,akkkKki
	ain,krate,kdepth,kfreq,kstages,kfback,ishape	xin		;READ IN INPUT ARGUMENTS
	if ishape=1 then
	 klfo	lfo	kdepth*0.5, krate, 1				;LFO FOR THE PHASER (TRIANGULAR SHAPE)
	elseif ishape=2 then
	 klfo	lfo	kdepth*0.5, krate, 0				;LFO FOR THE PHASER (SINE SHAPE)
	elseif ishape=3 then
	 klfo	lfo	kdepth*0.5, krate, 2				;LFO FOR THE PHASER (SQUARE SHAPE)
	elseif ishape=4 then
	 klfo	lfo	kdepth*0.5, krate, 4				;LFO FOR THE PHASER (SAWTOOTH)
	elseif ishape=5 then
	 klfo	lfo	kdepth*0.5, krate, 5				;LFO FOR THE PHASER (SAWTOOTH)
	elseif ishape=6 then
	 klfo	randomi	-kdepth*0.5, kdepth*0.5, krate*8		;LFO FOR THE PHASER (RANDOMI SHAPE)
	 klfo	portk	klfo, 1/(krate*8)				;SMOOTH CHANGES OF DIRECTION
	elseif ishape=7 then
	 klfo	randomh	-kdepth*0.5, kdepth*0.5, krate			;LFO FOR THE PHASER (RANDOMH SHAPE)
	endif	
	aout	phaser1	ain, cpsoct((klfo+(kdepth*0.5)+kfreq)), kstages, kfback	;PHASER1 IS APPLIED TO THE INPUT AUDIO
		xout	aout							;SEND AUDIO BACK TO CALLER INSTRUMENT
endop

opcode	PhaserSt,aa,aakkkKki
	ainL,ainR,krate,kdepth,kfreq,kstages,kfback,ishape	xin		;READ IN INPUT ARGUMENTS
	if ishape=1 then
	 klfo	lfo	kdepth*0.5, krate, 1				;LFO FOR THE PHASER (TRIANGULAR SHAPE)
	elseif ishape=2 then
	 klfo	lfo	kdepth*0.5, krate, 0				;LFO FOR THE PHASER (SINE SHAPE)
	elseif ishape=3 then
	 klfo	lfo	kdepth*0.5, krate, 2				;LFO FOR THE PHASER (SQUARE SHAPE)
	elseif ishape=4 then
	 klfo	lfo	kdepth*0.5, krate, 4				;LFO FOR THE PHASER (SAWTOOTH)
	elseif ishape=5 then
	 klfo	lfo	kdepth*0.5, krate, 5				;LFO FOR THE PHASER (SAWTOOTH)
	elseif ishape=6 then
	 klfo	randomi	-kdepth*0.5, kdepth*0.5, krate*8		;LFO FOR THE PHASER (RANDOMI SHAPE)
	 klfo	portk	klfo, 1/(krate*8)				;SMOOTH CHANGES OF DIRECTION
	elseif ishape=7 then
	 klfo	randomh	-kdepth*0.5, kdepth*0.5, krate			;LFO FOR THE PHASER (RANDOMH SHAPE)
	endif
	aoutL	phaser1	ainL, cpsoct((klfo+(kdepth*0.5)+kfreq)), kstages, kfback	;PHASER1 IS APPLIED TO THE INPUT AUDIO
	aoutR	phaser1	ainR, cpsoct((klfo+(kdepth*0.5)+kfreq)), kstages, kfback	;PHASER1 IS APPLIED TO THE INPUT AUDIO
		xout	aoutL,aoutR							;SEND AUDIO BACK TO CALLER INSTRUMENT
endop

		instr 1
kporttime	linseg		0,0.001,0.05
krate		chnget		"rate"
kdepth 		chnget 		"depth"
kdepth		portk		kdepth,kporttime
kfreq 		chnget 		"freq"
kfreq		portk		kfreq,kporttime
kfback 		chnget 		"fback"
kstages 	chnget 		"stages"
klevel 		chnget 		"level"
kmix		chnget		"mix"
kshape		chnget		"shape"
kshape		init		1

/* INPUT */
kinput		chnget	"input"
if kinput=1 then
 a1,a2		ins
elseif kinput=2 then
 a1		vco2		0.1,200
 a2		=		a1
else
 a1		pinkish		0.1
 a2		pinkish		0.1
endif

ktrig		changed		kshape,kstages							; reinitialise for i-rate parms
if ktrig=1 then
 reinit 	RESTART_PHASER
endif
RESTART_PHASER:
;aPhs1		Phaser		a1,krate,kdepth*8,(kfreq*5)+6,kstages,kfback*0.9,i(kshape)	; call UDO
;aPhs2		Phaser		a2,krate,kdepth*8,(kfreq*5)+6,kstages,kfback*0.9,i(kshape)
aPhs1,aPhs2	PhaserSt	a1,a2,krate,kdepth*8,(kfreq*10)+4,kstages,kfback*0.9,i(kshape)	; use stereo version to ensure lfo sync for random lfos

rireturn
a1		ntrpol		a1,aPhs1,kmix							; wet/dry mix
a2		ntrpol		a2,aPhs2,kmix
		outs		a1* klevel, a2* klevel
		endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; StereoChorus.csd
; Written by Iain McCurdy, 2012.

; Two LFO modes are offered, sines and rsplines.
; 

; Dereg. (deregulate) adds a random modulation to both LFO rate and depth in both LFO modes

<Cabbage>
form caption("Stereo Chorus") size(595, 100), pluginid("StCh") style("legacy")
image                 bounds(0, 0, 595, 100), colour("DarkSlateGrey"), shape("rounded"), outlinecolour("white"), outlinethickness(6)
label    bounds( 15, 22, 75, 12), text("LFO Type:"), fontcolour("white")
combobox bounds( 15, 35, 75, 20), text("Sine","RSpline"), channel("type"), textcolour("white"), colour( 7,29,29), fontcolour("white")
rslider  bounds( 90, 13, 75, 75), text("Rate"), channel("rate"), range(0.001, 7, 0.5,0.5),  textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(160, 13, 75, 75), text("Dereg"), channel("dereg"), range(0, 4, 0,0.5,0.01), textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(230, 13, 75, 75), text("Depth"), channel("depth"), range(0, 1.00, 0.2),     textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(300, 13, 75, 75), text("Offset"), channel("offset"), range(0.0001,0.1,0.001,0.5,0.0001),     textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(370, 13, 75, 75), text("Width"), channel("width"), range(0, 1.00, 0.75),    textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(440, 13, 75, 75), text("Mix"), channel("mix"), range(0, 1.00, 0.5),      textcolour("white"), colour(37,59,59), trackercolour("Silver")
rslider  bounds(510, 13, 75, 75), text("Level"), channel("level"), range(0, 1.00, 1),      textcolour("white"), colour(37,59,59), trackercolour("Silver")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;Author: Iain McCurdy (2012)
;http://iainmccurdy.org/csound.html

opcode	StChorus,aa,aakkakk
	ainL,ainR,krate,kdepth,aoffset,kwidth,kmix	xin			;READ IN INPUT ARGUMENTS
	ilfoshape	ftgentmp	0, 0, 131072, 19, 1, 0.5, 0,  0.5	;POSITIVE DOMAIN ONLY SINE WAVE
	kporttime	linseg	0,0.001,0.02					;RAMPING UP PORTAMENTO VARIABLE
	kChoDepth	portk	kdepth*0.01, kporttime				;SMOOTH VARIABLE CHANGES WITH PORTK
	aChoDepth	interp	kChoDepth					;INTERPOLATE TO CREATE A-RATE VERSION OF K-RATE VARIABLE
	amodL 		osciliktp 	krate, ilfoshape, 0			;LEFT CHANNEL LFO
	amodR 		osciliktp 	krate, ilfoshape, kwidth*0.5		;THE PHASE OF THE RIGHT CHANNEL LFO IS ADJUSTABLE
	amodL		=		(amodL*aChoDepth)+aoffset			;RESCALE AND OFFSET LFO (LEFT CHANNEL)
	amodR		=		(amodR*aChoDepth)+aoffset			;RESCALE AND OFFSET LFO (RIGHT CHANNEL)
	aChoL		vdelay	ainL, amodL*1000, 1.2*1000			;CREATE VARYING DELAYED / CHORUSED SIGNAL (LEFT CHANNEL) 
	aChoR		vdelay	ainR, amodR*1000, 1.2*1000			;CREATE VARYING DELAYED / CHORUSED SIGNAL (RIGHT CHANNEL)
	aoutL		ntrpol 	ainL*0.6, aChoL*0.6, kmix			;MIX DRY AND WET SIGNAL (LEFT CHANNEL)
	aoutR		ntrpol 	ainR*0.6, aChoR*0.6, kmix			;MIX DRY AND WET SIGNAL (RIGHT CHANNEL)
			xout	aoutL,aoutR					;SEND AUDIO BACK TO CALLER INSTRUMENT
endop


giPow3  ftgen 1,0,2048,10,1			; table for storage of functions
iftlen =       ftlen(giPow3)			; length of the function table
icount	=	0				; reset counter. (Moves for each index of the function table)
loop3:						; loop beginning                                            
ix	=	((icount/iftlen) * 2) -1        ; shift x range to -1 to 1                                  
iy	=	ix ^ 3                          ; apply formula to derive y                                 
	tableiw iy,icount,giPow3                ; write y value to table                                    
loop_lt,icount,1,iftlen,loop3                   ; loop back and increment counter if we are not yet finished

opcode	StChorusRspline,aa,aakkkkkk
	ainL,ainR,krate,kdereg,kdepth,koffset,kwidth,kmix	xin		;READ IN INPUT ARGUMENTS
	kporttime	linseg	0,0.001,0.02					;RAMPING UP PORTAMENTO VARIABLE
	kChoDepth	portk	kdepth*0.01, kporttime				;SMOOTH VARIABLE CHANGES WITH PORTK	
	kmod1		rspline	koffset,kChoDepth, krate*4+0.01, ((krate*4*kdereg)+0.01)
	kmod2		rspline	kChoDepth,koffset, krate*4+0.01, ((krate*4*kdereg)+0.01)
	kmod1		limit	kmod1,0.0001,1.2
	kmod2		limit	kmod2,0.0001,1.2
	amod1		interp	kmod1	
	amod2		interp	kmod2
	aCho1		vdelay	ainL, amod1*1000, 1.2*1000			;CREATE VARYING DELAYED / CHORUSED SIGNAL (LEFT CHANNEL) 
	aCho2		vdelay	ainR, amod2*1000, 1.2*1000			;CREATE VARYING DELAYED / CHORUSED SIGNAL (RIGHT CHANNEL)
	kpan		rspline	0,1,krate,2*krate*kdereg			;PANNING
	kpan		limit	kpan,0,1
	apan		interp	kpan
	aChoL		=	(aCho1*apan)+(aCho2*(1-apan))
	aChoR		=	(aCho2*apan)+(aCho1*(1-apan))
	aChoL		ntrpol	aChoL,aCho1,kwidth				;WIDTH PROCESSING BETWEEN AUTO-PANNED AND HARD-PANNED
	aChoR		ntrpol	aChoR,aCho2,kwidth
	aoutL		ntrpol 	ainL*0.6, aChoL*0.6, kmix			;MIX DRY AND WET SIGNAL (LEFT CHANNEL)
	aoutR		ntrpol 	ainR*0.6, aChoR*0.6, kmix			;MIX DRY AND WET SIGNAL (RIGHT CHANNEL)
			xout	aoutL,aoutR					;SEND AUDIO BACK TO CALLER INSTRUMENT
endop

instr 1
 kporttime	linseg	0,0.001,0.05                                                     
 krate chnget "rate"
 kdereg chnget "dereg"
 kdepth chnget "depth"
 koffset chnget "offset"
 kwidth chnget "width"
 klevel chnget "level"
 kmix  	chnget "mix"
 ktype	chnget	"type"
 ktype	init	1
 kmix	portk	kmix,kporttime
 klevel	portk	klevel,kporttime
 koffset	portk	koffset,kporttime*0.5
 aoffset	interp	koffset
 
 a1,a2	ins
 ;a1	pinkish	0.1
 ;a2	pinkish	0.1
 ;a1	vco2	0.1,50,4,0.5
 ;a2	vco2	0.1,50,4,0.5
 ;a1	poscil	0.1,100
 ;a2	poscil	0.1,100
 
 
 if ktype==1 then
  kdereg	rspline	-kdereg, kdereg, 0.1, 0.5
  ktrem	rspline	0,-1,0.1,0.5
  ktrem	pow	2,ktrem
  a1,a2	StChorus	a1,a2,krate*octave(kdereg),kdepth*ktrem,aoffset,kwidth,kmix
 else
  a1,a2	StChorusRspline	a1,a2,krate,kdereg,kdepth,koffset,kwidth,kmix
 endif
 a1	=	a1 * klevel
 a2	=	a2 * klevel
 	outs	a1,a2
endin

</CsInstruments>

<CsScore>                                              
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>                                                  ; Ball_in_a_Box.csd
; Written by Iain McCurdy, 2015

; Ball in a Box is a physical model reverb based on the notional idea of a ball (sound) within a bax (reverberant space)

; Room Size (X, Y, Z)		-	room size in metres
; Source Location (X, Y, Z)	-	location of the sound as a ratio 0 to 1 of the entire space
; Receive Location (X, Y, Z)	-	receiver location - in metres - from the centre of the space
; Reverb Decay			-	main decay of the resonator (default: 0.99)
; High Frequency Diffusion	-	is the coefficient of diffusion at the walls, which regulates the amount of diffusion (0-1, where 0 = no diffusion, 1 = maximum diffusion - default: 1)
; Direct Signal Attenuation	-	the attenuation of the direct signal (0-1, default: 0.5)
; Early Reflection Diffusion	-	the attenuation coefficient of the early reflections (0-1, default: 0.8)
; Pick-up Separation		-	the distance in meters between the two pickups (your ears, for example - default: 0.3)

<Cabbage>
form caption("Ball in a Box") size(800,395), pluginid("BABO"), colour(100,100,120) style("legacy")

image   bounds(  3,  5,394,125), outlinecolour("white"), outlinethickness(1), colour(0,0,0,0), plant("RoomSize") {
hslider bounds(  5, 10,390, 30), textcolour(white), channel("rx"), range(0.1,20.00, 5), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 33,390, 12), text("Room Size X"), fontcolour(200,200,200)
hslider bounds(  5, 45,390, 30), textcolour(white), channel("ry"), range(0.1,20.00, 6), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 68,390, 12), text("Room Size Y"), fontcolour(200,200,200)
hslider bounds(  5, 80,390, 30), textcolour(white), channel("rz"), range(0.1,20.00, 4), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5,103,390, 12), text("Room Size Z"), fontcolour(200,200,200)
}

image   bounds(  3,135,394,125), outlinecolour("white"), outlinethickness(1), colour(0,0,0,0), plant("SourceLocation") {
hslider bounds(  5, 10,390, 30), textcolour(white), channel("srcx"), range(0,1.00, 0.131), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 33,390, 12), text("Source Location X"), fontcolour(200,200,200)
hslider bounds(  5, 45,390, 30), textcolour(white), channel("srcy"), range(0,1.00, 0.243), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 68,390, 12), text("Source Location Y"), fontcolour(200,200,200)
hslider bounds(  5, 80,390, 30), textcolour(white), channel("srcz"), range(0,1.00, 0.717), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5,103,390, 12), text("Source Location Z"), fontcolour(200,200,200)
}

image   bounds(  3,265,394,125), outlinecolour("white"), outlinethickness(1), colour(0,0,0,0), plant("ReceiveLocation") {
hslider bounds(  5, 10,390, 30), textcolour(white), channel("rcvx"), range(-10,10,7.331), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 33,390, 12), text("Receive Location X"), fontcolour(200,200,200)
hslider bounds(  5, 45,390, 30), textcolour(white), channel("rcvy"), range(-10,10,-3.973), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 68,390, 12), text("Receive Location Y"), fontcolour(200,200,200)
hslider bounds(  5, 80,390, 30), textcolour(white), channel("rcvz"), range(-10,10, 6.791), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5,103,390, 12), text("Receive Location Z"), fontcolour(200,200,200)
}

image   bounds(403,  5,394,105), outlinecolour("white"), outlinethickness(1), colour(0,0,0,0), plant("Mixer") {
hslider bounds(  5, 10,390, 30), textcolour(white), channel("mix"), range(0, 1.00, 0.5), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 35,390, 12), text("Dry/Wet Mix"), fontcolour(200,200,200)
hslider bounds(  5, 55,390, 30), textcolour(white), channel("level"), range(0, 1.00, 0.5), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 80,390, 12), text("Level"), fontcolour(200,200,200)
}

image   bounds(403,115,394,275), outlinecolour("white"), outlinethickness(1), colour(0,0,0,0), plant("Filters") {
hslider bounds(  5, 20,390, 30), textcolour(white), channel("decay"), range(0.01, 1.00, 0.3), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 45,390, 12), text("Reverb Decay"), fontcolour(200,200,200)
hslider bounds(  5, 60,390, 30), textcolour(white), channel("diff"), range(0.01, 1.00, 1), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5, 85,390, 12), text("High Frequency Diffusion"), fontcolour(200,200,200)
hslider bounds(  5,100,390, 30), textcolour(white), channel("hydecay"), range(0.001, 1.00, 0.1), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5,125,390, 12), text("High Frequency Decay"), fontcolour(200,200,200)
hslider bounds(  5,140,390, 30), textcolour(white), channel("direct"), range(0, 1.00, 0.5), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5,165,390, 12), text("Direct Signal Attenuation"), fontcolour(200,200,200)
hslider bounds(  5,180,390, 30), textcolour(white), channel("early_diff"), range(0, 1.00, 0.8), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5,205,390, 12), text("Early Reflection Diffusion"), fontcolour(200,200,200)
hslider bounds(  5,220,390, 30), textcolour(white), channel("rdistance"), range(0.001, 9.00, 0.3), colour(220,220,250), trackercolour(240,210,170)
label   bounds(  5,245,390, 12), text("Pick-up Separation"), fontcolour(200,200,200)
}

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1

;Author: Iain McCurdy (2015)

instr	1	; read widgets
 gkrx		chnget	"rx"        
 gkry           chnget	"ry"        
 gkrz           chnget	"rz"        
 gksrcx         chnget	"srcx"      
 gksrcy         chnget	"srcy"      
 gksrcz         chnget	"srcz"      
 gkdiff         chnget	"diff"      
 gkdecay        chnget	"decay"     
 gkrdistance    chnget	"rdistance" 
 gkhydecay      chnget	"hydecay"   
 gkdirect       chnget	"direct"    
 gkearly_diff   chnget	"early_diff"
 gkrcvx         chnget	"rcvx"      
 gkrcvy         chnget	"rcvy"      
 gkrcvz         chnget	"rcvz"
 gkmix          chnget	"mix"
 gklevel	chnget	"level"
endin

instr	2	;REVERB
 aL,aR	ins	; read 
 kSwitch		changed		gkrx, gkry, gkrz, gksrcx, gksrcy, gksrcz, gkdiff, gkdecay, gkrdistance, gkhydecay, gkdirect, gkearly_diff, gkrcvx, gkrcvy, gkrcvz	;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
 if	kSwitch=1	then	;IF kSwitch=1 THEN
 	reinit	UPDATE		;BEGIN A REINITIALIZATION PASS FROM LABEL 'UPDATE'
 endif				;END OF CONDITIONAL BRANCHING
 UPDATE:				;A LABEL
 irx		init	i(gkrx)	;CREATE I-RATE VARIABLES FROM K-RATE VARIABLES
 iry		init	i(gkry) ;CREATE I-RATE VARIABLES FROM K-RATE VARIABLES
 irz		init	i(gkrz) ;CREATE I-RATE VARIABLES FROM K-RATE VARIABLES
 ksrcx		init	i(gksrcx) * irx	;THE ACTUAL LOCATION OF THE SOURCE SOUND IS DEFINED RELATIVE TO THE SIZE OF THE ROOM
 ksrcy		init	i(gksrcy) * iry	;THE ACTUAL LOCATION OF THE SOURCE SOUND IS DEFINED RELATIVE TO THE SIZE OF THE ROOM
 ksrcz		init	i(gksrcz) * irz	;THE ACTUAL LOCATION OF THE SOURCE SOUND IS DEFINED RELATIVE TO THE SIZE OF THE ROOM
 idiff		init	i(gkdiff) ;CREATE I-RATE VARIABLES FROM K-RATE VARIABLES
 giBaboVals	ftgen	1, 0, 8, -2, i(gkdecay), i(gkhydecay), i(gkrcvx), i(gkrcvy), i(gkrcvz), i(gkrdistance), i(gkdirect), i(gkearly_diff)
 aRvbL, aRvbR	babo	aL + aR, ksrcx, ksrcy, ksrcz, irx, iry, irz, idiff, giBaboVals	;BABO REVERBERATOR
 rireturn			;RETURN TO PERFORMANCE TIME PASSES
 		outs	((aRvbL*gkmix)+(aL*(1-gkmix)))*gklevel, ((aRvbR*gkmix)+(aR*(1-gkmix)))*gklevel
endin

		
</CsInstruments>

<CsScore>
i 1 0   3600
i 2 0.1 3600	;REVERB INSTRUMENT PLAYS FOR 1 HOUR (AND KEEPS PERFORMANCE GOING)
</CsScore>

</CsoundSynthesizer>
; ConvolutionReverb.csd
; Written by Iain McCurdy, 2012.
; 
; ------------------
; You are encouraged to experiment with different impulse files.
; You can try this one to start with: http://www.iainmccurdy.org/CsoundRealtimeExamples/SourceMaterials/Stairwell.wav
; You can find some here: http://www.openairlib.net/
; NOTE THAT ZERO LATENCY (or close to zero) CONV0LUTION WILL NOT BE POSSIBLE.
; 
; Instructions
; ------------
; 'Size Ratio' compresses the duration of the impulse file (provided that 'compressed' is chosen for 'resize' mode).
; 'Curve' defines the shape of an envelope applied to compressed impulse files using GEN16
; 	zero		=	straight line decaying
; 	positive vals. 	=	increasingly convex decaying
; 	negative vals	=	increasingly concave decaying
; Increase 'iplen' (must be a power of 2) if experiencing performance problems, or reduce it to reduce latency.
; 'Delay OS' fine tunes the delay applied to the dry signal. Normally this should be zero but adjust it to modify how the dry signal lines up with the convoluted signal.

<Cabbage>
form caption("Convolution Reverb") size(505,230), pluginid("Conv") style("legacy")
image bounds(0, 0, 505,230), colour(135, 30, 30,220), shape("rounded"), outlinecolour(255,255,150), outlinethickness(4) 
label   bounds( 29,  10, 55, 12),       text("direction:"), fontcolour(250,250,250)
button  bounds( 10,  22, 90, 20),       text("forward","backward"),                            channel("FwdBwd"), value(0), fontcolour(250,250,250)
label   bounds( 33,  43, 45, 12),       text("resize:"), fontcolour(250,250,250)
button  bounds( 10,  55, 90, 20),       text("normal","compressed"),                           channel("resize"), value(0), fontcolour(250,250,250)
rslider bounds(105, 11, 70, 70),        text("Size Ratio"),     colour(115, 10, 10), trackercolour(255,255,150), outlinecolour( 75, 35,  0), textcolour(250,250,250),  channel("CompRat"),     range(0, 1.00, 1)
rslider bounds(170, 11, 70, 70),        text("Curve"),          colour(115, 10, 10), trackercolour(255,255,150), outlinecolour( 75, 35,  0), textcolour(250,250,250),  channel("Curve"),       range(-8.00, 8.00, 0)
rslider bounds(235, 11, 70, 70),        text("In Skip"),        colour(115, 10, 10), trackercolour(255,255,150), outlinecolour( 75, 35,  0), textcolour(250,250,250),  channel("skipsamples"), range(0, 1.00, 0)
rslider bounds(300, 11, 70, 70),        text("Del.OS."),        colour(115, 10, 10), trackercolour(255,255,150), outlinecolour( 75, 35,  0), textcolour(250,250,250),  channel("DelayOS"),     range(-1.00, 1.00, 0)
rslider bounds(365, 11, 70, 70),        text("Mix"),            colour(115, 10, 10), trackercolour(255,255,150), outlinecolour( 75, 35,  0), textcolour(250,250,250),  channel("mix"),         range(0, 1.00, 0.25)
rslider bounds(430, 11, 70, 70),        text("Level"),          colour(115, 10, 10), trackercolour(255,255,150), outlinecolour( 75, 35,  0), textcolour(250,250,250),  channel("level"),       range(0, 1.00, 0.4)

filebutton bounds( 10, 90, 90, 25), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
soundfiler bounds(110, 90,380,125), channel("beg","len"), identchannel("ImpulseFile"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255)
label      bounds(114, 92,300, 16), text(""), align(left), colour(0,0,0,0), fontcolour(255,255,255,150), identchannel("stringbox")
label      bounds(114, 92,350, 16), text("First open a short stereo impulse sound file..."), align(left), fontcolour(255,255,255,150), visible(1), identchannel("InstructionID")
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

;giImpulse	ftgen	1,0,0,1,"D:/Csound/SSDIR/stairwell.wav",0,0,0	; load stereo file
giImpulse	ftgen	1,0,2,-2,0
giDisplay	ftgen	2,0,ftlen(giImpulse),2,0						; display table table
tableicopy 2, 1
gkReady	init	0

; reverse function table UDO
opcode	tab_reverse,i,i
ifn             xin
iTabLen         =               ftlen(ifn)
iTableRev       ftgen           ifn + 100,0,-iTabLen,-2, 0
icount          =               0
loop:
ival            table           iTabLen-icount-1, ifn
                tableiw         ival,icount,iTableRev
                loop_lt         icount,1,iTabLen,loop
                xout   	        iTableRev
endop

; compress function table UDO
opcode	tab_compress,i,iii
ifn,iCompRat,iCurve    xin
iTabLen         =               ftlen(ifn)
iTabLenComp     =               int(ftlen(ifn)*iCompRat)
iTableComp      ftgen           ifn+200,0,-iTabLenComp,-2, 0
iAmpScaleTab	ftgen		ifn+300,0,-iTabLenComp,-16, 1,iTabLenComp,iCurve,0
icount          =               0
loop:
ival            table           icount, ifn
iAmpScale	table		icount, iAmpScaleTab
                tableiw         ival*iAmpScale,icount,iTableComp
                loop_lt         icount,1,iTabLenComp,loop
                xout   	        iTableComp
endop

; compress reverse function table UDO
opcode	tab_compress_rev,i,iii
ifn,iCompRat,iCurve    xin
iTabLen         =               nsamp(ifn)
iTabLenComp     =               int(nsamp(ifn)*iCompRat)
iTableComp      ftgen           ifn+400,0,-iTabLenComp,-2, 0
iAmpScaleTab	ftgen		ifn+500,0,-iTabLenComp,-16, 1,iTabLenComp,iCurve,0
icount          =               0
loop:
ival            table           icount, ifn
iAmpScale	table		icount, iAmpScaleTab
                tableiw         ival*iAmpScale, iTabLenComp-icount-1,iTableComp
                loop_lt         icount,1,iTabLenComp,loop
                xout   	        iTableComp
endop

opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin				; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:					; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:				; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1		; Create a new string of just the file name
	xout	Sname			; Send it back to the caller instrument
endop

instr	1
	gSfilepath	chnget	"filename"
	kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
	if kNewFileTrg==1 then				; if a new file has been loaded...
	 event	"i",99,0,0				; call instrument to update sample storage function table 
	endif
	
	if trigger:k(gkReady,0.5,0)==1 then		; when a file is loaded for the first time do this conditional branch...
	 event	"i",2,0,3600*24*7			; start the convolution instrument
	endif
endin

instr	2	;CONVOLUTION REVERB INSTRUMENT
	chnset	"visible(0)","InstructionID"		; hide the instruction

	kFwdBwd		chnget	"FwdBwd"
	kresize		chnget	"resize"
	kmix		chnget	"mix"
	klevel		chnget	"level"
	kCompRat	chnget	"CompRat"
	kCurve		chnget	"Curve"
	kskipsamples	chnget	"skipsamples"
	kDelayOS	chnget	"DelayOS"
	kCompRat       init	1 			;IF THIS IS LEFT UNINITIALISED A CRASH WILL OCCUR! 

	
	ainL,ainR	ins				;READ STEREO AUDIO INPUT
	;ainL,ainR	diskin2	"808loop.wav",1,0,1	;USE A SOUND FILE FOR TESTING
	ainMix		sum	ainL,ainR
	
	;CREATE REVERSED TABLES
	irev	tab_reverse	giImpulse
        
        kSwitchStr	changed	gSfilepath
	kSwitchStr	delayk	kSwitchStr,1
	kSwitch	changed		kskipsamples,kFwdBwd,kDelayOS,kCompRat,kCurve,kresize	;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
	kSwitch	+=	kSwitchStr
	if	kSwitch=1	then			;IF I-RATE VARIABLE IS CHANGED...
		reinit	UPDATE				;BEGIN A REINITIALISATION PASS IN ORDER TO EFFECT THIS CHANGE. BEGIN THIS PASS AT LABEL ENTITLED 'UPDATE' AND CONTINUE UNTIL rireturn OPCODE 
	endif						;END OF CONDITIONAL BRANCHING
	UPDATE:						;LABEL
	
	;CREATE COMPRESSED TABLES
	icomp	tab_compress	giImpulse,i(kCompRat),i(kCurve)
        
	;CREATE COMPRESSED REVERSED TABLES
	icomprev	tab_compress_rev	giImpulse,i(kCompRat),i(kCurve)
        
	iplen		=	1024				;BUFFER LENGTH (INCREASE IF EXPERIENCING PERFORMANCE PROBLEMS, REDUCE IN ORDER TO REDUCE LATENCY)
	itab		=	giImpulse			;DERIVE FUNCTION TABLE NUMBER OF CHOSEN TABLE FOR IMPULSE FILE
	iirlen		=	nsamp(itab)*0.5			;DERIVE THE LENGTH OF THE IMPULSE RESPONSE IN SAMPLES. DIVIDE BY 2 AS TABLE IS STEREO.
	iskipsamples	=	nsamp(itab)*0.5*i(kskipsamples)	;DERIVE INSKIP INTO IMPULSE FILE. DIVIDE BY 2 (MULTIPLY BY 0.5) AS ALL IMPULSE FILES ARE STEREO
	
	;FORWARDS REVERB
	if kFwdBwd==0&&kresize==0 then
	 aL,aR	ftconv	ainMix, itab, iplen,iskipsamples, iirlen		;CONVOLUTE INPUT SOUND
	 adelL	delay	ainL, abs((iplen/sr)+i(kDelayOS)) 	;DELAY THE INPUT SOUND ACCORDING TO THE BUFFER SIZE
	 adelR	delay	ainR, abs((iplen/sr)+i(kDelayOS)) 	;DELAY THE INPUT SOUND ACCORDING TO THE BUFFER SIZE
        
        ;BACKWARDS REVERB
        elseif kFwdBwd==1&&kresize==0 then
	 aL,aR	ftconv	ainMix, irev, iplen, iskipsamples, iirlen				;CONVOLUTE INPUT SOUND
	 adelL	delay	ainL,abs((iplen/sr)+(iirlen/sr)-(iskipsamples/sr)+i(kDelayOS))	;DELAY THE INPUT SOUND ACCORDING TO THE BUFFER SIZE AND THE DURATION OF THE IMPULSE FILE
	 adelR	delay	ainR,abs((iplen/sr)+(iirlen/sr)-(iskipsamples/sr)+i(kDelayOS))	;DELAY THE INPUT SOUND ACCORDING TO THE BUFFER SIZE AND THE DURATION OF THE IMPULSE FILE
        
        ;FORWARDS COMPRESSED
	elseif kFwdBwd==0&&kresize==1 then
	 aL,aR	ftconv	ainMix, icomp, iplen,iskipsamples, iirlen*i(kCompRat)		;CONVOLUTE INPUT SOUND
	 adelL	delay	ainL, abs((iplen/sr)+i(kDelayOS)) 				;DELAY THE INPUT SOUND ACCORDING TO THE BUFFER SIZE
	 adelR	delay	ainR, abs((iplen/sr)+i(kDelayOS)) 				;DELAY THE INPUT SOUND ACCORDING TO THE BUFFER SIZE
        
        ;BACKWARDS COMPRESSED
	elseif kFwdBwd==1&&kresize==1 then
	 aL,aR	ftconv	ainMix, icomprev, iplen, iskipsamples, iirlen*i(kCompRat)		;CONVOLUTE INPUT SOUND
	 adelL	delay	ainL,abs((iplen/sr)+((iirlen*i(kCompRat))/sr)-(iskipsamples/sr)+i(kDelayOS))	;DELAY THE INPUT SOUND ACCORDING TO THE BUFFER SIZE AND THE DURATION OF THE IMPULSE FILE
	 adelR	delay	ainR,abs((iplen/sr)+((iirlen*i(kCompRat))/sr)-(iskipsamples/sr)+i(kDelayOS))	;DELAY THE INPUT SOUND ACCORDING TO THE BUFFER SIZE AND THE DURATION OF THE IMPULSE FILE
	endif
                 
        rireturn
        
	; CREATE A DRY/WET MIX
	aMixL	ntrpol	adelL,aL*0.1,kmix
	aMixR	ntrpol	adelR,aR*0.1,kmix
        	outs	aMixL*klevel,aMixR*klevel

endin




instr	99	; load sound file
 	giImpulse	ftgen	1,0,0,1,gSfilepath,0,0,0	; load stereo file
 	gkReady 	init	1					; if no string has yet been loaded giReady will be zero
 	Smessage sprintfk "file(%s)", gSfilepath			; print file to viewer
 	chnset Smessage, "filer1"	

 	Smessage sprintfk "file(%s)", gSfilepath			; print sound file image to fileplayer
 	chnset Smessage, "ImpulseFile"

	Sname	FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
	Smessage sprintfk "text(%s)",Sname
	chnset Smessage, "stringbox"
endin


;instr	99	; load sound file
; Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
; Smessage sprintfk "text(%s)",Sname
; chnset Smessage, "stringbox"
;endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*7*24] 
</CsScore>

</CsoundSynthesizer>
; DistanceEmulator.csd
; Written by Iain McCurdy, 2015
	
<Cabbage>
form caption("Distance Emulator") size(700,300), colour(200,210,180), pluginid("DsEm") style("legacy")
hslider   bounds(  5,  5,240, 30), channel("Amp1"), text("Amp.1"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 1, 0.5, 0.001)
hslider   bounds(255,  5,240, 30), channel("Amp2"), text("Amp.2"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 0.25, 0.5, 0.001)
hslider   bounds(  5, 55,240, 30), channel("Rvb1"), text("Rvb.1"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 0, 0.5, 0.001)
hslider   bounds(255, 55,240, 30), channel("Rvb2"), text("Rvb.2"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 1, 0.5, 0.001)
nslider bounds(505, 55, 70, 30), channel("RvbSize"), text("Size"),  colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0,0.999, 0.8,0.5,0.001)
nslider bounds(585, 55, 70, 30), channel("RvbLPF"), text("RvbLPF"), colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(20,20000,5000,0.5)
hslider   bounds(  5,105,240, 30), channel("LPF1"), text("LPF.1"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 0)
hslider   bounds(255,105,240, 30), channel("LPF2"), text("LPF.2"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 1)
nslider bounds(505,105, 70, 30), channel("LPF_CF"), text("Cutoff"), colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(20,20000,5000,0.5)
hslider   bounds(  5,155,240, 30), channel("HPF1"), text("HPF.1"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 0)
hslider   bounds(255,155,240, 30), channel("HPF2"), text("HPF.2"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 1)
nslider bounds(505,155, 70, 30), channel("HPF_CF"), text("Cutoff"), colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(20,20000,150,0.5)
hslider   bounds(  5,205,240, 30), channel("Wid1"), text("Width"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 1)
hslider   bounds(255,205,240, 30), channel("Wid2"), text("Width"),    colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 1)
hslider   bounds(  5,255,690, 30), channel("Mor"), text("Morph"),     colour(100,140,150), trackercolour(200,240,250), textcolour("DarkSlateGrey"), range(0, 1, 0)

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1


instr	1
 kPortTime	linseg	0,0.001,0.2
 kAmp1		chnget	"Amp1"
 kAmp2		chnget	"Amp2"
 kRvb1		chnget	"Rvb1"
 kRvb2		chnget	"Rvb2"
 kRvbSize	chnget	"RvbSize"
 kRvbLPF	chnget	"RvbLPF"
 kLPF1		chnget	"LPF1"
 kLPF2		chnget	"LPF2"
 kLPF_CF	chnget	"LPF_CF"
 kHPF1		chnget	"HPF1"
 kHPF2		chnget	"HPF2"
 kHPF_CF	chnget	"HPF_CF"
 kWid1		chnget	"Wid1"
 kWid2		chnget	"Wid2"
 kMor		chnget	"Mor"
 kMor		portk	kMor,kPortTime
 
 aL,aR	ins
 ;aL,aR	diskin2	"ClassicalGuitar.wav",1,0,1
 
 kAmp	ntrpol	kAmp1,kAmp2,kMor
 kRvb	ntrpol	kRvb1,kRvb2,kMor
 kLPF	ntrpol	kLPF1,kLPF2,kMor
 kHPF	ntrpol	kHPF1,kHPF2,kMor
 kWid	ntrpol	kWid1,kWid2,kMor
 kHPF	pow	kHPF,0.2
 kLPF	pow	kLPF,0.2
 
 aL	*=	kAmp^2
 aR	*=	kAmp^2

 aLPF_L	butlp	aL,kLPF_CF
 aLPF_R	butlp	aR,kLPF_CF
 aL		ntrpol		aL,aLPF_L,kLPF 
 aR		ntrpol		aR,aLPF_R,kLPF 
 	
 aHPF_L	buthp	aL,kHPF_CF
 aHPF_R	buthp	aR,kHPF_CF
 aL		ntrpol		aL,aHPF_L,kHPF 
 aR		ntrpol		aR,aHPF_R,kHPF 

 aRvbL,aRvbR	reverbsc	aL,aR,kRvbSize,kRvbLPF
 aL		ntrpol		aL,aRvbL,kRvb 
 aR		ntrpol		aR,aRvbR,kRvb 
 
 aWidL		ntrpol		aL,(aL+aR)*0.75,kWid
 aWidR		ntrpol		aR,(aL+aR)*0.75,kWid
 aL		=		aWidL
 aR		=		aWidR
 
 	outs	aL,aR
 
 

endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>; GateReverb.csd
; Written by Iain McCurdy, 2015.

; This effect implements a gate reverb effect using a multitap delay.
; The number of delay taps can be very large so their times are not defined explicitly but instead are derived from a number of global input parameters.

; Duration	-	the duration (in seconds) of a gate period
; N.Taps	-	the number of taps within the gate period (NB. increasing this parameter increases CPU and RAM demand)

; Scat.Amp.	-	random scattering of tap amplitudes
; Shape		-	envelope shaping of the gate reverb: 0=flat, <0=decay, >0=build
; Scat.Tim.	-	Scattering of delay tap times.

; Input/Ouput	-	input/output modes:
;			 Mono		-	input taken from left channel input, a single processed channel is sent to both outputs
;			 Stereo Match	-	stereo in / stereo out. 
;						Random values for left and right channels used for amplitude scattering and delay tap time scattering match resulting in a narrower stereo effect.
;			 Stereo Diff	-	stereo in / stereo out. 
;						Random values for left and right channels used for amplitude scattering and delay tap time scattering differ resulting in a wider stereo effect.
;			 (NB both stereo modes will employ double the number of taps specified by 'N.Taps' thereby doubling CPU and RAM usage for this function with respect to the mono mode.)
; Delay Dry	-	When activated the dry signal is delayed by the amount specified by 'Duration'. This can be particularly useful when using a 'build' reverb shape with a 50:50 dry/wet mix.

; Filter option filters each tap at a randomly selected cutoff frequency
; **Note that N.Taps may need to be reduced if CPU overloads**
; Choose between 'Bypass' (no filter), 'Lowpass' (moogvcf2 resonant filter) or 'bandpass' (butbp)
; Min.		-	minimum limit for random cutoff frequency selection
; Max.		-	maximum limit for random cutoff frequency selection
; Q.		-	Filter quality: Lowpass=resonance Bandpass=bandwidth


; Mix		-	dry/wet mix. 
;			 Note that on account of the accumulation of overlapping delay taps, the wet signal is liable to be much louder than the dry signal.
;			 This can be compensated for using the dry/wet control.
; Level		-	output level

<Cabbage>
form caption("Gate Reverb"), size(850, 85), pluginid("GtRv"), colour(13, 50, 67,50) style("legacy")
image              bounds(  0,  0,850, 85), colour(DarkSlateGrey),  shape("sharp")

#define RSliderStyle # colour(150,205,150), textcolour(200,250,200), outlinecolour(140,140,140), trackercolour(yellow), fontcolour(250,250,150)#

image   bounds(  0,  0,135, 85), colour(0,0,0,0), outlinecolour("white"), outlinethickness(2), shape("sharp"), plant("delays"){
rslider bounds(  0,  5, 75, 75), channel("TotDel"), text("Duration"), range(0.01,4,0.4,0.5,0.01), valuetextbox(1), textbox(1), $RSliderStyle
rslider bounds( 60,  5, 75, 75), channel("TotNum"), text("N.Taps"),   range(1,300,100,1,1), valuetextbox(1), textbox(1), $RSliderStyle
}

image   bounds(133,  0,194, 85), colour(0,0,0,0), outlinecolour("white"), outlinethickness(2), shape("sharp"), plant("scatter"){
rslider bounds(  0,  5, 75, 75), channel("ScatAmp"),text("Scat.Amp."), range(0,1,0.5),  valuetextbox(1), textbox(1), $RSliderStyle
rslider bounds( 60,  5, 75, 75), channel("Shape"),text("Shape"), range(-20,20,0,1,0.1), valuetextbox(1), textbox(1), $RSliderStyle
rslider bounds(120,  5, 75, 75), channel("ScatTim"),text("Scat.Tim."), range(0,1,0.5),  valuetextbox(1), textbox(1), $RSliderStyle
}

image    bounds(325,  0,112, 85), colour(0,0,0,0), outlinecolour("white"), outlinethickness(2), shape("sharp"), plant("InputOutputMode"){
label    bounds(  8,  8, 95, 12), text("Input/Output"), fontcolour(200,250,200)
combobox bounds(  8, 21, 95, 20), channel("InOutMode"), text("Mono","Stereo Match","Stereo Diff."), value(3), fontcolour(250,250,150)
checkbox bounds(  8, 50, 95, 12), channel("DelayDry"), text("Delay Dry"), value(0), fontcolour(250,250,150), colour("yellow")
}

image    bounds(435,  0,282, 85), colour(0,0,0,0), outlinecolour("white"), outlinethickness(2), shape("sharp"), plant("Filter"){
label    bounds(  8,  8, 85, 12), text("Filter"), fontcolour(200,250,200)
combobox bounds(  8, 21, 85, 20), channel("FiltSelect"), text("Bypass","Lowpass","Bandpass"), value(1), fontcolour(250,250,150)
rslider bounds( 90,  5, 75, 75), channel("FiltMin"),    text("Min."),      range(4,13.5,4,1,0.1),    valuetextbox(1), textbox(1), $RSliderStyle
rslider bounds(150,  5, 75, 75), channel("FiltMax"),    text("Max."),      range(4,13.5,13.5,1,0.1), valuetextbox(1), textbox(1), $RSliderStyle
rslider bounds(210,  5, 75, 75), channel("Q"),          text("Q."),        range(0,1,0.1),           valuetextbox(1), textbox(1), $RSliderStyle
}

image   bounds(715,  0,135, 85), colour(0,0,0,0), outlinecolour("white"), outlinethickness(2), shape("sharp"), plant("mixer"){
rslider bounds(  0,  5, 75, 75), channel("Mix"),    text("Mix"),      range(0,1.00,0.5), valuetextbox(1), textbox(1), $RSliderStyle
rslider bounds( 60,  5, 75, 75), channel("Level"),  text("Level"),    range(0,1,0.7),    valuetextbox(1), textbox(1), $RSliderStyle
}

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1
		seed	0
		
; RANDOM DISTRIBUTION - UNIFORM VALUES 0 TO 1
giRnd	ftgen	0, 0, 4096, 21, 1, 1

; UDO
opcode	Taps,a,iiiiiikkkko
 iInOutMode,iTotDel,iScatAmp,iShape,iScatTim,iTotNum,kFiltSelect,kFiltMin,kFiltMax,kQ,iCount	xin
 aMix,aOut	init	0								; INITIALISE THIS TAP AND MIX OF ALL OTHER TAPS
 if iInOutMode==2 then									; IF STEREO MATCHED INPUT/OUTPUT MODE
  iRndDel	table	iCount,giRnd							; READ A RANDOM DELAY OFFSET VALUE FROM RANDOM DISTRIBUTION TABLE (FIXED LAYER BY LAYER) 
  iRndDel	=	((iRndDel*2)-1) * ((iTotDel*iScatTim)/iTotNum)			; RESCALE DELAY OFFSET VALUE
  iRndAmp	table	iCount+1000,giRnd						; READ RANDOM AMPLITUDE VALUE FROM TABLE
  iRndAmp	=	1 - (iRndAmp * iScatAmp)					; RESCALE RANDOM AMPLITUDE VALUE
 else											; OTHERWISE (RANDOM DIFF. OR MONO MODE SELECTED) 
  iRndAmp	random	(1-iScatAmp),1 							; CREATE A RANDOM AMPLITUDE VALUE
  iRndDel	random	-(iTotDel*iScatTim)/iTotNum, (iTotDel*iScatTim)/iTotNum		; CREATE A RANDOM DELAY TAP OFFSET VALUE
 endif 
 iDel		limit	((iTotDel/iTotNum)*iCount)+iRndDel,0.001,iTotDel		; LIMIT DELAY TIMES SO THAT IT WON'T EXCEED BUFFER SIZE OR BE ZERO OR LESS
 aOut		deltapi	iDel								; CREATE DELAY TAP

 /* FILTER */
 iRndCFOct	random	i(kFiltMin),i(kFiltMax)
 iCF		=	cpsoct(iRndCFOct)
 if kFiltSelect==2 then
  aOut		moogvcf2	aOut,iCF,kQ*0.9
 elseif kFiltSelect==3 then
  aOut		butbp	aOut,iCF,(((1-kQ)*2) + 0.05)*iCF, 1
 endif

 if iShape!=0 then									; IF 'SHAPE' VALUE IS NOT ZERO
  if iShape>0 then									; IF A POSITIVE VALUE... (BUILD SHAPE)
   aOut	*=	(iCount/iTotNum)^iShape							; AMPLITUDE SCALED ACCORDING TO TAP NUMBER
  else											; OTHERWISE... (DECAY SHAPE)
   aOut	*=	((iTotNum-iCount)/iTotNum)^abs(iShape)  				; AMPLITUDE SCALED ACCORDING TO TAP NUMBER (REVERSED)
  endif
 endif
 if iCount<iTotNum then									; IF NUMBER OF REQUIRED TAPS IS NOT YET COMPLETED...
  aMix		Taps	iInOutMode,iTotDel,iScatAmp,iShape,iScatTim,iTotNum,kFiltSelect,kFiltMin,kFiltMax,kQ,iCount+1	; CALL FURTHER LAYER(S) FOR ADDITIONAL TAPS AS REQUIRED (INCREMENT COUNTER)
 endif
 		xout	(aOut*(iRndAmp^2))+aMix						; ADD THIS TAP (AND APPLY RANDOM AMPLITUDE FOR THIS TAP) WITH ALL SUBSEQUENT TAPS
endop

instr	1
 kInOutMode	chnget	"InOutMode"							; READ IN WIDGETS
 kInOutMode	init	1								; INIT (TO PREVENT) A ZERO AT I-TIME
 kTotNum	chnget	"TotNum"
 kTotNum	init	100
 kTotDel	chnget	"TotDel"
 kTotDel	init	0.4
 kMix		chnget	"Mix"
 kLevel		chnget	"Level"                                                                       
 kScatAmp	chnget	"ScatAmp"
 kShape		chnget	"Shape"
 kScatTim	chnget	"ScatTim"
 kDelayDry	chnget	"DelayDry"
 kFiltSelect	chnget	"FiltSelect"
 kFiltMin	chnget	"FiltMin"		
 kFiltMax	chnget	"FiltMax"
 kQ		chnget	"Q"
 		
 aL,aR		ins									; READ IN STEREO INPUT 

 if changed(kInOutMode,kTotNum,kTotDel,kScatAmp,kShape,kScatTim,kDelayDry,kFiltMin,kFiltMax)==1 then		; FORCE A REINITIALISATION IF ANY OF THE LISTED K-VARIABLES CHANGE
  		reinit	RESTART
 endif
 RESTART:

 if i(kInOutMode)==1 then									; IF MONO MODE IS SELECTED CREATE JUST A SINGLE CHANNEL AND SEND IT TO BOTH OUTPUTS
  aBuf		delayr	i(kTotDel) 								; SET UP BUFFER
  aDelL		Taps	i(kInOutMode),i(kTotDel),i(kScatAmp),i(kShape),i(kScatTim),i(kTotNum),kFiltSelect,kFiltMin,kFiltMax,kQ	; CALL UDO
 		delayw	aL									; WRITE INTO BUFFER
  if i(kDelayDry)==1 then
   aL	delay	aL,i(kTotDel)
  endif
  aMix		ntrpol	aL,aDelL,kMix								; MIX DRY AND WET SIGNALS
 	outs	aMix*kLevel, aMix*kLevel							; SEND SAME SIGNAL TO BOTH CHANNELS
 else												; OTHERWISE (EITHER OF THE STEREO MODES HAS BEEN SELECTED)
  aBuf		delayr	i(kTotDel) 								; LEFT CHANNEL...
  aDelL		Taps	i(kInOutMode),i(kTotDel),i(kScatAmp),i(kShape),i(kScatTim),i(kTotNum),kFiltSelect,kFiltMin,kFiltMax,kQ	;
 		delayw	aL									;
  aBuf		delayr	i(kTotDel) 								; RIGHT CHANNEL...
  aDelR		Taps	i(kInOutMode),i(kTotDel),i(kScatAmp),i(kShape),i(kScatTim),i(kTotNum),kFiltSelect,kFiltMin,kFiltMax,kQ	;
 		delayw	aR									;
  if i(kDelayDry)==1 then
   aL	delay	aL,i(kTotDel)
   aR	delay	aR,i(kTotDel)
  endif
  aMixL		ntrpol	aL,aDelL,kMix								; MIX DRY AND WET SIGNALS FOR BOTH CHANNELS SEPARATELY
  aMixR		ntrpol	aR,aDelR,kMix								;
 	outs	aMixL*kLevel, aMixR*kLevel							; STEREO OUTPUT
 endif
 
endin

</CsInstruments>

<CsScore>
i 1 0 3600
</CsScore>

</CsoundSynthesizer>
; MultiReverb.csd
; Written by Iain McCurdy, 2012

; Reverb effect that employs screverb and freeverb opcodes.
; Pitch Mod. is only used by reverbsc.

<Cabbage>
form caption("Multi Reverb") size(415, 90), pluginid("Rvrb") style("legacy")
image  bounds(  7, 22, 73, 45), colour( 39, 31, 20), shape("rounded"), outlinecolour(white), outlinethickness(1) 
image  bounds(  0,  0,415, 90), colour( 39, 31, 20), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
button bounds( 11, 20, 66, 20), text("screverb","screverb"), channel("scType"),   value(1), fontcolour:0(50,50,50), fontcolour:1("lime"), radiogroup(1)
button bounds( 11, 40, 66, 20), text("freeverb","freeverb"), channel("freeType"), value(0), fontcolour:0(50,50,50), fontcolour:1("lime"), radiogroup(1)
rslider bounds( 80, 11, 70, 70), text("Size"), 		textcolour(white), 		channel("fblvl"), 	range(0, 1.00, 0.8), colour( 79, 81, 70), trackercolour(240,210,170)
rslider bounds(145, 11, 70, 70), text("Damping"), 	textcolour(white), 		channel("fco"), 	range(0, 1.00, 0.6), colour( 79, 81, 70), trackercolour(240,210,170)
rslider bounds(210, 11, 70, 70), text("Pitch Mod."), 	textcolour(white), 		channel("pitchm"), 	range(0, 20.0, 1),   colour( 79, 81, 70), trackercolour(240,210,170), identchannel("pitchmID")
rslider bounds(275, 11, 70, 70), text("Mix"), 		textcolour(white), 		channel("mix"), 	range(0, 1.00, 1),   colour( 79, 81, 70), trackercolour(240,210,170)
rslider bounds(340, 11, 70, 70), text("Level"),	 	textcolour(white), 		channel("amp"), 	range(0, 1.00, 1),   colour( 79, 81, 70), trackercolour(240,210,170)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 	= 	44100	;SAMPLE RATE
ksmps 	= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 	= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs	=	1

; Author: Iain McCurdy (2012)

instr	1
	kscType		chnget	"scType"
	kfreeType	chnget	"freeType"
	ktype		=	(kscType==1?0:1)
	kfblvl		chnget	"fblvl"
	kfco		chnget	"fco"
	kpitchm		chnget	"pitchm"
	kmix		chnget	"mix"
	kamp		chnget	"amp"

	
	if changed(ktype)==1||timeinstk()==1 then
	 Smsg	sprintfk	"visible(%d)",1-ktype
	 chnset	Smsg,"pitchmID"
	endif

	ainL,ainR	ins
	denorm		ainL, ainR	;DENORMALIZE BOTH CHANNELS OF AUDIO SIGNAL
	if ktype==0 then
	 kfco	expcurve	kfco, 4	;CREATE A MAPPING CURVE TO GIVE A NON LINEAR RESPONSE
	 kfco	scale	kfco,20000,20	;RESCALE 0 - 1 TO 20 TO 20000
	 kSwitch		changed		kpitchm	;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
	 if	kSwitch=1	then	;IF kSwitch=1 THEN
		reinit	UPDATE		;BEGIN A REINITIALIZATION PASS FROM LABEL 'UPDATE'
	 endif				;END OF CONDITIONAL BRANCHING
	 UPDATE:				;A LABEL
	 arvbL, arvbR 	reverbsc 	ainL, ainR, kfblvl, kfco, sr, i(kpitchm)
	 rireturn			;RETURN TO PERFORMANCE TIME PASSES
	else
	 arvbL, arvbR 	freeverb 	ainL, ainR, kfblvl, 1-kfco
	endif
	amixL		ntrpol		ainL, arvbL, kmix	;CREATE A DRY/WET MIX BETWEEN THE DRY AND THE REVERBERATED SIGNAL
	amixR		ntrpol		ainR, arvbR, kmix	;CREATE A DRY/WET MIX BETWEEN THE DRY AND THE REVERBERATED SIGNAL
			outs		amixL * kamp, amixR * kamp
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; BufferFreeze.csd
; Written by Iain McCurdy, 2014, updated 2016

<Cabbage>
form caption("Buffer Freeze"), size(610, 250), pluginid("BfFr"), colour(50,50,75) style("legacy")
gentable      bounds(  5,  5,600,120), tablenumber(1), tablecolour("LightBlue"), amprange(-1,1,1), identchannel(table), zoom(-1)

hslider    bounds(  0,120, 610, 25), channel("ptr"),    range(0, 1.00, 1), trackercolour("LightBlue")
label      bounds(205,143,200,  12), text("Pointer"), fontcolour("white")

checkbox bounds( 15,180, 80, 30), channel("freeze"), text("Freeze"), fontcolour("white"), colour("LightBlue")

rslider    bounds(100,170, 70, 70), channel("InGain"), text("Input Gain"), textcolour("white"), range(0, 8.00, 1,0.5), trackercolour("LightBlue")
rslider    bounds(170,170, 70, 70), channel("DryGain"), text("Dry Gain"), textcolour("white"), range(0, 8.00, 1,0.5), trackercolour("LightBlue")
rslider    bounds(240,170, 70, 70), channel("FreezeGain"), text("Freeze Gain"), textcolour("white"), range(0, 8.00, 1), trackercolour("LightBlue")

label      bounds(325,175, 60,13), text("FFT Size"), fontcolour("white")
combobox   bounds(325,190, 60,20), text("128","256","512","1024","2048","4096","8192"), channel("FFTSize"), value(4), fontcolour(255,255,255)

rslider    bounds(395,170, 70, 70), channel("PtrRand"), text("Ptr.Rand."), textcolour("white"), range(0, 1.00, 0), trackercolour("LightBlue")
rslider    bounds(465,170, 70, 70), channel("Transpose"), text("Transpose"), textcolour("white"), range(-24, 24.00, 0), trackercolour("LightBlue")
rslider    bounds(535,170, 70, 70), channel("TransRand"), text("Trans.Rand."), textcolour("white"), range(0, 24.00, 0), trackercolour("LightBlue")

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	16	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS
0dbfs		=	1	; MAXIMUM AMPLITUDE
			 
giDispBuffer	ftgen	1,0, -600,-2, 0	; define live audio buffer table for display. It makes sense if this corresponds to the display size in pixels.
giAudBuffer	ftgen	2,0, 2^18,10, 0	; define live audio buffer table

instr	1
	aL,aR	ins
	kfreeze	chnget	"freeze"

	koffset	init	0	
	kInGain	chnget	"InGain"
	aL	*=	kInGain
	aR	*=	kInGain
	kDryGain	chnget	"DryGain"
	kFreezeGain	chnget	"FreezeGain"
		
	if kfreeze==0 then							; if writing to table mode...

	 ; write audio to table
	 aptr	phasor	sr/ftlen(giAudBuffer)				
		tablew	aL,aptr,giAudBuffer,1

	koffset			downsamp	aptr				; amount of offset added to freeze read pointer (NB. audio buffer does not scroll)
	
	if metro(sr*ftlen(giDispBuffer)/ftlen(giAudBuffer))==1 then		; update according to size of display table and size of audio buffer	 
	 	tablew	k(aL),ftlen(giDispBuffer),giDispBuffer			; write current audio sample value (as a downsampled krate value) to table
	 	
	 ; SHUNT ENTIRE TABLE CONTENTS ONE STEP TO THE RIGHT
	 kcount	=	0
	 loop:
	 kval	table	kcount+1,giDispBuffer
	 	tablew	kval,kcount,giDispBuffer
	 loop_lt	kcount,1,ftlen(giDispBuffer),loop	

       	 chnset	"tablenumber(1)", "table"					; update table display	

	endif
	 		outs	aL*kDryGain,aR*kDryGain
	 
	else									; otherwise freeze/read mode
	
	 kptr	chnget	"ptr"
	 kporttime linseg 0,0.001,0.01
	 kptr portk kptr, kporttime
	 kPtrRand	gauss	chnget:k("PtrRand")
	 kptr	wrap	kptr+koffset+kPtrRand,0,1
	 kFFTSize	chnget	"FFTSize"
	 kFFTSize	init	4
	 kPitch	=	semitone( chnget:k("Transpose") + gauss:k(chnget:k("TransRand")) )
	 if changed(kFFTSize)==1 then
	  reinit UPDATE
	 endif
	 UPDATE:
	 iFFTSize	=	2^(i(kFFTSize)+6)
	 asig 	mincer 	a(kptr*(ftlen(giAudBuffer)/sr)), kFreezeGain, kPitch, giAudBuffer, 0, iFFTSize
	 rireturn 
		outs	asig,asig

	endif

endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; FrequencyShifter.csd
; Iain McCurdy, 2013.
; 
; Frequency shifting using the hilbert filter
; 
; CONTROLS
; --------
; Input			--	Choose audio input: Live, sine tone or pink noise
; Polarity		--	3 options: 'Positive' = multiply 'Freq.' by 1, 'Negative' = multiply 'Freq.' by -1, 'Dual' = sum of 'Positive' and 'Negative' outputs
; Mix			--	Dry/Wet mix control
; Freq.			--	Principle frequency of the shifting frequency (before modulation by other controls)
; Mult.			--	multipler of shifting frequency. Can be useful for finer control of shifting frequency around zero.
; Feedback		--	Amount of frequency shifter that is fed back into its input
; Level			--	Output level
; Dual Mono / Stereo	--	'Dual Mono' = both channels treated in the same way. 'Stereo' = right channel 180 degrees out of phase with respect to the left
;				 Stereo mode most apparent if shifting frequency is close to zero
; zero freq		--	set 'Freq.' to zero
;  [LFO~]
; Modulate Frequency	--	Switch to activate LFO modulation  of shifting frequency
; Shape			--	Shape of the LFO: sine / triangle / square / random sample and hold / random splines
; Rate			--	Rate of LFO (in hertz)
; Min			--	Minimum frequency of the LFO modulation
; Max			--	Maximum frequency of the LFO modulation
; Pan Mod			--	Amount of panning modulation (strictly speaking, stereo balance modulation). Rate of modulation governed also by 'Rate'
; Sync LFO		--	Restart LFO. Can be useful if 'random spline' modulation becomes 'stuck' at a low frequency

<Cabbage>
form caption("Frequency Shifter") size(560,180), pluginid("fshi") style("legacy")
image                   bounds( 0,  0, 560,180), colour("darkslategrey"), outlinecolour("silver"), outlinethickness(6), shape("rounded")
label    bounds(15,  7, 70, 11), text("INPUT"), fontcolour("white")
combobox bounds(15, 18, 70, 20), channel("input"), value(1), text("Live","Tone","Noise")
label    bounds(15, 42, 70, 11), text("POLARITY"), fontcolour("white")
combobox bounds(15, 53, 70, 20), channel("polarity"), value(1), text("Positive","Negative","Dual")
rslider bounds( 80, 10, 70, 70), text("Mix"),      channel("mix"),    range(0, 1.00, 0.5),     colour(27,59,59), textcolour("white"), trackercolour(255,255,100)
rslider bounds(150, 10, 70, 70), text("Freq."),    channel("freq"),   range(-4000, 4000, -50), colour(27,59,59), textcolour("white"), trackercolour(255,255,100)
rslider bounds(220, 10, 70, 70), text("Mult."),    channel("mult"),   range(-1, 1.00, 0.1),    colour(27,59,59), textcolour("white"), trackercolour(255,255,100)
rslider bounds(285, 15, 60, 60), text("Port."),    channel("port"),   range(0, 30.00, 0.1),    colour(27,59,59), textcolour("white"), trackercolour(255,255,100)

rslider bounds(340, 10, 70, 70), text("Feedback"), channel("fback"),  range(0, 0.75, 0.6),     colour(27,59,59), textcolour("white"), trackercolour(255,255,100)
rslider bounds(410, 10, 70, 70), text("Level"),    channel("level"),  range(0, 1.00, 1),       colour(27,59,59), textcolour("white"), trackercolour(255,255,100)

checkbox bounds(480, 20, 12, 12), channel("r1") fontcolour("white") colour(yellow) value(1)
checkbox bounds(480, 32, 12, 12), channel("r2") fontcolour("white") colour(yellow) 
label    bounds(493, 21, 55,  9), text("DUAL MONO"), fontcolour("white")
label    bounds(492, 33, 40,  9), text("STEREO"), fontcolour("white")

button   bounds(480, 50, 65, 20), colour("Green"), text("Zero Freq", "Zero Freq"), channel("Zerofreq"), value(0), latched(0)

;----

line     bounds( 10, 90, 540, 2), colour("Grey")

;----

checkbox bounds( 40,100,150, 20), channel("ModOnOff") text("LFO Modulate Freq."), fontcolour("white") colour(lime) value(0)
label    bounds( 53,127, 45, 11), text("SHAPE"), fontcolour("white")
combobox bounds( 40,138, 85, 20), channel("LFOShape"), value(7), text("Sine","Triangle","Square","Saw Up","Saw Down","Rand.S&H","Rand.Spline")
rslider bounds( 175,100, 70, 70), text("Rate"),     channel("LFORate"),  range(0, 30,  1.5, 0.5, 0.001), colour("lightslategrey"), textcolour("white"), trackercolour(255,255,100)
rslider bounds( 245,100, 70, 70), text("Min"),      channel("LFOMin"),   range(-2000, 2000, -600),       colour("lightslategrey"), textcolour("white"), trackercolour(255,255,100)
rslider bounds( 315,100, 70, 70), text("Max"),      channel("LFOMax"),   range(-2000, 2000,  600),       colour("lightslategrey"), textcolour("white"), trackercolour(255,255,100)
rslider bounds( 385,100, 70, 70), text("Pan Mod."), channel("PanSpread"),range(0, 1.00, 1),              colour("lightslategrey"), textcolour("white"), trackercolour(255,255,100)
button   bounds(455,100, 65, 20), colour("Green"), text("Sync LFO", "Sync LFO"), channel("SyncLFO"), value(0), latched(0)

</Cabbage>
<CsoundSynthesizer>

<CsOptions>
-d -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>
sr 	= 	48000
ksmps 	= 	32
nchnls 	= 	2
0dbfs 	= 	1

;Iain McCurdy, 2012
;http://iainmccurdy.org/csound.html
;Frequency shifter effect based around the hilbert filter.

gisine		ftgen	0,0,4096,10,1			;A SINE WAVE SHAPE
gicos		ftgen	0,0,4096,11,1			;A COSINE WAVE SHAPE
gishapes	ftgen	0,0,8,-2,0,1,2,4,5

opcode	FreqShifter,a,akkki
	adry,kmix,kfshift,kfback,ifn	xin			;READ IN INPUT ARGUMENTS
	kWet	limit	kmix*2,0,1
	kDry	limit	(1-kmix)*2,0,1
	aFS	init	0					;INITILISE FEEDBACK SIGNAL (FOR FIRST K-PASS)
	ain	=	adry + (aFS * kfback)			;ADD FEEDBACK SIGNAL TO INPUT (AMOUNT OF FEEDBACK CONTROLLED BY 'Feedback Gain' SLIDER)
	areal, aimag hilbert ain				;HILBERT OPCODE OUTPUTS TWO PHASE SHIFTED SIGNALS, EACH 90 OUT OF PHASE WITH EACH OTHER
	;QUADRATURE OSCILLATORS. I.E. 90 OUT OF PHASE WITH RESPECT TO EACH OTHER
	;OUTUTS	OPCODE	AMPLITUDE | FREQ. | FUNCTION_TABLE | INITIAL_PHASE (OPTIONAL;DEFAULTS TO ZERO)
	asin 	oscili       1,    kfshift,     ifn,           0
	acos 	oscili       1,    kfshift,     ifn,           0.25	
	;RING MODULATE EACH SIGNAL USING THE QUADRATURE OSCILLATORS AS MODULATORS
	amod1	=		areal * acos
	amod2	=		aimag * asin	
	;UPSHIFTING OUTPUT
	aFS	= (amod1 - amod2)
	aout	sum	aFS*kWet, adry*kDry		;CREATE WET/DRY MIX
		xout	aout				;SEND AUDIO BACK TO CALLER INSTRUMENT
endop


opcode	CabbageRadio2,k,SS			; change opcode name and number is string variable inputs
S1,S2	xin					; add string inputs for the required number of inputs 
kon		=	0
koff		=	0
ksum		=	0
ktrigsum	=	0
#define READ_CHANGES(NAME)	#
k$NAME	chnget	$NAME
ksum	=	ksum + k$NAME
kon$NAME	trigger	k$NAME,0.5,0
ktrigsum	=	ktrigsum + kon$NAME#

#define WRITE_CHANGES(NAME'COUNT)	#
if kon$NAME!=1 then
 chnset	koff,$NAME
else
 kval	=	$COUNT
endif#

 $READ_CHANGES(S1) 
 $READ_CHANGES(S2)				; add macro expansions for the required number of radio buttons

if ktrigsum>0 then

 $WRITE_CHANGES(S1'1)
 $WRITE_CHANGES(S2'2)				; add macro expansions for the required number of radio buttons

endif

kval	=	(ksum=0?0:kval)
	xout	kval
endop


instr	1
kporttime	linseg	0,0.001,1
koff	=	0
kmix		chnget	"mix"			; read input widgets
kfreq		chnget	"freq"
kmult		chnget	"mult"
kport		chnget	"port"
kfshift		portk	kfreq*kmult,kporttime*kport
kfback		chnget	"fback"
klevel		chnget	"level"
kpolarity	chnget	"polarity"
kStereoMode	CabbageRadio2	"r1","r2"	; call UDO
kZeroFreq	chnget	"Zerofreq"
ktrig changed	kZeroFreq
if ktrig=1 then
 chnset	koff,"freq"
endif
kModOnOff	chnget	"ModOnOff"	
kLFOShape        chnget	"LFOShape"        	
kLFORate         chnget	"LFORate"         	
kLFOMin          chnget	"LFOMin"          	
kLFOMax          chnget	"LFOMax"          	
kPanSpread	chnget	"PanSpread"		
kSyncLFO	chnget	"SyncLFO"


/* INPUT */
kinput		chnget	"input"
if kinput=1 then
 a1,a2	ins
elseif kinput=2 then
 a1	oscils	0.2, 300, 0
 a2	=	a1
else
 a1	pinkish	0.2
 a2	pinkish	0.2
endif



/* LFO */
if kModOnOff=1 then
 ktrig	changed	kLFOShape,kSyncLFO
 if ktrig==1 then
  reinit RESTART_LFO
 endif
 RESTART_LFO:
 if i(kLFOShape)=6 then
  kLFOFreq	randomh	kLFOMin,kLFOMax,kLFORate
 elseif i(kLFOShape)=7 then				; random spline
  ;kLFOFreq	randomi	kLFOMin,kLFOMax,kLFORate,1
  ;kLFOFreq	portk	kLFOFreq,1/kLFORate
  kLFOFreq	rspline	kLFOMin,kLFOMax,kLFORate,kLFORate*2
 else
  ishape	table	i(kLFOShape)-1,gishapes
  kLFOFreq	lfo	1,kLFORate,ishape
  kLFOFreq	scale	(kLFOFreq*0.5)+0.5,kLFOMin,kLFOMax
 endif
 rireturn
endif

 
 
kfshift	=	kfshift+kLFOFreq

/* FREQUENCY SHIFTERS */
ktrig	changed	kStereoMode
if ktrig=1 then
 reinit RESTART_FREQUENCY_SHIFTERS
endif
RESTART_FREQUENCY_SHIFTERS:
if kpolarity=1 then						; polarity is positive...
 a1	FreqShifter	a1,kmix,kfshift,kfback,gisine	
 if i(kStereoMode)=2 then
  a2	FreqShifter	a2,kmix,kfshift,kfback,gicos	; cosine version
 else
  a2	FreqShifter	a2,kmix,kfshift,kfback,gisine	
 endif 
elseif kpolarity=2 then						; polarity is negative...
 a1	FreqShifter	a1,kmix,-kfshift,kfback,gisine	
 if i(kStereoMode)=2 then
  a2	FreqShifter	a2,kmix,-kfshift,kfback,gicos	; cosine version
 else
  a2	FreqShifter	a2,kmix,-kfshift,kfback,gisine	
 endif
else								; polarity is dual...
 aa	FreqShifter	a1,kmix,kfshift,kfback,gisine	; positive
 if i(kStereoMode)=2 then
  ab	FreqShifter	a2,kmix,kfshift,kfback,gicos	; cosine version
 else
  ab	FreqShifter	a2,kmix,kfshift,kfback,gisine	
 endif 
 ac	FreqShifter	a1,kmix,-kfshift,kfback,gisine	; negative
 if i(kStereoMode)=2 then
  ad	FreqShifter	a2,kmix,-kfshift,kfback,gicos	; cosine version
 else
  ad	FreqShifter	a2,kmix,-kfshift,kfback,gisine	
 endif
rireturn

 a1	=		(aa+ac)*0.5				; sum positive and negative and attenuate
 a2	=		(ab+ad)*0.5
endif


/* PANNING */
if kModOnOff=1 then
 kpan	randomi	0.5-(kPanSpread*0.5),0.5+(kPanSpread*0.5),kLFORate,1
 kpan	portk	kpan,1/kLFORate
 a1  =     a1 * sin(kpan*$M_PI_2)
 a2  =     a2 * cos(kpan*$M_PI_2)
 ;a1	=	a1*kpan
 ;a2	=	a2*(1-kpan)
endif



a1	=	a1 * klevel					; scale using level control
a2	=	a2 * klevel
	outs	a1,a2
endin

</CsInstruments>
<CsScore>
i 1 0 [60*60*24*7]
</CsScore>
</CsoundSynthesizer>; PitchShifter.csd
; Written by Iain McCurdy, 2015.

; A pitch shifter using the traditional delay buffer write-read method.
; Two buffers are used per channel (therefore four in total).
; Each overlapping buffer is gated using a hanning window in order to prevent discontinuities
; Snap		-	when activated forces 'Semitones' to an integer.

; Three modes are provided:
; 	Feedback	-	a standard single pitchshifter unit with feedback (2 feedback modes are offered)
;	Interative	-	the user can choose the number of simultaneous pitchshifter units. 
;				Pitchshifting intervals of the various units are related additively, e.g. if semitones=12, the first unit is 12, the second 24, the third 36 etc. (similar to feedback mode)
;	Harmonic	-	Iterative units are harmonically related. E.g. normal harmonic series of intervals is generated if semitones=12. i.e. first interval of the harmonic series is 1 octave

; FB.Method	-	selects from two different feedback methods:
;			  'Indiv.' - each buffer feeds back into itself
;			  'Global' - the gated and mixed buffers from each channel are fed back into both of the buffers for that channel.
; Smooth	-	Basically portamento time governing the filtering of changes made to 'Semitones' and 'Delay'. If zero, portmento filtering is bypassed entirely.  
; Window	-	Selects the window shape used to envelope the overlapping buffers

<Cabbage>
form caption("Pitch Shifter") size(840,  90), pluginid("PShf"), scrollbars(0) style("legacy")

#define RSliderStyle # colour("Grey"), textcolour("white"), outlinecolour("DarkGrey"), trackercolour("Silver")#

label    bounds( 10, 15, 80, 13), fontcolour("white"), text("Interval")
combobox bounds( 10, 30, 80, 20), text("Semitone","Ratio"), channel("IntervalMode"),       value(1)

image     bounds(120, 15, 35, 58), plant("Ratio"), colour(0,0,0,0), visible(0), identchannel("RatioPlant_ident") {
nslider bounds(  5,  0, 25, 18), channel("Numerator"),        range(1,99,3,1,1)
image     bounds(  0, 26, 35,  1), shape("sharp") 
nslider bounds(  5, 35, 25, 18), channel("Denominator"),      range(1,99,2,1,1)
}

image    bounds(110, 10,130, 70), plant("Semitones"), colour(0,0,0,0), visible(1), identchannel("SemitonesPlant_ident") {
rslider  bounds(  0,  0, 70, 70), text("Semitones"),  channel("Semitones"),      range(-48,48,7,1,0.001), $RSliderStyle
checkbox bounds( 70, 20, 60, 15), text("Snap"),       channel("Snap"), value(1), fontcolour("white")
}

label     bounds(240, 15, 80, 13), fontcolour("white"), text("Mode")
combobox  bounds(240, 30, 80, 20), text("Feedback","Iteration","Harmonic"), channel("Mode"),       value(1)
rslider  bounds(330, 10, 70, 70), text("Feedback"),    channel("Feedback"),       range(0,1,0.9,2,0.0001), visible(1), identchannel("Feedback_ident"),  $RSliderStyle
label    bounds(400, 15, 70, 13), text("FB.Method"), fontcolour("White"), visible(1), identchannel("FBLabel_ident"),
combobox bounds(400, 30, 70, 20), text("Indiv.","Global"),       channel("FBMethod"), visible(1), identchannel("FBMethod_ident"),
rslider  bounds(400, 10, 70, 70), text("Iterations"),    channel("NIter"),       range(1,10,3,1,1), identchannel("NIter_ident"), visible(0)        $RSliderStyle

rslider  bounds(470, 10, 70, 70), text("Delay"),       channel("Delay"),          range(0.01,4.00, 0.1,0.5),      $RSliderStyle
rslider  bounds(540, 10, 70, 70), text("Smooth"),      channel("Smooth"),         range(0,99,0,0.5),              $RSliderStyle
label    bounds(610, 15, 80, 13), text("Window"), fontcolour("White")
combobox bounds(610, 30, 80, 20), text("Hanning","Triangle","Half Sine","Square","Pulse","Perc.","Rev.Perc."),  channel("Window")
rslider  bounds(690, 10, 70, 70), text("Mix"),         channel("Mix"),            range(0, 1,0.5),                $RSliderStyle
rslider  bounds(760, 10, 70, 70), text("Level"),       channel("Level"),          range(0, 1.00,1),               $RSliderStyle

</Cabbage>

<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE


giHanning	ftgen	0, 0, 4097,  20, 2
giTriangle	ftgen	0, 0, 4097,  20, 3
giHalfSine	ftgen	0, 0, 4097,   9, 0.5, 1, 0
giSquare	ftgen	0, 0, 4097,   7, 0, 64, 1, 4096-128, 1, 64, 0
giPulse		ftgen	0, 0, 4097,  20, 6, 1, 0.5
giPerc		ftgen	0, 0, 4097,  16, 0, 64, -2, 1,   4096-64, -2, 0
giRevPerc	ftgen	0, 0, 4097,  16, 0, 4096-64, -2, 1, 64, -2, 0



opcode	pitchshifter, aa, aakkkkii	; individual buffer feedback
	ainL,ainR,kratio,kfeedback,kDelay,kSmooth,imaxdelay,iwfn	xin
	setksmps	1

	kPortTime	linseg	0,0.001,1
	;if kSmooth>0 then					; portamento smoothing
	 kratio		portk	kratio, kPortTime*kSmooth	
	 kDelay		portk	kDelay, kPortTime*kSmooth	
	;endif

	aDelay		interp	kDelay

	arate		=	(kratio-1)/kDelay		;SUBTRACT 1/1 SPEED

	aphase1		phasor	-arate				;MOVING PHASE 1-0
	aphase2		phasor	-arate, .5			;MOVING PHASE 1-0 - PHASE OFFSET BY 180 DEGREES (.5 RADIANS)
	
	agate1		tablei	aphase1, iwfn, 1, 0, 1		;
	agate2		tablei	aphase2, iwfn, 1, 0, 1		;
	
	abuf1		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig1	deltap3	aphase1 * aDelay		;VARIABLE TAP
	aGatedSig1	=	adelsig1 * agate1
			delayw	ainL + (aGatedSig1*kfeedback)	;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
	
	abuf2		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig2	deltap3	aphase2 * aDelay		;VARIABLE TAP
	aGatedSig2	=	adelsig2 * agate2
			delayw	ainL + (aGatedSig2*kfeedback)	;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB

	abuf3		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig3	deltap3	aphase1 * aDelay		;VARIABLE TAP
	aGatedSig3	=	adelsig3 * agate1
			delayw	ainR + (aGatedSig3*kfeedback)	;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
	
	abuf4		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig4	deltap3	aphase2 * aDelay		;VARIABLE TAP
	aGatedSig4	=	adelsig4 * agate2
			delayw	ainR + (aGatedSig4*kfeedback)	;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
			
	aGatedMixL	=	(aGatedSig1 + aGatedSig2) * 0.5
	aGatedMixR	=	(aGatedSig3 + aGatedSig4) * 0.5
			xout	aGatedMixL, aGatedMixR
endop


opcode	pitchshifter2, aa, aakkkkii	; global feedback signal
	ainL,ainR,kratio,kfeedback,kDelay,kSmooth,imaxdelay,iwfn	xin
	setksmps	1

	kPortTime	linseg	0,0.001,1
	;if kSmooth>0 then					; portamento smoothing
	 kratio		portk	kratio, kPortTime*kSmooth	
	 kDelay		portk	kDelay, kPortTime*kSmooth	
	;endif

	aDelay		interp	kDelay

	arate		=	(kratio-1)/kDelay		;SUBTRACT 1/1 SPEED
	aphase1		phasor	-arate				;MOVING PHASE 1-0
	aphase2		phasor	-arate, .5			;MOVING PHASE 1-0 - PHASE OFFSET BY 180 DEGREES (.5 RADIANS)
	
	agate1		tablei	aphase1, iwfn, 1, 0, 1		;
	agate2		tablei	aphase2, iwfn, 1, 0, 1		;

	aGatedMixL,aGatedMixR	init	0
	
	abuf1		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig1	deltap3	aphase1 * aDelay		;VARIABLE TAP
	aGatedSig1	=	adelsig1 * agate1
			delayw	ainL + (aGatedMixL*kfeedback)	;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
	
	abuf2		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig2	deltap3	aphase2 * aDelay		;VARIABLE TAP
	aGatedSig2	=	adelsig2 * agate2
			delayw	ainL + (aGatedMixL*kfeedback)	;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB

	abuf3		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig3	deltap3	aphase1 * aDelay		;VARIABLE TAP
	aGatedSig3	=	adelsig3 * agate1
			delayw	ainR + (aGatedMixR*kfeedback)		;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
	
	abuf4		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig4	deltap3	aphase2 * aDelay		;VARIABLE TAP
	aGatedSig4	=	adelsig4 * agate2
			delayw	ainR + (aGatedMixR*kfeedback)		;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
			
	aGatedMixL	=	(aGatedSig1 + aGatedSig2) * 0.5
	aGatedMixR	=	(aGatedSig3 + aGatedSig4) * 0.5
	
			xout	aGatedMixL, aGatedMixR
endop


; ITERATIVE PITCHSHIFTER
opcode	pitchshifter3, aa, aakikkiip	; global feedback signal
	ainL,ainR,kratio,iNIter,kDelay,kSmooth,imaxdelay,iwfn,iCount	xin
	setksmps	1

	kPortTime	linseg	0,0.001,1
	;if kSmooth>0 then					; portamento smoothing
	 kratioL	portk	kratio^iCount, kPortTime*kSmooth	
	 kDelay		portk	kDelay, kPortTime*kSmooth	
	;endif

	aDelay		interp	kDelay

	arate		=	(kratioL-1)/kDelay		;SUBTRACT 1/1 SPEED
	aphase1		phasor	-arate				;MOVING PHASE 1-0
	aphase2		phasor	-arate, .5			;MOVING PHASE 1-0 - PHASE OFFSET BY 180 DEGREES (.5 RADIANS)
	
	agate1		tablei	aphase1, iwfn, 1, 0, 1		;
	agate2		tablei	aphase2, iwfn, 1, 0, 1		;

	aGatedMixL,aGatedMixR	init	0
	
	abuf1		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig1	deltap3	aphase1 * aDelay		;VARIABLE TAP
	aGatedSig1	=	adelsig1 * agate1
			delayw	ainL				;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
	
	abuf2		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig2	deltap3	aphase2 * aDelay		;VARIABLE TAP
	aGatedSig2	=	adelsig2 * agate2
			delayw	ainL				;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB

	abuf3		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig3	deltap3	aphase1 * aDelay		;VARIABLE TAP
	aGatedSig3	=	adelsig3 * agate1
			delayw	ainR				;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
	
	abuf4		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig4	deltap3	aphase2 * aDelay		;VARIABLE TAP
	aGatedSig4	=	adelsig4 * agate2
			delayw	ainR				;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
			
	aGatedMixL	=	(aGatedSig1 + aGatedSig2) * 0.5
	aGatedMixR	=	(aGatedSig3 + aGatedSig4) * 0.5
	
	aMixL,aMixR	init	0
	if iCount<iNIter then
	 aMixL,aMixR	pitchshifter3	ainL,ainR,kratio,iNIter,kDelay,kSmooth,imaxdelay,iwfn,iCount+1
	endif
	
			xout	aGatedMixL + aMixL, aGatedMixR + aMixR
endop


; HARMONIC ITERATIVE
opcode	pitchshifter4, aa, aakikkiip	; global feedback signal
	ainL,ainR,kratio,iNIter,kDelay,kSmooth,imaxdelay,iwfn,iCount	xin
	setksmps	1

	kratio	=	kratio * (iCount+1)/iCount
	iratio	=	i(kratio) * (iCount+1)/iCount

	kPortTime	linseg	0,0.001,1
	if kSmooth>0 then					; portamento smoothing
	 kratio		portk	kratio, kPortTime*kSmooth	
	 kDelay		portk	kDelay, kPortTime*kSmooth	
	endif

	aDelay		interp	kDelay
	;koctfract	=	kSemitones/12			;TRANSPOSITION AS FRACTION OF AN OCTAVE
	;kratio		=	cpsoct(8+koctfract)/cpsoct(8)	;RATIO OF NEW FREQ TO A DECLARED BASE FREQUENCY (MIDDLE C)

	arate		=	(kratio-1)/kDelay		;SUBTRACT 1/1 SPEED
	aphase1		phasor	-arate				;MOVING PHASE 1-0
	aphase2		phasor	-arate, .5			;MOVING PHASE 1-0 - PHASE OFFSET BY 180 DEGREES (.5 RADIANS)
	
	agate1		tablei	aphase1, iwfn, 1, 0, 1		;
	agate2		tablei	aphase2, iwfn, 1, 0, 1		;

	aGatedMixL,aGatedMixR	init	0
	
	abuf1		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig1	deltap3	aphase1 * aDelay		;VARIABLE TAP
	aGatedSig1	=	adelsig1 * agate1
			delayw	ainL				;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
	
	abuf2		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig2	deltap3	aphase2 * aDelay		;VARIABLE TAP
	aGatedSig2	=	adelsig2 * agate2
			delayw	ainL				;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB

	abuf3		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig3	deltap3	aphase1 * aDelay		;VARIABLE TAP
	aGatedSig3	=	adelsig3 * agate1
			delayw	ainR				;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
	
	abuf4		delayr	imaxdelay			;DECLARE DELAY BUFFER
	adelsig4	deltap3	aphase2 * aDelay		;VARIABLE TAP
	aGatedSig4	=	adelsig4 * agate2
			delayw	ainR				;WRITE AUDIO TO THE BEGINNING OF THE DELAY BUFFER, MIX IN FEEDBACK SIGNAL - PROPORTION DEFINED BY gkFB
			
	aGatedMixL	=	(aGatedSig1 + aGatedSig2) * 0.5
	aGatedMixR	=	(aGatedSig3 + aGatedSig4) * 0.5
	
	aMixL,aMixR	init	0
	if iCount<iNIter then
	 aMixL,aMixR	pitchshifter4	ainL,ainR,kratio,iNIter,kDelay,kSmooth,imaxdelay,iwfn,iCount+1
	endif
	
			xout	aGatedMixL + aMixL, aGatedMixR + aMixR
endop


instr	1
	aInL,aInR	ins
	;aInL		vco2	0.2,100,4,0.5
	;aInR		=	aInL
	
	kFeedback	chnget	"Feedback"
	kNIter		chnget	"NIter"
	kNIter		init	1
	kDelay		chnget	"Delay"
	kSmooth		chnget	"Smooth"
	kMode		chnget	"Mode"
	kIntervalMode	chnget	"IntervalMode"
	
	if changed(kIntervalMode)==1 then				; semitones mode
	 if kIntervalMode==1 then
	 	chnset	"visible(0)","RatioPlant_ident"
	 	chnset	"visible(1)","SemitonesPlant_ident"
	 else								; ratio mode
	 	chnset	"visible(1)","RatioPlant_ident"
	 	chnset	"visible(0)","SemitonesPlant_ident"
	 endif
	endif
	
	if kIntervalMode==1 then
		kSemitones	chnget	"Semitones"
		kSnap		chnget	"Snap"
		if kSnap==1 then
		 if frac(kSemitones)!=0 then
		  kSemitones	=	round(kSemitones)
		  		chnset	kSemitones,"Semitones"
		 endif
		endif
	 	kRatio	=	semitone(kSemitones)	
	else
		kNumerator	chnget	"Numerator"
		kDenominator	chnget	"Denominator"
		kRatio		=	kNumerator/kDenominator
		kSemitones	=	log2(kRatio)*12	
	endif
	
	if changed(kMode)==1 then
	 if kMode==1 then
	  chnset	"visible(1)","Feedback_ident"
	  chnset	"visible(1)","FBLabel_ident"
	  chnset	"visible(1)","FBMethod_ident"
	  chnset	"visible(0)","NIter_ident"
	 elseif kMode==2 then
	  chnset	"visible(0)","Feedback_ident"
	  chnset	"visible(0)","FBLabel_ident"
	  chnset	"visible(0)","FBMethod_ident"
	  chnset	"visible(1)","NIter_ident"
	 else
	  chnset	"visible(0)","Feedback_ident"
	  chnset	"visible(0)","FBLabel_ident"
	  chnset	"visible(0)","FBMethod_ident"
	  chnset	"visible(1)","NIter_ident"
	 endif
	endif
	
	
	iMaxDelay	=	4
	kWindow		chnget	"Window"
	kWindow		init	1
	if changed(kWindow)==1 then
	 reinit UPDATE
	endif
	UPDATE:
	iWfn	=	giHanning + i(kWindow) - 1

	if kMode==1 then
	 kFBMethod	chnget	"FBMethod"
	 kFBMethod	init	1
	 if kFBMethod==1 then
	  aPS_L,aPS_R	pitchshifter	aInL,aInR,kRatio,kFeedback,kDelay,kSmooth,iMaxDelay,iWfn
	 elseif kFBMethod==2 then
	  aPS_L,aPS_R	pitchshifter2	aInL,aInR,kRatio,kFeedback,kDelay,kSmooth,iMaxDelay,iWfn	
	 endif
	elseif kMode==2 then
	 if changed(kNIter)==1 then
	  reinit UPDATE3
	 endif
	 UPDATE3:
	 aPS_L,aPS_R	pitchshifter3	aInL,aInR,kRatio,i(kNIter),kDelay,kSmooth,iMaxDelay,iWfn	
	elseif kMode==3 then		; HARMONIC ITERATIVE
	 if changed(kNIter)==1 then
	  reinit UPDATE4
	 endif
	 ;aFBL,aFBR	init	0
	 UPDATE4:
	 ;aPS_L,aPS_R	pitchshifter4	aInL+aFBL,aInR+aFBL,semitone(kSemitones-12),i(kNIter),kDelay,kSmooth,iMaxDelay,iWfn	
	 aPS_L,aPS_R	pitchshifter4	aInL,aInR,semitone(kSemitones-12),i(kNIter),kDelay,kSmooth,iMaxDelay,iWfn	
	 ;aFBL	=	aPS_L*kFeedback
	 ;aFBR	=	aPS_R*kFeedback
	endif

	rireturn
	kMix		chnget	"Mix"
	aMixL		ntrpol	aInL,aPS_L,kMix
	aMixR		ntrpol	aInR,aPS_R,kMix
	kLevel		chnget	"Level"
			outs	aMixL*kLevel, aMixR*kLevel
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pvsAdsyn.csd
; Written by Iain McCurdy, 2012.

; Encapsulation of the pvsadsyn opcode.
; This opcode takes a streaming phase vocoding analysis and reconstitutes it as an audio signal with user-definable parameters
;  for the number of bins to include, the bin from which to begin resynthesis (bin offset) and the option of skipping bins and not
;  resynthesising them one after another (Bin Incr.)

<Cabbage>
form caption("pvsAdsyn") size(580, 90), pluginid("adsy") style("legacy")
image pos(0, 0), size(580, 90), colour(200,100,50,150), shape("rounded"), outlinecolour("white"), outlinethickness(5) 
rslider bounds(10, 11, 70, 70),  text("Freq.Mod."),  channel("fmod"),      range(0.25, 4, 1),        textcolour("white"), colour(200,100,50,250), trackercolour(tan)
rslider bounds(80, 11, 70, 70),  text("Num.Osc.s"),  channel("noscs"),     range(1, 1024, 256,1,1),  textcolour("white"), colour(200,100,50,250), trackercolour(tan)
rslider bounds(150, 11, 70, 70), text("Bin Offset"), channel("binoffset"), range(0, 256, 1,1,1),     textcolour("white"), colour(200,100,50,250), trackercolour(tan)
rslider bounds(220, 11, 70, 70), text("Bin Incr."),  channel("binincr"),   range(1, 32, 1,1,1),      textcolour("white"), colour(200,100,50,250), trackercolour(tan)
label    bounds(295,20, 60,13), text("FFT Size"), fontcolour("white")
combobox bounds(295,35, 60,18), text("64","128","256","512","1024","2048","4096","8192"), channel("att_table"), value(5), fontcolour(255,255,200)
rslider bounds(360, 11, 70, 70), text("Feedback"),   channel("feedback"),  range(0, 0.99, 0),        textcolour("white"), colour(200,100,50,250), trackercolour(tan)
rslider bounds(430, 11, 70, 70), text("Mix"),        channel("mix"),       range(0, 1.00, 1),        textcolour("white"), colour(200,100,50,250), trackercolour(tan)
rslider bounds(500, 11, 70, 70), text("Level"),      channel("lev"),       range(0, 5.00, 0.5, 0.5), textcolour("white"), colour(200,100,50,250), trackercolour(tan)
</Cabbage>

<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

;Author: Iain McCurdy (2012)
;http://iainmccurdy.org/csound.html

/* FFT attribute tables */
giFFTattributes1	ftgen	0, 0, 4, -2,   64,  32,   64, 1
giFFTattributes2	ftgen	0, 0, 4, -2,  128,  64,  128, 1
giFFTattributes3	ftgen	0, 0, 4, -2,  256, 128,  256, 1
giFFTattributes4	ftgen	0, 0, 4, -2,  512, 128,  512, 1
giFFTattributes5	ftgen	0, 0, 4, -2, 1024, 256, 1024, 1
giFFTattributes6	ftgen	0, 0, 4, -2, 2048, 512, 2048, 1
giFFTattributes7	ftgen	0, 0, 4, -2, 4096,1024, 4096, 1
giFFTattributes8	ftgen	0, 0, 4, -2, 8192,2048, 8192, 1

opcode	pvsadsyn_module,a,akkkkkkiiii
	ain,kfmod,knoscs,kbinoffset,kbinincr,kfeedback,kmix,iFFTsize,ioverlap,iwinsize,iwintype	xin
	aresyn	init	0
	f_anal  	pvsanal	ain+(aresyn*kfeedback), iFFTsize, ioverlap, iwinsize, iwintype		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	knossc	init	256
	ktrig		changed	knoscs,kbinoffset,kbinincr
	if ktrig==1 then
	 reinit	UPDATE
	endif
	UPDATE:
	inoscs	init	i(knoscs)	
	ibinoffset	init	i(kbinoffset)
	ibinincr	init	i(kbinincr)
	inoscs	limit	inoscs, 1, (((iFFTsize*0.5)+1)-ibinoffset)/ibinincr
	aresyn 		pvsadsyn f_anal, inoscs, kfmod , i(kbinoffset), i(kbinincr)	;RESYNTHESIZE FROM THE fsig USING pvsadsyn
	rireturn
	amix		ntrpol		ain, aresyn, kmix					;CREATE DRY/WET MIX
			xout		amix	
endop

instr	1
	; audio input
	ainL,ainR	ins
	;ainL,ainR	diskin	"SynthPad.wav",1,0,1	;USE FOR TESTING
	kmix		chnget	"mix"
	kfmod		chnget	"fmod"
	knoscs		chnget	"noscs"
	kbinoffset	chnget	"binoffset"
	kbinincr	chnget	"binincr"
	klev		chnget	"lev"
	kfeedback	chnget	"feedback"
	
	/* SET FFT ATTRIBUTES */
	katt_table	chnget	"att_table"	; FFT atribute table
	katt_table	init	5
	ktrig		changed	katt_table
	if ktrig==1 then
	 reinit update
	endif
	update:
	iFFTsize	table	0, giFFTattributes1 + i(katt_table) - 1
	ioverlap	table	1, giFFTattributes1 + i(katt_table) - 1
	iwinsize	table	2, giFFTattributes1 + i(katt_table) - 1
	iwintype	table	3, giFFTattributes1 + i(katt_table) - 1
	/*-------------------*/

	aoutL		pvsadsyn_module	ainL,kfmod,knoscs,kbinoffset,kbinincr,kfeedback,kmix,iFFTsize,ioverlap,iwinsize,iwintype
	aoutR		pvsadsyn_module	ainR,kfmod,knoscs,kbinoffset,kbinincr,kfeedback,kmix,iFFTsize,ioverlap,iwinsize,iwintype
			outs	aoutR*klev,aoutR*klev
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pvsBlur.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("pvsBlur"), size(235,125) colour( 70, 90,100), pluginid("blur") style("legacy")
image             bounds(0, 0,235,125), colour( 70, 90,100), shape("rounded"), outlinecolour("white"), outlinethickness(5) 
label    bounds(15,20, 60,13), text("FFT Size"), fontcolour("white")
combobox bounds(15,35, 60,20), text("128","256","512","1024","2048","4096","8192"), channel("att_table"), value(4), fontcolour(220,220,255)
rslider bounds( 80, 10, 70, 70), text("Mix"),       channel("mix"),       range(0, 1.00, 1),                textcolour("white"), colour( 30, 50, 60),trackercolour("white")
rslider bounds(150, 10, 70, 70), text("Level"),     channel("lev"),       range(0, 1.00, 0.5, 0.5),         textcolour("white"), colour( 30, 50, 60),trackercolour("white")
hslider bounds( 10, 70,210, 40), channel("blurtime"),  range(0, 2.00, 0.0, 0.5, 0.0001),                    textcolour("white"), colour( 10, 30, 40),trackercolour("white")
label   bounds( 85,103, 60, 11), text("Blur Time"), fontcolour("white")
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

; Author: Iain McCurdy (2012)
; http://iainmccurdy.org/csound.html

/* FFT attribute tables */
giFFTattributes1	ftgen	0, 0, 4, -2,  128,  64,  128, 1
giFFTattributes2	ftgen	0, 0, 4, -2,  256, 128,  256, 1
giFFTattributes3	ftgen	0, 0, 4, -2,  512, 128,  512, 1
giFFTattributes4	ftgen	0, 0, 4, -2, 1024, 256, 1024, 1
giFFTattributes5	ftgen	0, 0, 4, -2, 2048, 512, 2048, 1
giFFTattributes6	ftgen	0, 0, 4, -2, 4096,1024, 4096, 1
giFFTattributes7	ftgen	0, 0, 4, -2, 8192,2048, 8192, 1

opcode	pvsblur_module,a,akkkiiii
	ain,kblurtime,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype	xin
	f_anal  	pvsanal	ain, iFFTsize, ioverlap, iwinsize, iwintype		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	f_blur		pvsblur	f_anal, kblurtime, 2					;BLUR AMPLITUDE AND FREQUENCY VALUES OF AN F-SIGNAL
	aout		pvsynth f_blur                      				;RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL
	amix		ntrpol		ain, aout, kmix					;CREATE DRY/WET MIX
			xout		amix*klev	
endop

instr	1
	kblurtime	chnget	"blurtime"
	kmix		chnget	"mix"
	klev		chnget	"lev"

	ainL,ainR	ins
	;ainL,ainR	diskin	"808loop.wav",1,0,1	;USE FOR TESTING

	/* SET FFT ATTRIBUTES */
	katt_table	chnget	"att_table"	; FFT atribute table
	katt_table	init	5
	ktrig		changed	katt_table
	if ktrig==1 then
	 reinit update
	endif
	update:
	iFFTsize	table	0, giFFTattributes1 + i(katt_table) - 1
	ioverlap	table	1, giFFTattributes1 + i(katt_table) - 1
	iwinsize	table	2, giFFTattributes1 + i(katt_table) - 1
	iwintype	table	3, giFFTattributes1 + i(katt_table) - 1
	/*-------------------*/
	
	kporttime	linseg	0,0.001,0.02
	kblurtime	portk	kblurtime,kporttime
	aoutL		pvsblur_module	ainL,kblurtime,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype
	aoutR		pvsblur_module	ainR,kblurtime,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype
				outs	aoutR,aoutR
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pvsBuffer.csd
; Writes audio into a circular FFT buffer.
; Read speed can be modified as can the frequencies.
; Take Care! Feedback values above 1 are intended to be used only when transposition is not unison. 

<Cabbage>
form caption("pvsBuffer") size(580,135), pluginid("buff") style("legacy")
image             bounds(0, 0, 580, 135), colour(100, 80, 80,125), shape("rounded"), outlinecolour("white"), outlinethickness(4) 

label             bounds(10, 97, 48,10), text("RECORD"), align(right), fontcolour(white)
label             bounds(10,112, 48,10), text("PLAY"),   align(right), fontcolour(white)
image             bounds( 70,101, 490, 3), colour(255, 50, 50), shape("sharp"), identchannel("RecIndic")
image             bounds( 70,116, 490, 3), colour( 55,250, 50), shape("sharp"), identchannel("PlayIndic")

rslider bounds(10, 11, 70, 70),  text("Speed"),     channel("speed"),     range(0, 4, 1, 0.5, 0.0001), textcolour("white"),    colour(100, 80, 80,  5) trackercolour(silver)
rslider bounds(80, 11, 70, 70),  text("Buf. Size"), channel("buflen"),    range(0.10,20.00, 5, 0.5),   textcolour("white"),    colour(100, 80, 80,  5) trackercolour(silver)
rslider bounds(150, 11, 70, 70), text("Semitones"), channel("semis"),     range(-24, 24, 0, 1, 1),     textcolour("white"),    colour(100, 80, 80,  5) trackercolour(silver)
rslider bounds(220, 11, 70, 70), text("Cents"),     channel("cents"),     range(-100, 100, 0, 1, 1),   textcolour("white"),    colour(100, 80, 80,  5) trackercolour(silver)
rslider bounds(290, 11, 70, 70), text("Feedback"),  channel("FB"),        range(0, 1.50, 0),           textcolour("white"),    colour(100, 80, 80,  5) trackercolour(silver)
label    bounds(360,20, 60,13), text("FFT Size"), fontcolour("white")
combobox bounds(360,35, 60,20), text("64","128","256","512","1024","2048","4096","8192"), channel("att_table"), value(5), fontcolour(255,255,190)

rslider bounds(430, 11, 70, 70), text("Mix"),       channel("mix"),       range(0, 1.00, 1),           textcolour("white"),    colour(100, 80, 80,  5) trackercolour(silver)
rslider bounds(500, 11, 70, 70), text("Level"),     channel("lev"),       range(0, 1.00, 0.5),         textcolour("white"),    colour(100, 80, 80,  5) trackercolour(silver)
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

;Author: Iain McCurdy (2012)
;http://iainmccurdy.org/csound.html

/* FFT attribute tables */
giFFTattributes1	ftgen	0, 0, 4, -2,   64,  32,   64, 1
giFFTattributes2	ftgen	0, 0, 4, -2,  128,  64,  128, 1
giFFTattributes3	ftgen	0, 0, 4, -2,  256, 128,  256, 1
giFFTattributes4	ftgen	0, 0, 4, -2,  512, 128,  512, 1
giFFTattributes5	ftgen	0, 0, 4, -2, 1024, 256, 1024, 1
giFFTattributes6	ftgen	0, 0, 4, -2, 2048, 512, 2048, 1
giFFTattributes7	ftgen	0, 0, 4, -2, 4096,1024, 4096, 1
giFFTattributes8	ftgen	0, 0, 4, -2, 8192,2048, 8192, 1

opcode	pvsbuffer_module,akk,akkkkkkiiii
	ain,kspeed,kbuflen,kscale,kfeedback,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype	xin
	kPhOffset	=	0
	ktrig		changed		kbuflen
	ibuflen	init	1
	kspeed	init	1
	kscale	init	1
	if ktrig==1 then
	 reinit	UPDATE
	endif
	UPDATE:
	ibuflen		=	i(kbuflen)
	iphasor		ftgen		0, 0, 65536, 7, 0, 65536, 1			;WAVE SHAPE FOR A MOVING PHASE POINTER
	aread 		osciliktp 	kspeed/ibuflen, iphasor, kPhOffset		;CREATE MOVING POINTER TO READ FROM BUFFER
	kread		downsamp	aread
	kread		=		kread * ibuflen
	aFB		init		0
	f_anal 		pvsanal		ain+aFB, iFFTsize, ioverlap, iwinsize, iwintype	;ANALYSE THE AUDIO SIGNAL THAT WAS CREATED IN INSTRUMENT 1. OUTPUT AN F-SIGNAL.
	ibuffer,ktime  	pvsbuffer   	f_anal, ibuflen					;BUFFER FSIG	
	rireturn
	khandle		init 		ibuffer						;INITIALISE HANDLE TO BUFFER
	f_buf  		pvsbufread  	kread , khandle			;READ BUFFER
	f_scale		pvscale 	f_buf, kscale					;RESCALE FREQUENCIES
	aresyn 		pvsynth  	f_scale			                   	;RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL	
	aFB		dcblock2	aresyn * kfeedback				;CREATE FEEDBACK SIGNAL FOR NEXT PASS AND BLOCK DC OFFSET ACCUMULATION
	amix		ntrpol		ain, aresyn, kmix				;CREATE DRY/WET MIX
			xout		amix*klev,ktime/ibuflen,kread/ibuflen
endop

instr	1
	ainL,ainR	ins
	;ainL,ainR	diskin	"SynthPad.wav",1,0,1	;USE FOR TESTING
	kspeed		chnget	"speed"
	kbuflen		chnget	"buflen"
	ksemis		chnget	"semis"
	kcents		chnget	"cents"
	ksemis		init	0
	kcents		init	0
	kscale		=	semitone(ksemis)*cent(kcents)
	kscale		init	1
	kbuflen		init	1
	kspeed		init	1
	kmix		chnget	"mix"
	kfeedback	chnget	"FB"
	klev		chnget	"lev"
	kmix		init	1
	kfeedback	init	0
	klev		init	0.5

	/* SET FFT ATTRIBUTES */
	katt_table	chnget	"att_table"	; FFT atribute table
	katt_table	init	5
	ktrig		changed	katt_table
	if ktrig==1 then
	 reinit update
	endif
	update:
	iFFTsize	table	0, giFFTattributes1 + i(katt_table) - 1
	ioverlap	table	1, giFFTattributes1 + i(katt_table) - 1
	iwinsize	table	2, giFFTattributes1 + i(katt_table) - 1
	iwintype	table	3, giFFTattributes1 + i(katt_table) - 1
	/*-------------------*/
	
	aoutL,kwrite,kread		pvsbuffer_module	ainL,kspeed,kbuflen,kscale,kfeedback,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype
	aoutR,k1,k1			pvsbuffer_module	ainR,kspeed,kbuflen,kscale,kfeedback,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype
			outs	aoutL,aoutR

	ktrig	metro	kr/(ksmps*2)
	if ktrig==1 then
	 Smsg	sprintfk	"size(%d,3)",kwrite*490
	 chnset	Smsg,"RecIndic" 
	 Smsg	sprintfk	"size(%d,3)",kread*490
	 chnset	Smsg,"PlayIndic" 
	endif
endin

</CsInstruments>
<CsScore>
i 1 0.1 [60*60*24*7]
</CsScore>
</CsoundSynthesizer>; pvScale.csd
; Written by Iain McCurdy, 2012. Updated 2015.

; Pitch scaling interval can be defined either in semitones and cents or as a ratio (fraction).

; Three methods of feedback are possible:
;  1: "F Sig" Direct feeding back of the fft signal
;  2: "Audio" feeding back of the audio signal, therefore each time the signal will be resynthesized anf then re-analysed. Additional delay will also be induced when feeding back.
;  3: "Iter. A number of iterations are defined, creating a stack of pitch shifted signals. This method will be CPU costly if "Iter." is high. Some CPU can be saved by reducing "FFT Size"

; FFT Size	-	Larger values will retain spectral accuracy at the expense of time accuracy
;			Smaller values will improve time accuracy at the expense of spectral accuracy.
;			In general smaller values are preferrable with rhythmic material and larger values are preferrable with melodic material. 

; Port.		-	Portamento time applied to changed made to the pitch scaling interval

<Cabbage>
form caption("pvscale Pitch Shifter") size(690,  90), pluginid("scal") style("legacy")
image                         bounds(0, 0, 690, 90), colour("SlateGrey"), outlinecolour("silver"), outlinethickness(4)

image bounds(  6, 23,678, 30), colour("silver"), shape("ellipse"), outlinethickness(3)

label    bounds( 10, 24, 75, 12), text("Interval"), fontcolour("black")
combobox bounds( 10, 37, 75, 20), channel("IntervalMode"), text("Semitone","Ratio"), value(1)

image   bounds( 90, 10,290, 80), colour(0,0,0,0), plant("Semitone"), identchannel("semitone_ident") {
image   bounds(  8,  1, 54, 53), colour(30,30,30), shape("ellipse"), outlinethickness(0)
rslider bounds(  0,  0, 70, 70),  text("Semitones"), channel("semis"), range(-24, 24, 7, 1, 1),   textcolour("black"),colour("DarkSlateGrey"), trackercolour("LightBlue")
image   bounds( 78,  1, 54, 53), colour(30,30,30), shape("ellipse"), outlinethickness(0)
rslider bounds( 70,  0, 70, 70),  text("Cents"),     channel("cents"), range(-100, 100, 0, 1, 1), textcolour("black"),colour("DarkSlateGrey"), trackercolour("LightBlue")
}

image     bounds(130, 20, 35, 58), plant("Ratio"), colour(0,0,0,0), visible(0), identchannel("ratio_ident") {
nslider bounds(  5,  5, 25, 18), channel("Numerator"),        range(1,99,3,1,1)
image     bounds(  0, 26, 35,  1), shape("sharp"), colour("black")
nslider bounds(  5, 30, 25, 18), channel("Denominator"),      range(1,99,2,1,1)
}

image   bounds(238, 11, 54, 53), colour(30,30,30), shape("ellipse"), outlinethickness(0)	; circles around rsliders
rslider bounds(230, 10, 70, 70), text("Feedback"),  channel("FB"), range(0.00, 0.99, 0),         textcolour("black"),colour("DarkSlateGrey"), trackercolour("LightBlue"), identchannel("feedback_ident")
rslider bounds(230, 10, 70, 70), text("Iter."),     channel("Iter"), range(1, 10, 1,1,1),        textcolour("black"),colour("DarkSlateGrey"), trackercolour("LightBlue"), identchannel("iter_ident"), visible(0)

label    bounds(310,  8, 70, 12), text("F.back Mode"), FontColour("black")
combobox bounds(310, 20,  70,20), channel("FB_mode"), value(1), text("F Sig.", "Audio", "Iter.")

label    bounds(310, 45,  70, 12), text("Formants"), FontColour("black")
combobox bounds(310, 57,  70, 20), channel("formants"), value(1), text("Ignore", "Keep 1", "Keep 2")

label    bounds(400, 24, 60, 12), text("FFT Size"), fontcolour("black")
combobox bounds(400, 37, 60, 20), channel("FFTsize"), text("64","128","256","512","1024","2048","4096","8192"), value(6)

image   bounds(478, 11, 54, 53), colour(30,30,30), shape("ellipse"), outlinethickness(0)
rslider bounds(470, 10, 70, 70), text("Port."),     channel("port"),      range(0,30.00, 0.05,0.5,0.01), textcolour("black"),colour("DarkSlateGrey"), trackercolour("LightBlue")
image   bounds(548, 11, 54, 53), colour(30,30,30), shape("ellipse"), outlinethickness(0)
rslider bounds(540, 10, 70, 70), text("Mix"),       channel("mix"),       range(0, 1.00, 0.5),      textcolour("black"),colour("DarkSlateGrey"), trackercolour("LightBlue")
image   bounds(618, 11, 54, 53), colour(30,30,30), shape("ellipse"), outlinethickness(0)
rslider bounds(610, 10, 70, 70), text("Level"),     channel("lev"),       range(0, 1.00, 0.5, 0.5), textcolour("black"),colour("DarkSlateGrey"), trackercolour("LightBlue")
</Cabbage>

<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

;Iain McCurdy
;http://iainmccurdy.org/csound.html
;Pitch shifting effect using pvs scale opcode.

/* FFT attribute tables */
giFFTsizes	ftgen	0, 0, 8, -2, 64, 128, 256, 512, 1024, 2048, 4096, 8192

opcode	pvscale_module,a,akkkkkki
	ain,kscale,kformants,kfeedback,kFB_mode,kmix,klev,iFFTsize	xin
	if(kFB_mode==0) then
	 f_FB		pvsinit iFFTsize, iFFTsize/4, iFFTsize, 1, 0			;INITIALISE FEEDBACK FSIG
	 f_anal  	pvsanal	ain, iFFTsize, iFFTsize/4, iFFTsize, 1			;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	 f_mix		pvsmix	f_anal, f_FB						;MIX AUDIO INPUT WITH FEEDBACK SIGNAL
	 f_scale		pvscale f_mix, kscale					;RESCALE FREQUENCIES
	 f_FB		pvsgain f_scale, kfeedback 					;CREATE FEEDBACK F-SIGNAL FOR NEXT PASS
	 aout		pvsynth f_scale                      				;RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL
	else
	 aFB		init	0
	 f_anal  	pvsanal	ain+aFB, iFFTsize, iFFTsize/4, iFFTsize, 1		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	 f_scale		pvscale f_anal, kscale, kformants-1			;RESCALE FREQUENCIES
	 aout		pvsynth f_scale                      				;RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL
	 aFB		=	aout*kfeedback
	endif	
	amix		ntrpol		ain, aout, kmix					;CREATE DRY/WET MIX
			xout		amix*klev	
endop

opcode	pvscale_module_iter,a,akkikkip
	ain,kscale,kformants,iIter,kFB_mode,kporttime,iFFTsize,iCount	xin
	aout,amix	init	0
	f_anal  	pvsanal	ain, iFFTsize, iFFTsize/4, iFFTsize, 1		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	kscaleL		portk	kscale^iCount, kporttime 
	f_scale		pvscale f_anal, kscaleL, kformants-1		;RESCALE FREQUENCIES
	aout		pvsynth f_scale
	if iCount<iIter then
	 amix	pvscale_module_iter	ain,kscale,kformants,iIter,kFB_mode,kporttime,iFFTsize,iCount+1
	endif	
	                      				;RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL
			xout		aout+amix	
endop

instr	1
	/* GUI WIDGETS SHOWING AND HIDING FOR INTERVAL DEFINITION CONTROLS */
	kIntervalMode	chnget	"IntervalMode"
	if changed(kIntervalMode)==1 then
	 if kIntervalMode==1 then
	  	chnset	"visible(1)","semitone_ident"
	  	chnset	"visible(0)","ratio_ident"
	 else
	  	chnset	"visible(0)","semitone_ident"	 
	  	chnset	"visible(1)","ratio_ident"
	 endif
	endif

	/* GUI WIDGETS SHOWING AND HIDING FOR FEEDBACK CONTROLS */
	kFB_mode	chnget	"FB_mode"
	if changed(kFB_mode)==1 then
	 if kFB_mode==3 then
	  	chnset	"visible(0)","feedback_ident"
	  	chnset	"visible(1)","iter_ident"
	 else
	  	chnset	"visible(1)","feedback_ident"
	  	chnset	"visible(0)","iter_ident"
	 endif
	endif
	
	ainL,ainR	ins
	;ainL,ainR	diskin2	"SynthPad.wav",1,0,1
	;ainL	vco2	0.3,300,4,0.5
	ainR	=	ainL
	kmix	chnget	"mix"
	kFB	chnget	"FB"
	kIter	chnget	"Iter"
	kformants	chnget	"formants"
	
	/* SET FFT ATTRIBUTES */
	kFFTsize	chnget	"FFTsize"
	kFFTsize	init	6
	ktrig		changed	kFFTsize,kformants,kIter
	if ktrig==1 then
	 reinit update
	endif
	update:

	/* PORTAMENTO TIME FUNCTION */
	kporttime	linseg	0,0.001,1	; ramp-up function
	kport		chnget	"port"		; widget		
	kporttime	*=	kport		; combine ramp-up and widget value

	iFFTsize	table	i(kFFTsize)-1, giFFTsizes
	/*-------------------*/
	
	kfeedback	chnget	"FB"
	ksemis		chnget	"semis"
	kcents		chnget	"cents"
	kNumerator	chnget	"Numerator"
	kDenominator	chnget	"Denominator"
	
	kmix		chnget	"mix"
	klev		chnget	"lev"
	
	kscale		=	kIntervalMode = 1 ? semitone(ksemis)*cent(kcents) : kNumerator/kDenominator

	if kFB_mode==3 then
	 aoutL		pvscale_module_iter	ainL,kscale,kformants,i(kIter),kFB_mode,kporttime,iFFTsize
	 aoutR		pvscale_module_iter	ainR,kscale,kformants,i(kIter),kFB_mode,kporttime,iFFTsize
	 aoutL		ntrpol	ainL,aoutL,kmix
	 aoutR		ntrpol	ainR,aoutR,kmix
	 aoutL		*=	klev
	 aoutR		*=	klev	 
	else
	 kscale		portk	kscale, kporttime
	 aoutL		pvscale_module	ainL,kscale,kformants,kfeedback,kFB_mode,kmix,klev,iFFTsize
	 aoutR		pvscale_module	ainR,kscale,kformants,kfeedback,kFB_mode,kmix,klev,iFFTsize
	endif
	
			outs	aoutR,aoutR
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pvsCross.csd
; Written by Iain McCurdy, 2012.

; This effect implements cross-synthesis between the left and right inputs.
; By default, the left input is the 'source' signal and the right signal is the 'destination' signal.
;  This arrangement can be swapped with the swap button.

; LEFT----+
;         |
;      (SOURCE)                 +---LEFT
;         |                     |
;         +-CROSS-SYNTHESIS-----+
;         |                     |
;    (DESTINATION)              +---RIGHT
;         |
; RIGHT---+


; Source	-	level of the source signal sent to the output.
; Dest.		-	level of the destination signal sent to the output.
; Cross		-	level of the cross-synthesis signal sent to the output.
; Level		-	global control of the level of all signal that may be present at the output.

<Cabbage>
form caption("pvsCross") size(370, 90), pluginid("crss") style("legacy")
image            bounds(0, 0, 370, 90), colour("Cream"), outlinecolour("silver"), outlinethickness(5)

; filter switches
checkbox bounds( 10, 20, 94, 15), text("Swap Inputs"), channel("swap"), fontcolour(138, 54, 15), colour("lime")

label    bounds(15, 41, 60,13), text("FFT Size"), fontcolour(138, 54, 15)
combobox bounds(15, 55, 60,20), text("64","128","256","512","1024","2048","2048","4096","8192","16384"), channel("att_table"), value(5)

line     bounds(115, 10,165, 3), colour("Grey")

label   bounds(160,  5, 75, 12), text("M  I  X  E  R"), fontcolour(78, 24,  7), colour("Cream")
rslider bounds(100,18, 75, 65), text("Source"),     channel("src_lev"),   range(0, 1.00, 0),   textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
rslider bounds(160,18, 75, 65), text("Dest."),      channel("dst_lev"),   range(0, 1.00, 0),   textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
rslider bounds(220,18, 75, 65), text("Cross"),      channel("cross_lev"), range(0, 1.00, 1),   textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
rslider bounds(285, 8, 75, 75), text("Level"),      channel("lev"),       range(0, 1.00, 0.5), textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
</Cabbage>
<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>
sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

;Iain McCurdy
;http://iainmccurdy.org/csound.html

/* FFT attribute tables */
giFFTattributes1	ftgen	0, 0, 4, -2,   64,  32,   64, 1
giFFTattributes2	ftgen	0, 0, 4, -2,  128,  64,  128, 1
giFFTattributes3	ftgen	0, 0, 4, -2,  256, 128,  256, 1
giFFTattributes4	ftgen	0, 0, 4, -2,  512, 128,  512, 1
giFFTattributes5	ftgen	0, 0, 4, -2, 1024, 128, 1024, 1
giFFTattributes6	ftgen	0, 0, 4, -2, 2048, 256, 2048, 1
giFFTattributes7	ftgen	0, 0, 4, -2, 2048,1024, 2048, 1
giFFTattributes8	ftgen	0, 0, 4, -2, 4096,1024, 4096, 1
giFFTattributes9	ftgen	0, 0, 4, -2, 8192,2048, 8192, 1
giFFTattributes10	ftgen	0, 0, 4, -2,16384,4096,16384, 1

opcode	pvscross_module,a,aakkkiiii
	a_src,a_dst,kampS,kampD,klev,iFFTsize,ioverlap,iwinsize,iwintype	xin
	f_src  	pvsanal	a_src, iFFTsize, ioverlap, iwinsize, iwintype		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	f_dst  	pvsanal	a_dst, iFFTsize, ioverlap, iwinsize, iwintype		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	f_cross 	pvscross f_src, f_dst, kampS, kampD			;IMPLEMENT fsig CROSS SYNTHESIS
	aout		pvsynth f_cross                      				;RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL
			xout		aout*klev	
endop



instr	1

	katt_table	chnget	"att_table"	; FFT atribute table
	katt_table	init	5
	ktrig		changed	katt_table
	if ktrig==1 then
	 reinit update
	endif
	update:
	iFFTsize	table	0, giFFTattributes1 + i(katt_table) - 1
	ioverlap	table	1, giFFTattributes1 + i(katt_table) - 1
	iwinsize	table	2, giFFTattributes1 + i(katt_table) - 1
	iwintype	table	3, giFFTattributes1 + i(katt_table) - 1
		
	kfeedback	chnget	"FB"
	kampS		=	0;chnget	"ampS"
	kampD		=	1;chnget	"ampD"
	kporttime	linseg	0,0.001,0.02
	kmix		chnget	"mix"
	klev		chnget	"lev"
	ksrc_lev		chnget	"src_lev"
	kdst_lev		chnget	"dst_lev"
	kcross_lev		chnget	"cross_lev"
	klev		chnget	"lev"
	klisten		chnget	"listen"
	kswap		chnget	"swap"
	
	a1		inch	1
	a2		inch	2

	if kswap==0 then
	 a_src	=	a1
	 a_dst	=	a2
	else
	 a_src	=	a2
	 a_dst	=	a1
	endif
	
	aoutL		pvscross_module	a_src,a_dst,kampS,kampD,klev,iFFTsize,ioverlap,iwinsize,iwintype
	aoutR		pvscross_module	a_src,a_dst,kampS,kampD,klev,iFFTsize,ioverlap,iwinsize,iwintype

	aMixL	=	(aoutL*kcross_lev)+(a_src*ksrc_lev)+(a_dst*kdst_lev)
	aMixR	=	(aoutR*kcross_lev)+(a_src*ksrc_lev)+(a_dst*kdst_lev)

		outs	aMixL,aMixR
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pvsFreeze.csd
; Freeze either amplitude stream or frequency stream (or both) of a streaming FFT analysis
; Changing FFT size can modify the sound quality of the frozen sound

; 'Auto' can be used to automatically trigger a new freeze frame (both amplitude and frequency) if the amplitude of the sound crosses a threshold
; 'Delay' specifies the time delay at which the sound will actually be frozen after the threshold triggering. This can be employed to capture the sustain portion of a sound (and not the attack).
; 'Threshold' specifies the threshold level at which triggering will occur. In a noisy environment, raise 'Threshold'

<Cabbage>
form caption("pvsfreeze"), size(660,100) colour(  0,160,80), pluginid("frez") style("legacy")

image            bounds(  0,  0,270, 80), colour(  0,160,80), shape("rounded"), outlinecolour("white"), outlinethickness(4), plant("Freeze") {
checkbox bounds( 15, 10, 180, 25), channel("freezb"), text("Freeze Both"), fontcolour("white"), shape("ellipse"), colour("red")
checkbox bounds( 20, 50, 180, 15), channel("lock"), text("Lock Phases"), fontcolour("white"), shape("ellipse"), colour("LightBlue")
checkbox bounds(120, 10, 180, 25), channel("freeza"), text("Freeze Amplitudes"), fontcolour("white"), shape("ellipse"), colour("yellow")
checkbox bounds(120, 45, 180, 25), channel("freezf"), text("Freeze Frequencies"), fontcolour("white"), shape("ellipse"), colour("orange")
}

image bounds(270,  0,190, 80), colour(  0,160,80), shape("rounded"), outlinecolour("white"), outlinethickness(4), plant("Auto") {
button  bounds( 15, 25, 40, 20), channel("auto"), text("Auto","Auto"), colour:0(  0,  0,  0), fontcolour:0(100,100,100), colour:1(255,100,100), fontcolour:1(255,200,200)
rslider bounds( 60, 10, 60, 60), text("Delay"),     channel("delay"),  textcolour("white"), range(0.0001, 0.5, 0.1, 1,0.001), colour(  0,100, 50,255), trackercolour("white")
rslider bounds(120, 10, 60, 60), text("Threshold"), channel("thresh"), textcolour("white"), range(0.001, 0.5, 0.1,1,0.001),   colour(  0,100, 50,255), trackercolour("white")
}

image   bounds(460,  0,200, 80), colour(  0,160,80), shape("rounded"), outlinecolour("white"), outlinethickness(4), plant("Mix") {
label    bounds(10,15, 60,13), text("FFT Size"), fontcolour("white")
combobox bounds(10,30, 60,18), text("64","128","256","512","1024","2048","4096","8192"), channel("att_table"), value(5)
rslider bounds( 70, 10, 60, 60), text("Mix"),      channel("mix"),       range(0, 1.00, 1),        textcolour("white"), colour(  0,100, 50,255), trackercolour("white")
rslider bounds(130, 10, 60, 60), text("Level"),    channel("lev"),       range(0, 1.00, 0.5, 0.5), textcolour("white"), colour(  0,100, 50,255), trackercolour("white")
}




label   bounds( 2,85,100,10), text("Iain McCurdy . 2017"), fontcolour("white")
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

;Author: Iain McCurdy (2013)
;http://iainmccurdy.org/csound.html

/* FFT attribute tables */
giFFTattributes1	ftgen	0, 0, 4, -2,   64,  32,   64, 1
giFFTattributes2	ftgen	0, 0, 4, -2,  128,  64,  128, 1
giFFTattributes3	ftgen	0, 0, 4, -2,  256, 128,  256, 1
giFFTattributes4	ftgen	0, 0, 4, -2,  512, 128,  512, 1
giFFTattributes5	ftgen	0, 0, 4, -2, 1024, 256, 1024, 1
giFFTattributes6	ftgen	0, 0, 4, -2, 2048, 512, 2048, 1
giFFTattributes7	ftgen	0, 0, 4, -2, 4096,1024, 4096, 1
giFFTattributes8	ftgen	0, 0, 4, -2, 8192,2048, 8192, 1

opcode	pvsfreeze_module,a,akkkkiiiik
	ain,kfreeza,kfreezf,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype,klock	xin

	f_anal  	pvsanal	ain, iFFTsize, ioverlap, iwinsize, iwintype		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	f_freeze	pvsfreeze f_anal, kfreeza, kfreezf
	f_lock 		pvslock f_freeze, klock
	aout		pvsynth f_lock
	amix		ntrpol		ain, aout, kmix					;CREATE DRY/WET MIX
			xout		amix*klev	
endop

instr	1
	kmix		chnget	"mix"			; read in widgets
	klev		chnget	"lev"
	kfreeza		chnget	"freeza"
	kfreezf		chnget	"freeza"
	kfreezb		chnget	"freezb"
	klock		chnget	"lock"
	
	; triggering of 'Freeze All' mode
	kon		=	1
	koff		=	0
	ktrigon		trigger	kfreezb,0.5,0
	ktrigoff	trigger	kfreezb,0.5,1
	if(ktrigon==1) then
	 chnset		kon,"freeza"
	 chnset		kon,"freezf"
	elseif(ktrigoff==1) then
	 chnset		koff,"freeza"
	 chnset		koff,"freezf"
	endif

	; audio input
	ainL,ainR	ins

	; auto freeze triggering
	kauto	chnget	"auto"				; read in widgets
	kthresh	chnget	"thresh"
	kdelay	chnget	"delay"
	if kauto==1 then				; if 'Auto' is on
	 krms	rms	ainL+ainR			; scan RMS of audio signal
	 ktrig	trigger	krms,kthresh,0			; if signal crosses threshold upwards																																																																													
	 ktrigdel	vdel_k	ktrig,kdelay,0.5	; delayed version of the trigger
	 if ktrig==1 then				; if initial threshold crossing occurs...
	  chnset		koff,"freeza"		; turn freezing off
	  chnset		koff,"freezf"
	 endif
	 if ktrigdel==1 then				; if delayed trigger is received...
	  chnset		kon,"freeza"		; turn freezing on
	  chnset		kon,"freezf"
	 endif
	endif

	kofftrig	trigger	kauto,0.5,1		; when 'Auto' is turned off generate a trigger
	if kofftrig==1 then				; if 'Auto' is turned off...
	 chnset		koff,"freeza"			; turn freezing off
	 chnset		koff,"freezf"
	endif	

	/* SET FFT ATTRIBUTES */
	katt_table	chnget	"att_table"	; FFT atribute table
	katt_table	init	5
	ktrig		changed	katt_table
	if ktrig==1 then
	 reinit update
	endif
	update:
	iFFTsize	table	0, giFFTattributes1 + i(katt_table) - 1
	ioverlap	table	1, giFFTattributes1 + i(katt_table) - 1
	iwinsize	table	2, giFFTattributes1 + i(katt_table) - 1
	iwintype	table	3, giFFTattributes1 + i(katt_table) - 1
	/*-------------------*/
	
	aoutL		pvsfreeze_module	ainL,kfreeza,kfreezf,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype, klock
	aoutR		pvsfreeze_module	ainR,kfreeza,kfreezf,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype, klock
				outs				aoutR,aoutR
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pvShift.csd
; Written by Iain McCurdy, 2012.

; Streaming phase vocoding frequency shifter.

<Cabbage>
form caption("pvshift Frequency Shifter") size(510,  90), pluginid("shft"), scrollbars(0) style("legacy")

image bounds( 15,  9, 60, 60), colour(30,30,30,100), shape("ellipse"), outlinethickness(0)
image bounds( 85,  9, 60, 60), colour(30,30,30,100), shape("ellipse"), outlinethickness(0)
image bounds(155,  9, 60, 60), colour(30,30,30,100), shape("ellipse"), outlinethickness(0)
image bounds(225,  9, 60, 60), colour(30,30,30,100), shape("ellipse"), outlinethickness(0)
image bounds(295,  9, 60, 60), colour(30,30,30,100), shape("ellipse"), outlinethickness(0)
image bounds(365,  9, 60, 60), colour(30,30,30,100), shape("ellipse"), outlinethickness(0)
image bounds(435,  9, 60, 60), colour(30,30,30,100), shape("ellipse"), outlinethickness(0)
image bounds(-60,-5,630,110), colour(100,205,60), outlinecolour("silver"), outlinethickness(6), shape("ellipse")
rslider bounds( 10, 15, 70, 70), text("Coarse"),     channel("coarse"),    range(-4000, 4000, 0, 1),    colour("orange"), trackercolour("yellow"), textcolour("black")
rslider bounds( 80, 15, 70, 70), text("Multiplier"), channel("fine"),      range(-1, 1, 1, 1, 0.0001),  colour("orange"), trackercolour("yellow"), textcolour("black")
rslider bounds(150, 15, 70, 70), text("Lowest"),     channel("lowest"),    range( 20, 20000, 20, 0.5),  colour("orange"), trackercolour("yellow"), textcolour("black")
rslider bounds(220, 15, 70, 70), text("Feedback"),   channel("FB"),        range(0, 1.00, 0),           colour("orange"), trackercolour("yellow"), textcolour("black")
label    bounds(295,20, 60,13), text("FFT Size"), fontcolour("black")
combobox bounds(295,35, 60,20), text("64","128","256","512","1024","2048","4096","8192"), channel("att_table"), value(5), fontcolour(220,220,255)
rslider bounds(360, 15, 70, 70), text("Mix"),        channel("mix"),       range(0, 1.00, 1),           colour("orange"), trackercolour("yellow"), textcolour("black")
rslider bounds(430, 15, 70, 70), text("Level"),      channel("lev"),       range(0, 1.00, 0.5, 0.5),    colour("orange"), trackercolour("yellow"), textcolour("black")
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

;Iain McCurdy
;http://iainmccurdy.org/csound.html
;Frequency shifting effect using pvshift opcode.

/* FFT attribute tables */
giFFTattributes1	ftgen	0, 0, 4, -2,   64,  32,   64, 1
giFFTattributes2	ftgen	0, 0, 4, -2,  128,  64,  128, 1
giFFTattributes3	ftgen	0, 0, 4, -2,  256, 128,  256, 1
giFFTattributes4	ftgen	0, 0, 4, -2,  512, 128,  512, 1
giFFTattributes5	ftgen	0, 0, 4, -2, 1024, 256, 1024, 1
giFFTattributes6	ftgen	0, 0, 4, -2, 2048, 512, 2048, 1
giFFTattributes7	ftgen	0, 0, 4, -2, 4096,1024, 4096, 1
giFFTattributes8	ftgen	0, 0, 4, -2, 8192,2048, 8192, 1

opcode	pvshift_module,a,akkkkkiiii
	ain,kshift,klowest,kfeedback,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype	xin
	f_FB		pvsinit iFFTsize,ioverlap,iwinsize,iwintype, 0			; INITIALISE FEEDBACK FSIG
	f_anal  	pvsanal	ain, iFFTsize, ioverlap, iwinsize, iwintype		; ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	f_mix		pvsmix	f_anal, f_FB									; MIX AUDIO INPUT WITH FEEDBACK SIGNAL
	f_shift		pvshift f_mix, kshift, klowest							; SHIFT FREQUENCIES
	f_FB		pvsgain f_shift, kfeedback 								; CREATE FEEDBACK F-SIGNAL FOR NEXT PASS
	aout		pvsynth f_shift                      					; RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL
	amix		ntrpol		ain, aout, kmix								; CREATE DRY/WET MIX
			xout		amix*klev	
endop

instr	1
	ainL,ainR	ins
	;gicos	ftgen	0,0,131072,11,1			; test tone
	;ainL	gbuzz	0.1,330,80,1,0.7,gicos	; test tone
	ainR	=		ainL
	
	
	;ainL,ainR	diskin2	"SynthPad.wav",1,0,1
	kcoarse	chnget	"coarse"	; coarse freq. shift
	kfine	chnget	"fine"		; fine freq. control (multipler)
	kporttime	linseg	0,0.001,0.2
	kshift	lineto	kcoarse*kfine, kporttime	; ultimate freq. shift is sum of coarse and fine controls
	klowest	chnget	"lowest"	; lowest shifted frequency
	kFB	chnget	"FB"		; feedback amount
	kmix		chnget	"mix"
	klev		chnget	"lev"

	/* SET FFT ATTRIBUTES */
	katt_table	chnget	"att_table"	; FFT atribute table
	katt_table	init	5
	ktrig		changed	katt_table
	if ktrig==1 then
	 reinit update
	endif
	update:
	iFFTsize	table	0, giFFTattributes1 + i(katt_table) - 1
	ioverlap	table	1, giFFTattributes1 + i(katt_table) - 1
	iwinsize	table	2, giFFTattributes1 + i(katt_table) - 1
	iwintype	table	3, giFFTattributes1 + i(katt_table) - 1
	/*-------------------*/
	
	aoutL		pvshift_module	ainL,kshift,klowest,kFB,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype	; call UDO for each channel
	aoutR		pvshift_module	ainR,kshift,klowest,kFB,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype

			outs	aoutR,aoutR
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pvSmooth.csd
; Written by Iain McCurdy, 2012.
; FFT feedback is disabled if amplitude smoothing is increased beyond zero. If this is not done the instrument will fail. 

; link	-	links 'Amp.Smooth' and 'Frq.Smooth'

<Cabbage>
form caption("pvSmooth") size(505, 90), pluginid("smoo"), scrollbars(0) style("legacy")
image bounds(0, 0, 505, 90), colour("Cream"), outlinecolour("silver"), outlinethickness(5)
label pos(-52, -30), size(615, 150), fontcolour(210,105, 30, 80), text("smooth"), shape("rounded"), outlinecolour("white"), outlinethickness(4)
rslider bounds( 10, 8, 75, 75), text("Amp.Smooth"), channel("acf"),       range(0, 1.00, 0,16, 0.0001), textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
checkbox bounds( 70, 8, 70,10), channel("link"), text("Link"), fontcolour(138, 54, 15)
rslider bounds( 90, 8, 75, 75), text("Frq.Smooth"), channel("fcf"),       range(0, 1.00, 0,16, 0.0001), textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
rslider bounds(170, 8, 75, 75), text("Feedback"),   channel("FB"),        range(0, 0.999, 0, 1,0.001),    textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
label    bounds(250,20, 70,13), text("FFT Size"), fontcolour(138, 54, 15)
combobox bounds(250,35, 70,20), text("64","128","256","512","1024","2048","2048_2","4096","8192","16384"), channel("att_table"), value(5), fontcolour(255,255,200)
checkbox bounds(250,60, 90,10), channel("delay"), text("Delay Comp."), fontcolour(138, 54, 15)
rslider bounds(330, 8, 75, 75), text("Mix"),        channel("mix"),       range(0, 1.00, 1),              textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
rslider bounds(410, 8, 75, 75), text("Level"),      channel("lev"),       range(0, 1.00, 0.5),            textcolour(138, 54, 15), colour("chocolate"), trackercolour(138, 54, 15)
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

;Iain McCurdy
;http://iainmccurdy.org/csound.html
;Spectral smoothing effect.

/* FFT attribute tables */
giFFTattributes1	ftgen	0, 0, 4, -2,   64,  32,   64, 1
giFFTattributes2	ftgen	0, 0, 4, -2,  128,  64,  128, 1
giFFTattributes3	ftgen	0, 0, 4, -2,  256, 128,  256, 1
giFFTattributes4	ftgen	0, 0, 4, -2,  512, 128,  512, 1
giFFTattributes5	ftgen	0, 0, 4, -2, 1024, 128, 1024, 1
giFFTattributes6	ftgen	0, 0, 4, -2, 2048, 256, 2048, 1
giFFTattributes7	ftgen	0, 0, 4, -2, 2048,1024, 2048, 1
giFFTattributes8	ftgen	0, 0, 4, -2, 4096,1024, 4096, 1
giFFTattributes9	ftgen	0, 0, 4, -2, 8192,2048, 8192, 1
giFFTattributes10	ftgen	0, 0, 4, -2,16384,4096,16384, 1

opcode	pvsmooth_module,a,akkkkkiiiii
	ain,kacf,kfcf,kfeedback,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype,idelay	xin
	f_FB		pvsinit iFFTsize,ioverlap,iwinsize,iwintype, 0			;INITIALISE FEEDBACK FSIG
	f_anal  	pvsanal	ain, iFFTsize, ioverlap, iwinsize, iwintype		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	f_mix		pvsmix	f_anal, f_FB						;MIX AUDIO INPUT WITH FEEDBACK SIGNAL
	f_smooth	pvsmooth	f_mix, kacf, kfcf				;BLUR AMPLITUDE AND FREQUENCY VALUES OF AN F-SIGNAL
	f_FB		pvsgain f_smooth, kfeedback 					;CREATE FEEDBACK F-SIGNAL FOR NEXT PASS
	aout		pvsynth f_smooth                      				;RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL
	if idelay==1 then
	 ain	delay	ain,(iFFTsize)/sr
	endif
	amix		ntrpol		ain, aout, kmix					;CREATE DRY/WET MIX
			xout		amix*klev	
endop

instr	1
	ainL,ainR	ins
	;ainL,ainR	diskin	"808loop.wav",1,0,1	;USE FOR TESTING
	;ainL,ainR	diskin	"SynthPad.wav",1,0,1	;USE FOR TESTING

	katt_table	chnget	"att_table"	; FFT atribute table
	katt_table	init	5
	kdelay		chnget	"delay"
	ktrig		changed	katt_table,kdelay
	if ktrig==1 then
	 reinit update
	endif
	update:
	iFFTsize	table	0, giFFTattributes1 + i(katt_table) - 1
	ioverlap	table	1, giFFTattributes1 + i(katt_table) - 1
	iwinsize	table	2, giFFTattributes1 + i(katt_table) - 1
	iwintype	table	3, giFFTattributes1 + i(katt_table) - 1
		
	kfeedback	chnget	"FB"
	kacf		chnget	"acf"
	kfcf		chnget	"fcf"
	klink		chnget	"link"
	if klink==1 then
	 if changed(kacf)==1 then
	  chnset	kacf,"fcf"
	 elseif changed(kfcf)==1 then
	  chnset	kfcf,"acf"
	 endif
	endif
	kfeedback	=	(kacf>0?0:kfeedback)		; feedback + amplitude smoothing can cause failure so we must protect against this
	kacf		=	1-kacf
	kfcf		=	1-kfcf
	kporttime	linseg	0,0.001,0.02
	kmix		chnget	"mix"
	klev		chnget	"lev"
	aoutL		pvsmooth_module	ainL,kacf,kfcf,kfeedback,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype,i(kdelay)
	aoutR		pvsmooth_module	ainR,kacf,kfcf,kfeedback,kmix,klev,iFFTsize,ioverlap,iwinsize,iwintype,i(kdelay)
			outs	aoutR,aoutR
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; pvsWarp.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("pvsWarp") size(535, 90), pluginid("warp") style("legacy")
image pos(0, 0), size(535, 90), colour( 80, 80,135,220), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
rslider bounds( 10, 11, 70, 70), text("Scale"),    channel("scal"),      range(0.1, 4, 1, 0.5, 0.001), colour("LightSlateGrey"), textcolour("white"), trackercolour("white")
rslider bounds( 80, 11, 70, 70), text("Shift"),    channel("shift"),     range(-5000, 5000, 0),        colour("LightSlateGrey"), textcolour("white"), trackercolour("white")
rslider bounds(150, 11, 70, 70), text("Feedback"), channel("FB"),        range(0, 0.99, 0),            colour("LightSlateGrey"), textcolour("white"), trackercolour("white")
label    bounds(220,20, 60,13), text("FFT Size"), fontcolour("white")
combobox bounds(220,35, 60,20), text("128","256","512","1024","2048","4096","8192"), channel("att_table"), value(4), fontcolour("lightblue")
checkbox bounds(290,30, 95,15), channel("DelayComp"), text("Delay Comp."), fontcolour("white"), colour("lightblue")
rslider bounds(385, 11, 70, 70), text("Mix"),      channel("mix"),       range(0, 1.00, 1),            colour("LightSlateGrey"), textcolour("white"), trackercolour("white")
rslider bounds(455, 11, 70, 70), text("Level"),    channel("lev"),       range(0, 1.00, 0.5),          colour("LightSlateGrey"), textcolour("white"), trackercolour("white")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE

;Author: Iain McCurdy (2012)
;http://iainmccurdy.org/csound.html

/* FFT attribute tables */
giFFTattributes1	ftgen	0, 0, 4, -2,   64,  32,   64, 1
giFFTattributes2	ftgen	0, 0, 4, -2,  128,  64,  128, 1
giFFTattributes3	ftgen	0, 0, 4, -2,  256, 128,  256, 1
giFFTattributes4	ftgen	0, 0, 4, -2,  512, 128,  512, 1
giFFTattributes5	ftgen	0, 0, 4, -2, 1024, 256, 1024, 1
giFFTattributes6	ftgen	0, 0, 4, -2, 2048, 512, 2048, 1
giFFTattributes7	ftgen	0, 0, 4, -2, 4096,1024, 4096, 1
giFFTattributes8	ftgen	0, 0, 4, -2, 8192,2048, 8192, 1

opcode	pvswarp_module,a,akkkkiiiii
	ain,kscal,kshift,kfeedback,kmix,iFFTsize,ioverlap,iwinsize,iwintype,iDelayComp	xin
	aout		init	0
	;f_FB		pvsinit iFFTsize,ioverlap,iwinsize,iwintype, 0			;INITIALISE FEEDBACK FSIG
	f_anal  	pvsanal	ain+(aout*kfeedback), iFFTsize, ioverlap, iwinsize, iwintype		;ANALYSE AUDIO INPUT SIGNAL AND OUTPUT AN FSIG
	;f_mix		pvsmix	f_anal, f_FB						;MIX AUDIO INPUT WITH FEEDBACK SIGNAL
	f_warp		pvswarp	f_anal, kscal, kshift					;WARP SPECTRAL ENVELOPE VALUES OF AN F-SIGNAL USING BOTH SCALING AND SHIFTING
	;f_FB		pvsgain f_warp, kfeedback 					;CREATE FEEDBACK F-SIGNAL FOR NEXT PASS
	aout		pvsynth f_warp                      				;RESYNTHESIZE THE f-SIGNAL AS AN AUDIO SIGNAL
	if(kfeedback>0) then
	 aout		clip	aout,0,0dbfs
	endif
	if iDelayComp==1 then
	 ain	delay	ain,iwinsize/sr
	endif
	amix		ntrpol		ain, aout, kmix					;CREATE DRY/WET MIX
			xout		amix	
endop

instr	1
	ainL,ainR	ins
	;ainL,ainR	diskin	"SynthPad.wav",1,0,1	;USE FOR TESTING
	kscal		chnget	"scal"
	kshift		chnget	"shift"
	kfeedback	chnget	"FB"
	kmix		chnget	"mix"
	klev		chnget	"lev"
	kDelayComp	chnget	"DelayComp"
	ainL		=	ainL*klev
	ainR		=	ainR*klev

	/* SET FFT ATTRIBUTES */
	katt_table	chnget	"att_table"	; FFT atribute table
	katt_table	init	5
	ktrig		changed	katt_table,kDelayComp
	if ktrig==1 then
	 reinit update
	endif
	update:
	iFFTsize	table	0, giFFTattributes1 + i(katt_table) - 1
	ioverlap	table	1, giFFTattributes1 + i(katt_table) - 1
	iwinsize	table	2, giFFTattributes1 + i(katt_table) - 1
	iwintype	table	3, giFFTattributes1 + i(katt_table) - 1
	/*-------------------*/

	aoutL		pvswarp_module	ainL,kscal,kshift,kfeedback,kmix,iFFTsize,ioverlap,iwinsize,iwintype,i(kDelayComp)
	aoutR		pvswarp_module	ainR,kscal,kshift,kfeedback,kmix,iFFTsize,ioverlap,iwinsize,iwintype,i(kDelayComp)
			outs	aoutL,aoutR
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>
; RingModulator.csd
; Written by Iain McCurdy, 2012.

; Ring Modulator
; --------------
; Modulating waveform is a harmonic waveform based on a sawtooth waveform.
;  The number of harmonics included is defined using 'Harms'.
;  An offset of harmonics to omit is defined using 'Offset'.
;  Therefore Harms=1 and Offset=0 will produce a sine wave.

; Input		-	input mode 

; Freq.		-	frequency of the ring modulator (if input mode is 'Knob')
;			 If input mode is 'Kybd.' then base frequency is derived from the note played and the 'Freq.' knob is disregarded.
; Harms.	-	number of harmonics included in the modulating waveform
; Offset	-	number of harmonics to skip before building the harmonic waveform used by the modulator

; Env.		-	amount of amplitude following used to influence the modulator frequency
; Att.		-	attack time used in amplitude following
; Dec.		-	decay time used in amplitude following

; Thresh	-	threshold which, if the rms (amplitude measurement) crosses through, will trigger the generation of a new random modulator frequency.
;			 If thresh is zero, the random triggering of new modulating frequencies is bypassed
; Min.		-	minimum of the range within which a new modulating frequency will be generated (oct format)
; Max.		-	maximum of the range within which a new modulating frequency will be generated (oct format)

; Width		-	create stereo width by offsetting the phase of the left channel modulator with respect to that of the right
; Mix		-	dry/wet mix
; Level		-	output level

<Cabbage>
form caption("Ring Modulator") size(755,170), pluginid("rmod") style("legacy")
image               pos(0, 0), size(755, 90), colour("black"), shape("rounded"), outlinecolour("lime"), outlinethickness(5) 
label    bounds( 10, 20, 65, 13), text("Input"), textcolour(white)
combobox bounds( 10, 34, 65, 18), text("Knob","Keybd."), channel("input"), textcolour(white)
rslider bounds( 75, 12, 70, 70), text("Freq."),    channel("freq"),  range(0, 15000, 800, 0.25),   colour("yellow"),    trackercolour(white), textcolour(white)
rslider bounds(145, 12, 70, 70), text("Harms"),    channel("harms"), range(1, 40, 1,1,1),          colour("yellow"),    trackercolour(white), textcolour(white)
rslider bounds(215, 12, 70, 70), text("Offset"),   channel("offset"),range(0, 20, 0,1,1),          colour("yellow"),    trackercolour(white), textcolour(white)

line    bounds(290,  2, 3, 86), colour("lime")
rslider bounds(300, 12, 70, 70), text("Env."),     channel("env"),   range(0, 1.00, 0.5, 0.5,0.001), colour("orange"),    trackercolour(white), textcolour(white)
rslider bounds(370,  6, 40, 40), text("Att."),     channel("att"),   range(0.001, 2, 0.01, 0.5),   colour("orange"),    trackercolour(white), textcolour(white)
rslider bounds(370, 46, 40, 40), text("Dec."),     channel("dec"),   range(0.001, 2, 0.1,  0.5),   colour("orange"),    trackercolour(white), textcolour(white)
line    bounds(415,  2, 3, 86), colour("lime")

rslider bounds(425, 12, 70, 70), text("Thresh"),   channel("thresh"),   range(0, 1.00, 0, 0.5,0), colour("orange"),    trackercolour(white), textcolour(white)
rslider bounds(490,  6, 40, 40), text("Min."),     channel("min"),   range(0, 13, 5),   colour("orange"),    trackercolour(white), textcolour(white)
rslider bounds(490, 46, 40, 40), text("Max."),     channel("max"),   range(0, 13, 8),   colour("orange"),    trackercolour(white), textcolour(white)
line    bounds(535,  2, 3, 86), colour("lime")


rslider bounds(540, 12, 70, 70), text("Width"),    channel("width"), range(0, 1.0, 0.3,1,0.001),   colour("chocolate"), trackercolour(white), textcolour(white)
rslider bounds(610, 12, 70, 70), text("Mix"),      channel("mix"),   range(0, 1.00, 1),            colour("chocolate"), trackercolour(white), textcolour(white)
rslider bounds(680, 12, 70, 70), text("Level"),    channel("level"), range(0, 1.00, 1),            colour("chocolate"), trackercolour(white), textcolour(white)

keyboard bounds(0,92,755,78)
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
;-d -n
-dm0 -n -+rtmidi=null -M0
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
massign	0,2

;Author: Iain McCurdy (2012)
;http://iainmccurdy.org/csound.html

gisaw	ftgen	0,0,4096,7,1,4096,-1	; source modulating waveform (unbandlimited sawtooth waveform) before harmonic filtering

opcode	RingModulator,a,akkkkkii
	ain,kmix,kfreq,kenv,katt,kdec,ifn,iphs	xin			;READ IN INPUT ARGUMENTS
	iWet	ftgentmp	0,0,1024,-7,0,512,1,512,1		;RESCALING FUNCTION FOR WET LEVEL CONTROL
	iDry	ftgentmp	0,0,1024,-7,1,512,1,512,0		;RESCALING FUNCTION FOR DRY LEVEL CONTROL
	kWet	table	kmix, iWet, 1					;RESCALE WET LEVEL CONTROL ACCORDING TO FUNCTION TABLE iWet
	kDry	table	kmix, iDry, 1					;RESCALE DRY LEVEL CONTROL ACCORDING TO FUNCTION TABLE iDry
	aFollow	follow2		ain, katt, kdec				;AMPLITUDE FOLLOWING kModFrq + (cpsoct(kFollow*kenv*30))     	;CREATE A LEFT CHANNEL MODULATING FREQUENCY BASE ON THE STATIC VALUE CREATED BY kfreq AND THE AMOUNT OF DYNAMIC ENVELOPE FOLLOWING GOVERNED BY kenv
	kFollow	downsamp	aFollow
	kFollow	logcurve	kFollow/0dbfs,2
	kfreq	=	kfreq + (kFollow*kenv*8000)     		;CREATE A LEFT CHANNEL MODULATING FREQUENCY BASE ON THE STATIC VALUE CREATED BY kfreq AND THE AMOUNT OF DYNAMIC ENVELOPE FOLLOWING GOVERNED BY kenv
	aMod	poscil	1, kfreq, ifn, iphs  			;CREATE RING MODULATING SIGNAL
	aout	sum	ain*kDry, ain*aMod*kWet				;MIX DRY AND WET SIGNALS
		xout	aout						;SEND AUDIO BACK TO CALLER INSTRUMENT
endop

instr	1
 kporttime	linseg	0,0.001,0.1
 gkfreq	chnget	"freq"
 gkfreq	portk	gkfreq,kporttime
 gkmix 	chnget	"mix"
 gkwidth	chnget	"width"
 gkenv 	chnget	"env"
 gkatt 	chnget	"att"
 gkdec 	chnget	"dec"
 gkthresh 	chnget	"thresh"
 gkmin 	chnget	"min"
 gkmax 	chnget	"max"
 gklevel 	chnget	"level"
 gkharms		chnget	"harms"
 gkoffset	chnget	"offset"

 ga1,ga2	ins
 ;ga1,ga2	diskin2	"808loop.wav",1,0,1

 gkinput	chnget	"input"
 gkinput	init	1
 if changed(gkinput)==1&&gkinput==1 then
  event	"i",2,0,-1
 endif
endin

instr	2
 /* MIDI AND GUI INTEROPERABILITY */
 iMIDIflag	=	0			; IF MIDI ACTIVATED = 1, NON-MIDI = 0
 mididefault	1, iMIDIflag			; IF NOTE IS MIDI ACTIVATED REPLACE iMIDIflag WITH '1'
 
 if iMIDIflag==1 then				; IF THIS IS A MIDI ACTIVATED NOTE...
  icps	cpsmidi					; READ MIDI PITCH VALUES - THIS VALUE CAN BE MAPPED TO GRAIN DENSITY AND/OR PITCH DEPENDING ON THE SETTING OF THE MIDI MAPPING SWITCHES
  kfreq	=		icps
 else
  kfreq 	=	gkfreq
 endif						; END OF THIS CONDITIONAL BRANCH

 if gkinput!=1&&iMIDIflag!=1 then
  turnoff
 endif
 
 if gkthresh>0 then
  a1,a2	init	0
  krms	rms	a1+a2
  kRTrig	init	1
  kfreq	trandom	kRTrig,gkmin,gkmax
  kfreq	=	cpsoct(kfreq)
  if changed(kfreq)==1 then
   chnset	kfreq,"freq"
  endif
  kRTrig	trigger	krms,gkthresh,0
 endif
 
 if metro(8)==1 then 
  if changed(gkharms,gkoffset,gkwidth)==1 then
   reinit UPDATE
  endif
  UPDATE:
 endif
 ifn	ftgen	1, 0, 4096, 30, gisaw, 1+i(gkoffset), i(gkharms)+i(gkoffset)		; generate a waveform based on chosen source waveform with user-set modifications
 ;ifn	ftgen	1, 0, 4096, 10, 1
 a1	RingModulator	ga1,gkmix,kfreq,gkenv,gkatt,gkdec,ifn,i(gkwidth)
 a2	RingModulator	ga2,gkmix,kfreq,gkenv,gkatt,gkdec,ifn,0
 rireturn
 aEnv	linsegr	0,0.01,1,0.01,0
 a1	=	a1 * gklevel * aEnv
 a2	=	a2 * gklevel * aEnv
 	outs	a1,a2
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; Shredulator.csd
; Written by Iain McCurdy, 2016

; This effect implements an FFT delay, the delay time of which can be shifted using a random sample and gold function.
; In sync with this random function, amplitude can also be randomised ('Granulate' control), as can transposition.

; CONTROLS
; --------

; FFT Size		-	size of FFT window: smaller sizes provides better time resolution but possible distortion of frequency components
; Max Delay		-	Maximum delay time as defined by the circular (pvs) buffer. This is i-rate so altering it will cause discontinuities in the realtime audio stream.
;					 Note that maximum delay time can modulated at k-rate using the 'Depth' control
; Rate			-	Rate at which new random delay times are generated. This also controls the rate at which new random amplitude ('Granulation') 
;  					 and random transposition ('Randomise') values are generated.
;					This control can also be thought of as 'grain size'.
; Depth			-	Amplitude of the random delay time generator. This, along with 'Max.Delay', controls the maximum random delay time possible.
; Granulation	-	Amount of random amplitude variation
; Feedback		-	Ratio of output (pvs) signal that is fed back into the input

; Semitones		-	Number of semitones transposition
; Cents			-	Number of cents transposition
; Pre/Post		-	If 'Pre' is selected, the signal before transposition is sent to the output (transposition are only heard via the feedback signal), 
;					 if 'Post' is selected the, the transposed signal is sent directly to the output
; Randomise		-	If raised above zero, rather than transposition being a fixed value as defined by 'Semitones' and 'Cents' 
;               	 it will be a bipolar random value in the range +/- the offset defined by 'Semitones' and 'Cents'.


<Cabbage>
form caption("") size(460,395), colour(225,230,255), pluginid("Shrd"), scrollbars(0) style("legacy")
image   bounds(  0,-10,460, 45), colour(0,0,0,0), outlinethickness(0), plant("title")
{
label   bounds(  0,  1,460, 51), text("SHREDULATOR"), fontcolour(155,155,155)
image   bounds( 55, 21,325,  5),   colour(225,230,255), shape("sharp"), rotate(0.1,162,2)
image   bounds( 90, 21,200,  7),   colour(225,230,255), shape("sharp"), rotate(-0.18,100,3)

label   bounds(  1,  3,459, 50), text("SHREDULATOR"), fontcolour(  5,  5,  5)
image   bounds( 45, 21, 80,  2),   colour(225,230,255), shape("sharp"), rotate(-0.8,40,1)
image   bounds(110, 21, 55,  2),   colour(225,230,255), shape("sharp"), rotate( 0.8,22,1)
image   bounds( 85, 34,100,  3),   colour(225,230,255), shape("sharp"), rotate(-0.4,22,1)
image   bounds(160, 34,180,  3),   colour(225,230,255), shape("sharp"), rotate(-0.2,45,2)
image   bounds(215, 17, 70,  4),   colour(225,230,255), shape("sharp"), rotate( 0.5,22,2)
image   bounds(250, 21,150,  4),   colour(225,230,255), shape("sharp"), rotate( 0.2,60,2)
image   bounds(271, 31, 53,  2),   colour(225,230,255), shape("sharp"), rotate(-0.1,22,1)
image   bounds(340, 21, 60,  2),   colour(225,230,255), shape("sharp"), rotate( 0.7,22,1)
}

label bounds(358, 39,97,10), fontcolour("black"), text("Iain McCurdy |2016|") align("right")

image    bounds(5,50,450,110), colour(225,230,255), outlinecolour("Black"), outlinethickness(5), plant("Delay")
{  
label    bounds(  0,  3,440, 13), text("D    E    L    A    Y"), fontcolour("Black")
label    bounds( 10, 20, 70, 14), text("FFT Size"), fontcolour("Black")
combobox bounds( 10, 35, 70, 20), text("128","256","512","1024","2048","4096"), channel("FFTindex"), value(4)
rslider  bounds( 75, 15, 90,90), text("Max.Delay"), textbox(1), valuetextbox(1), channel("MaxDelay"), range(0.1, 8, 3.7,0.5), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
rslider  bounds(145, 15, 90,90), text("Rate"), textbox(1), valuetextbox(1), channel("Rate"), range(0.1, 500, 10,0.5,0.1), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
rslider  bounds(215, 15, 90,90), text("Depth"), textbox(1), valuetextbox(1), channel("Depth"), range(0, 1, 0.2), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
rslider  bounds(285, 15, 90,90), text("Granulation"), textbox(1), valuetextbox(1), channel("Granulation"), range(0, 1, 0.2), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
rslider  bounds(355, 15, 90,90), text("Feedback"), textbox(1), valuetextbox(1), channel("Feedback"), range(0, 1, 0.5), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
}

image    bounds(5,165,450,110), colour(225,230,255), outlinecolour("Black"), outlinethickness(5), plant("Transpose")
{  
label    bounds(  0,  3,450, 13), text("T    R    A    N    S    P    O    S    E"), fontcolour("Black")
rslider  bounds( 60, 15, 90,90), text("Semitones"), textbox(1), valuetextbox(1), channel("Semitones"), range(-12, 12, 5,1,1), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
rslider  bounds(130, 15, 90,90), text("Cents"), textbox(1), valuetextbox(1), channel("Cents"), range(-100, 100, 0,1,1), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
label    bounds(220, 20, 70, 14), text("Pre/Post"), fontcolour("Black")
combobox bounds(220, 35, 70, 20), text("Pre","Post"), channel("PrePost"), value(2)
rslider  bounds(290, 15, 90,90), text("Randomise"), textbox(1), valuetextbox(1), channel("TransRand"), range(0, 1, 0.35), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
}

image    bounds(5,280,450,110), colour(225,230,255), outlinecolour("Black"), outlinethickness(5), plant("Output")
{  
label    bounds(  0,  3,450, 13), text("O    U    T    P    U    T"), fontcolour("Black")
rslider  bounds(110, 15, 90,90), text("Width"), textbox(1), valuetextbox(1), channel("Width"), range(0, 1, 1), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
rslider  bounds(180, 15, 90,90), text("Dry/Wet Mix"), textbox(1), valuetextbox(1), channel("DryWetMix"), range(0, 1, 1), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
rslider  bounds(250, 15, 90,90), text("Level"), textbox(1), valuetextbox(1), channel("Level"), range(0, 1, 1), fontcolour("Black"), textcolour("Black"), colour(20,20,155), trackercolour(150,150,225)
}

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -d -+rtmidi=NULL -M0 -m0d 
</CsOptions>
                                           
<CsInstruments>

sr = 44100
ksmps = 16
nchnls = 2
0dbfs = 1


instr	1
 kMaxDelay			chnget		"MaxDelay"
 kMaxDelay			init		1
 kSemitones			chnget		"Semitones"
 kCents				chnget		"Cents"
 kTransRand			chnget		"TransRand"
 kDepth				chnget		"Depth"
 kRate				chnget		"Rate"
 kTranspose			=			kSemitones + kCents*0.01
 kFeedback			chnget		"Feedback"
 kWidth				chnget		"Width"
 kDryWetMix			chnget		"DryWetMix"
 kLevel				chnget		"Level"
 kFFTindex			chnget		"FFTindex"
 kFFTindex			init		4
 kGranulation		chnget		"Granulation"
 kPrePost			chnget		"PrePost"
 kPrePost			init		1
 iFFTsizes[]		fillarray	128,256,512,1024,2048,4096	; array of FFT size values
 
 ;aL		diskin	"JAG.wav",1,0,1											; read in sound file
 ;aL		poscil	0.4,300
 ;aR		=		aL
 aL,aR		ins
 
 if changed(kMaxDelay,kFFTindex)==1 then
  reinit RESTART
 endif
 RESTART:

 iFFTsize			=			iFFTsizes[i(kFFTindex)-1]	; retrieve FFT size value from array

 fsigInL			pvsanal		aL, iFFTsize, iFFTsize/4, iFFTsize, 1	; FFT analyse audio
 fsigInR			pvsanal		aR, iFFTsize, iFFTsize/4, iFFTsize, 1	; FFT analyse audio
 fsigFB				pvsinit 	iFFTsize									; initialise feedback signal
 fsigMixL 			pvsmix 		fsigInL, fsigFB								; mix feedback with input
 fsigMixR 			pvsmix 		fsigInR, fsigFB								; mix feedback with input

 iHandle1, kTime	pvsbuffer	fsigMixL, i(kMaxDelay)								; create a circular fsig buffer
 kDly1				randomh		0,i(kMaxDelay)*kDepth, kRate, 1				; delay time
 kAmp1				trandom		changed(kDly1),-kGranulation*60,0
 kTranspose1_2		trandom		changed(kDly1),kTranspose-(2*kTranspose*kTransRand),kTranspose
 fsigOut			pvsbufread 	kTime-kDly1, iHandle1						; read from buffer
 fsigGran			pvsgain		fsigOut,ampdbfs(kAmp1)
 fScale				pvscale		fsigGran,semitone(kTranspose1_2)
 fsigFB				pvsgain 	fScale, kFeedback			; create feedback signal for next pass
 if kPrePost==1 then
  aDly				pvsynth		fsigGran 									; resynthesise read buffer output
 else
  aDly				pvsynth		fScale 									; resynthesise read buffer output
 endif
 aMix				ntrpol		aL,aDly,kDryWetMix 						; dry/wet audio mix
 					outs		aMix*kLevel*(1-kWidth),aMix*kLevel

 iHandle2, kTime	pvsbuffer	fsigMixR, i(kMaxDelay)								; create a circular fsig buffer
 kDly2				randomh		0,i(kMaxDelay)*kDepth, kRate, 1				; delay time
 kAmp2				trandom		changed(kDly2),-kGranulation*60,0
 kTranspose2_2		trandom		changed(kDly2),kTranspose-(2*kTranspose*kTransRand),kTranspose
 fsigOut			pvsbufread 	kTime-kDly2, iHandle2 						; read from buffer
 fsigGran			pvsgain		fsigOut,ampdbfs(kAmp2)
 fScale				pvscale		fsigGran,semitone(kTranspose2_2)
 fsigFB				pvsgain 	fScale, kFeedback			; create feedback signal for next pass
 if kPrePost==1 then
  aDly				pvsynth		fsigGran 									; resynthesise read buffer output
 else
  aDly				pvsynth		fScale 									; resynthesise read buffer output
 endif
 aMix				ntrpol		aR,aDly,kDryWetMix 						; dry/wet audio mix
 					outs		aMix*kLevel,aMix*kLevel*(1-kWidth)
endin

</CsInstruments>

<CsScore>
i 1 0 -1
f 0 3700
</CsScore>

</CsoundSynthesizer>
; BounceDelay.csd
; Written by Iain McCurdy, 2015

; Creates layers of delays, their delay times mathematically related so as to create the impression of sounds bouncing and coming to rest (and other sound effects).
; The gesture can be further shaped by applying progessive amounts of amplitude reduction, lowpass filtering and highpass filtering.

; Total time	-	total time of the 'bounce' gesture / the length of the longest delay.
; Number	-	number of delays
; Warp		-	amount of progressive time warping of the delays:
;			 If 'Warp' = 0 then delays are uniformly spaced
;			 If 'Warp' < 0 then delays are progressively more narrowly spaced (the typical 'bounce' structure)
;			 If 'Warp' > 0 then delays are progressively more widely spaced (a reverse 'bounce' structure)
; Feedback	-	The amount output -> input feedback in each individual delay
; Mix		-	Dry/wet mix.
; Level		-	Output level
; Amp.Curve	-	Delay by delay amplitude shaping	
;			 If 'Amp.Curve' = 0, no shaping is applied.
;			 If 'Amp.Curve' < 0, amplitudes are progressively attenuated. The more negative this value is, the more rapidly amplitudes are reduced / the steeper the slope of the curve.
;			 If 'Amp.Curve' > 0, amplitudes are progressively increased (starting at silence). The larger this value is, the more rapidly amplitudes are increased / the steeper the slope of the curve.

; Lowpass Filter
; --------------
; Curve		-	Delay by delay lowpass filtering. Curve shaping operates in a similar fashion to 'Amp.Curve'
; Slope		-	Steepness of the cutoff slope of the filter.

; Highpass Filter
; --------------
; Curve		-	Delay by delay highpass filtering. Curve shaping operates in a similar fashion to 'Amp.Curve'
; Slope		-	Steepness of the cutoff slope of the filter.

; Note that the dry signal is included in amplitude and filtering shaping so depending on the three curve settings it may be filtered or even attenuated completely.
	
<Cabbage>
form caption("Bounce Delay"), size(490,385), pluginid("BnDl") style("legacy")
rslider   bounds( 10, 10, 70, 70), channel("TotalTime"), text("Total Time"), colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0.01, 4, 1.7, 0.5)
rslider   bounds( 90, 10, 70, 70), channel("Number"), text("Number"),        colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(1, 32,20, 1,1)
rslider   bounds(170, 10, 70, 70), channel("Warp"), text("Warp"),            colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(-3, 3, -0.5)
rslider   bounds(250, 10, 70, 70), channel("Feedback"), text("Feedback"),    colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0)
rslider   bounds(330, 10, 70, 70), channel("Mix"), text("Mix"),              colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.5)
rslider   bounds(410, 10, 70, 70), channel("Level"), text("Level"),          colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 1)

rslider   bounds( 10,125, 70, 70), channel("AmpCurve"), text("Amp.Curve"),   colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(-1, 1, -0.7)

image     bounds( 90,100,180,100), colour(0,0,0,0), outlinecolour("white"), outlinethickness(1), plant("LPF"){
label     bounds(  0,  3,180, 14), fontcolour("white"), text("L o w p a s s   F i l t e r")
rslider   bounds( 10, 25, 70, 70), channel("LPFCurve"), text("Curve"),   colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(-1, 1, -0.8)
label     bounds( 80, 30, 80, 14), fontcolour("white"), text("Slope")
combobox  bounds( 80, 45, 80, 20),  channel("LPFType"),text("Bypass","6dB/oct","12dB/oct"), colour(  0, 40, 50), textcolour("white"), value(2)
}

image     bounds(285,100,180,100), colour(0,0,0,0), outlinecolour("white"), outlinethickness(1), plant("HPF"){
label     bounds(  0,  3,180, 14), fontcolour("white"), text("H i g h p a s s   F i l t e r")
rslider   bounds( 10, 25, 70, 70), channel("HPFCurve"), text("Curve"),   colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(-1, 1, 0)
label     bounds( 80, 30, 80, 14), fontcolour("white"), text("Slope")
combobox  bounds( 80, 45, 80, 20),  channel("HPFType"),text("Bypass","6dB/oct","12dB/oct"), colour(  0, 40, 50), textcolour("white"), value(1)
}

label     bounds( 10,370,110, 10), fontcolour(150,150,150), text("Iain McCurdy |2015|")

; display bars 
image bounds( 18,218,454,124), colour(250,250,250), shape("sharp")
image bounds( 20,220,450,120), colour( 20, 20, 20), shape("sharp"), plant("display") {
image bounds(  -100,  0,  4,100), colour(250,250,250), shape(sharp), visible(1), widgetarray("Bars",32)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

giCurveRange	=	4	; extent of the control over shaping curves. This governs all curves: amplitude, LPF and HPF but it might be preferrable to have independent global variables for independent control.
giMaxDelay	=	4	; maximum delay time (this should correspond with the maximum value used for the 'Total Time' widget) 

; UDO that defines a single delay layer
; recursion is used to generate multiple delays. Layer counting is used to differentiate between layers.
opcode	EchoDelays,aa,aakkkkkkkkii
 aInL,aInR,kTotTim,kWarp,kFeedback,kAmpCurve,kLPFCurve,kLPFType,kHPFCurve,kHPFType,iNumber,iCount	xin	; read in input arguments
 ;	setksmps	1
 kRatio	pow	(iCount)/(iNumber),kWarp		; define delay time ratio according to layer number and 'Warp' amount. 
 kTim	=	kTotTim * kRatio		; scale ratio by total delay time
 aTim	interp	kTim				; create interpolated a-rate version. Creates higher quality results than just using a k-rate variable in the delay.  
 abuf	delayr	giMaxDelay			; establish delay buffer (establish memory/RAM needed)
 atapL	deltapi	aTim				; read from within delay buffer
 	delayw	aInL + (atapL*kFeedback)	; write into delay buffer
 abuf	delayr	giMaxDelay			; do the same for the right channel
 atapR	deltapi	aTim
 	delayw	aInR + (atapR*kFeedback)

 /* define amplitude */
 if kAmpCurve<=0 then											; negative or zero curve values
  kAmpVal	pow	1-(iCount/iNumber), octave((abs(kAmpCurve)*giCurveRange)-giCurveRange/2)	; calculate amplitude scaling value (will be a value between zero and 1). Each layer will have its own value. 
 else												 	; positive curve values
  kAmpVal	pow	(iCount/iNumber), octave((abs(kAmpCurve)*giCurveRange)-giCurveRange/2)
 endif

 /* define LPF */
 if kLPFCurve<-0.01||kLPFCurve>0.01 then								; only apply filtering if curve value is moved away from zero (!=0 didn't seem to be working)
  if kLPFCurve<=0 then											; when curve widget is negative or zero
   kLPFVal	pow	1-(iCount/iNumber), octave((abs(kLPFCurve)*giCurveRange)-giCurveRange/2)	; calculate lowpass filtering ratio (a value between 0 and 1)
  else													; positive values
   kLPFVal	pow	iCount/iNumber, octave((kLPFCurve*giCurveRange)-giCurveRange/2)
  endif
  if kLPFType==2 then											; choose between 6db and 12dB/oct filter slopes i.e. tone or butlp opcodes 
   atapL		tone	atapL,cpsoct((kLPFVal*10)+4)
   atapR		tone	atapR,cpsoct((kLPFVal*10)+4)
  elseif kLPFType==3 then
   atapL		butlp	atapL,cpsoct((kLPFVal*10)+4)
   atapR		butlp	atapR,cpsoct((kLPFVal*10)+4)
  endif  
 endif

 /* define HPF */
 if kHPFCurve<-0.01||kHPFCurve>0.01 then
  if kHPFCurve<=0 then
   kHPFVal	pow	1-(iCount/iNumber), octave((abs(kHPFCurve)*giCurveRange)-giCurveRange/2)
  else
   kHPFVal	pow	iCount/iNumber, octave((kHPFCurve*giCurveRange)-giCurveRange/2)
  endif
  if kHPFType==2 then
   atapL		atone	atapL,cpsoct(((1-kHPFVal)*10)+4)
   atapR		atone	atapR,cpsoct(((1-kHPFVal)*10)+4)
  elseif kHPFType==3 then
   atapL		buthp	atapL,cpsoct(((1-kHPFVal)*10)+4)
   atapR		buthp	atapR,cpsoct(((1-kHPFVal)*10)+4)
  endif  
 endif

 /* call the next echo (if required) */ 
 if iCount<iNumber then
  aMixL,aMixR	EchoDelays	aInL,aInR,kTotTim,kWarp,kFeedback,kAmpCurve,kLPFCurve,kLPFType,kHPFCurve,kHPFType,iNumber,iCount+1
 endif
 
 /* send back to instrument */
 	xout	(atapL*kAmpVal)+aMixL,(atapR*kAmpVal)+aMixR
 aMixL	=	0
 aMixR	=	0
endop


instr	1
 kporttime	linseg	0,0.001,0.05
 kTotTim	chnget	"TotalTime"
 kTotTim	portk	kTotTim,kporttime
 kNumber	chnget	"Number"
 kNumber	init	10
 kWarp		chnget	"Warp"   
 kWarp		portk	octave(kWarp),kporttime
 kWarp		init	1
 kFeedback	chnget	"Feedback"   
 kAmpCurve	chnget	"AmpCurve"
 kAmpCurve	init	0
 kLPFCurve	chnget	"LPFCurve"
 kLPFType	chnget	"LPFType"
 kHPFCurve	chnget	"HPFCurve"
 kHPFType	chnget	"HPFType" 
 kMix		chnget	"Mix"
 kLevel		chnget	"Level"
  
 aInL,aInR	ins

 /* reinitialise if 'Number' (of layers) changes */
 if changed(kNumber)==1 then
  reinit UPDATE
 endif
 UPDATE:
 
 iNumber	=	i(kNumber)
 if iNumber>1 then			; only call UDO if more than one layer is asked for (the dry/undelayed signal is the first layer)
  aDelL,aDelR	EchoDelays	aInL,aInR,kTotTim,kWarp,kFeedback,kAmpCurve,kLPFCurve,kLPFType,kHPFCurve,kHPFType,iNumber,1
 else
  aDelL	=	0
  aDelR	=	0
 endif
 
 /* define amplitude */
 if kAmpCurve>0 then	; attenuate dry signal completely if 'Amp.Curve' is positive	
  aInL	=	0
  aInR	=	0
 endif
 
 /* define LPF */
 if kLPFCurve>0 then			; if (Lowpass) curve is positive we need to apply maximum lowpass filtering to the first sound iteration (the dry signal)
  if kLPFType==2 then			; choose between filter types
   aInL		tone	aInL,cpsoct(4)
   aInR		tone	aInR,cpsoct(4)
  elseif kLPFType==3 then
   aInL		butlp	aInL,cpsoct(4)
   aInR		butlp	aInR,cpsoct(4)
  endif  
 endif

 /* define HPF */			; if (Highpass) curve is positive we need to apply maximum highpass filtering to the first sound iteration (the dry signal)
 if kHPFCurve>0 then
  if kHPFType==2 then
   aInL		atone	aInL,cpsoct(14)
   aInR		atone	aInR,cpsoct(14)
  elseif kHPFType==3 then
   aInL		buthp	aInL,cpsoct(14)
   aInR		buthp	aInR,cpsoct(14)
  endif  
 endif
 
 aMixL	ntrpol		aInL, aDelL, kMix	; dry/wet mixing
 aMixR	ntrpol		aInR, aDelR, kMix

	outs	aMixL*kLevel, aMixR*kLevel




 /* move display bars */
 if changed(kNumber)==1 then		; hide all
  reinit HideAndShow
 endif
 HideAndShow:
 icount	=	1
 loop0:
 Sident	sprintf	"Bars_ident%i",icount
 	chnset	"visible(0)",Sident
 	loop_le	icount,1,32,loop0
 icount	=	1
 loop1:
 Sident	sprintf	"Bars_ident%i",icount
 	chnset	"visible(1)",Sident
 	loop_lt	icount,1,i(kNumber),loop1
 rireturn
 
 if metro(5)==1 then
  if changed(kNumber,kTotTim,kWarp,kAmpCurve)==1 then
   reinit MoveBars
  endif
 endif
 MoveBars:
 icount	=	1
 inum	=	i(kNumber)
 iwid	=	450 * (i(kTotTim)/giMaxDelay)
 ipos	=	0
 loop:
 Sident	sprintf	"Bars_ident%i",icount 
 iRatio	pow	(icount-1)/(inum-1),i(kWarp)
 ipos	=	iwid * iRatio

 iAmpCurve	=	i(kAmpCurve)
 if iAmpCurve>-0.01&&iAmpCurve<0.01 then
  iAmpVal	=	1 
 elseif iAmpCurve<=0 then											; negative or zero curve values
  iAmpVal	pow	1-(icount/inum), octave((abs(iAmpCurve)*giCurveRange)-giCurveRange/2)		; calculate amplitude scaling value (will be a value between zero and 1). Each layer will have its own value. 
 else									 	; positive curve values
  iAmpVal	pow	(icount/inum), octave((abs(iAmpCurve)*giCurveRange)-giCurveRange/2)
 endif
 
 Smess	sprintf	"bounds(%i, %i,  1,%i)",ipos,20+(100*(1-iAmpVal)),100*iAmpVal
 	chnset	Smess,Sident
 	loop_le	icount,1,inum,loop
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>; BreakBeatCutter.csd
; Iain McCurdy, 2013.

; Break Beat Cut Up using the bbcut opcode with additional processing

; ==BBCUT=================================================================================================================
; 'Sub-division' determines the note duration used as the base unit in  cut-ups. 
; For example a value of 8 represents quavers (eighth notes), 16 represents semiquavers (sixteenth notes) and so on.                                                   
; 
; 'Bar Length' represents the number of beats per bar. For example, a value of 4 represents a 4/4 bar and so on. 
; 
; 'Phrase' defines the number of bars that will elapse before the cutting up pattern restarts from the beginning.          
; 
; 'Stutter' is a separate cut-up process which occasionally will take a very short fragment of the input audio and repeat
; it many times. 
; 
; 'Stutter Speed' defines the duration of each stutter in relation to 'Sub-division'. 
; If subdivision is 8 (quavers / eighth notes) and 'Stutter Speed' is 2 then each stutter will be a semiquaver / sixteenth note.
; 
; 'Stutter Chance' defines the frequency of stutter moments. 
; The range for this parameter is 0 to 1. Zero means stuttering will be very unlikely, 1 means it will be very likely.       
; 'Repeats' defines the number of repeats that will be employed in normal cut-up events.                                     
; When processing non-rhythmical, unmetered material it may be be more interesting to employ non-whole numbers for parameters such as 'Sub-division', 'Phrase' and 'Stutter Speed'.                                                      
; ========================================================================================================================




; ==FILTER================================================================================================================
; Additionally in this example a randomly moving band-pass filter has been implemented. 
; 
; 'Filter Mix' crossfades between the unfiltered bbcut signal and the filtered bbcut signal.   
; 
; 'Cutoff Freq.' consists of two small sliders which determine the range from which random cutoff values are derived.       
; 
; 'Interpolate<=>S&H' fades continuously between an interpolated random function and a sample and hold type random function. 
; 
; 'Filter Div.' controls the frequency subdivision with which new random cutoff frequency values are generated - a value of '1' means that new values are generated once every bar.                                    
; ========================================================================================================================



; ==WGUIDE================================================================================================================
; A waveguide effect can randomly and rhythmically cut into the audio stream
; 'Chance' defines the probability of this happening. 0=never 1=always
; The range of frequencies the effect will choose from is defined by the user as note values.
; Frequencies are quatised to adhere to equal temperament.
; ========================================================================================================================



; ==SQUARE MOD. (Square wave ring modulation)=============================================================================
; This effect can similarly randomly and rhythmically cut into the audio stream using the 'chance' control
; The range of frequencies the modulator waveform can move between is defined as 'oct' values.
; ========================================================================================================================


; ==F.SHIFT (Frequency Shifter)===========================================================================================
; Similar to the above except using a frequency shifter effect.
; ========================================================================================================================

<Cabbage>
form          size(440,470), caption("Break Beat Cutter"), pluginid("bbct") style("legacy")


groupbox bounds( 0,  0,440,170), text("CUTTER"), plant("cutter"),colour(20,20,20), FontColour(silver){
rslider bounds( 10, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Sub-div."),       channel("subdiv"),  range(1,  512,  8, 1, 1)
rslider bounds( 80, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Bar Length"),     channel("barlen"),  range(1,   16,  2, 1, 1)
rslider bounds(150, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Phrase"),         channel("phrase"),  range(1, 512, 8, 1, 1)
rslider bounds(220, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Repeats"),        channel("repeats"), range(1, 32, 2, 1, 1)
rslider bounds(290, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Stut. Speed"),  channel("stutspd"), range(1, 32, 4, 1, 1)
rslider bounds(360, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Stut. Chance"), channel("stutchnc"), range(0, 1.00, 0.5)
hslider bounds(  5, 95,425, 40), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), textBox(1)    channel("BPM"), range(10,  500, 110,1,1)
label   bounds(198,127, 25, 11), text("BPM"), FontColour("silver")
label  bounds( 10,142, 80,12), text("Clock Source:")
button bounds( 90,140, 60,18), text("Internal","External"), channel("ClockSource"), value(0)
label   bounds(338,158, 100, 10), text("Iain McCurdy [2013]"), FontColour("grey"), align("right")
}



groupbox bounds( 0,170,440,100), text("FILTER"), plant("filter"), FontColour(silver),colour(20,20,20){
rslider bounds( 10, 25, 70, 70), colour(200,100,50,255), trackercolour(200,100,50,255), fontcolour("silver"), text("Mix"),    channel("FltMix"), range(0, 1.00, 0.6)
rslider bounds( 80, 25, 70, 70), colour(200,100,50,255), trackercolour(200,100,50,255), fontcolour("silver"), text("Division"),    channel("fltdiv"), range(1, 16, 1,1,1)
rslider bounds(150, 25, 70, 70), colour(200,100,50,255), trackercolour(200,100,50,255), fontcolour("silver"), text("Bandwidth"),    channel("bw"), range(0.1, 10, 1, 0.5, 0.001)
hslider bounds(220, 25,140, 35), colour(200,100,50,255), trackercolour(200,100,50,255), fontcolour("silver"),    channel("cfmin"), range(50, 10000, 50  ,0.5,0.1)
hslider bounds(220, 50,140, 35), colour(200,100,50,255), trackercolour(200,100,50,255), fontcolour("silver"),    channel("cfmax"), range(50, 10000, 10000,0.5,0.1)
label   bounds(254, 77, 80, 12), text("Cutoff Freq."), FontColour("white")
rslider bounds(360, 25, 70, 70), colour(200,100,50,255), trackercolour(200,100,50,255), fontcolour("silver"), text("Int./S&H"),    channel("i_h"), range(0, 1, 0)
}

groupbox bounds( 0,270,220,100), text("WAVE GUIDE"), plant("waveguide"), FontColour(silver),colour(20,20,20){
rslider bounds( 10, 25, 70, 70), colour(150,150,50,255), trackercolour(150,150,50,255), fontcolour("silver"), text("Chance"),    channel("WguideChnc"), range(0, 1.00, 0.2)
hslider bounds( 80, 25,140, 35), colour(150,150,50,255), trackercolour(150,150,50,255), fontcolour("silver"),    channel("wguidemin"), range(22, 100, 50,1,1)
hslider bounds( 80, 50,140, 35), colour(150,150,50,255), trackercolour(150,150,50,255), fontcolour("silver"),    channel("wguidemax"), range(22, 100, 70,1,1)
label   bounds(108, 77, 85, 12), text("Pitch Range"), FontColour("white")
}

groupbox bounds(220,270,220,100), text("SQUARE MOD."), plant("sqmod"), FontColour(silver),colour(20,20,20){
rslider bounds( 10, 25, 70, 70), colour(200,150,200,255), trackercolour(200,150,200,255), fontcolour("silver"), text("Chance"),    channel("SqModChnc"), range(0, 1.00, 0.2)
hslider bounds( 80, 25,140, 35), colour(200,150,200,255), trackercolour(200,150,200,255), fontcolour("silver"),    channel("sqmodmin"), range(1, 14.0,  6)
hslider bounds( 80, 50,140, 35), colour(200,150,200,255), trackercolour(200,150,200,255), fontcolour("silver"),    channel("sqmodmax"), range(1, 14.0, 12)
label   bounds(108, 77, 85, 12), text("Freq.Range"), FontColour("white")
}

groupbox bounds(0,370,220,100), text("FREQUENCY SHIFT"), plant("fshift"), FontColour(silver),colour(20,20,20){
rslider bounds( 10, 25, 70, 70), colour(250,110,250,255), trackercolour(250,110,250,255), fontcolour("silver"), text("Chance"),    channel("FshiftChnc"), range(0, 1.00, 0.2)
hslider bounds( 80, 25,140, 35), colour(250,110,250,255), trackercolour(250,110,250,255), fontcolour("silver"),    channel("fshiftmin"), range(-4000, 4000,-1000)
hslider bounds( 80, 50,140, 35), colour(250,110,250,255), trackercolour(250,110,250,255), fontcolour("silver"),    channel("fshiftmax"), range(-4000, 4000, 1000)
label   bounds(108, 77, 85, 12), text("Freq.Range"), FontColour("white")
}

groupbox bounds(220,370,220,100), text("OUTPUT"), plant("output"), FontColour(silver),colour(20,20,20){
rslider bounds( 10, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Layers"),       channel("layers"), range(1, 20, 1,1,1)
rslider bounds( 80, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Dry/Wet"),      channel("DryWet"), range(0, 1.00, 0.6)
rslider bounds(150, 25, 70, 70), colour("Tan"), trackercolour("Tan"), fontcolour("silver"), text("Level"),        channel("gain"),   range(0, 1.00, 0.75)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -dm0
</CsOptions>

<CsInstruments>
sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1
seed	0

gisine	ftgen	0,0,131072,10,1

opcode	BBCutIteration,aa,aaiiiiiiiii
 aL,aR,iBPS, isubdiv,  ibarlen,  iphrase, irepeats, istutspd, istutchnc, icount, ilayers	xin
 abbcutL		bbcutm	aL,   iBPS, isubdiv,  ibarlen,  iphrase, irepeats, istutspd, istutchnc
 abbcutR		bbcutm	aR,   iBPS, isubdiv,  ibarlen,  iphrase, irepeats, istutspd, istutchnc
 amixL	=	0
 amixR	=	0
 if icount<ilayers then
   amixL,amixR	BBCutIteration	aL,aR, iBPS, isubdiv,  ibarlen,  iphrase, irepeats, istutspd, istutchnc, icount+1, ilayers
 endif
 xout	abbcutL+amixL,abbcutR+amixL
endop

opcode	FreqShifter,a,aki
	ain,kfshift,ifn	xin					;READ IN INPUT ARGUMENTS
	areal, aimag hilbert ain				;HILBERT OPCODE OUTPUTS TWO PHASE SHIFTED SIGNALS, EACH 90 OUT OF PHASE WITH EACH OTHER
	asin 	oscili       1,    kfshift,     ifn,          0
	acos 	oscili       1,    kfshift,     ifn,          0.25	
	;RING MODULATE EACH SIGNAL USING THE QUADRATURE OSCILLATORS AS MODULATORS
	amod1	=		areal * acos
	amod2	=		aimag * asin	
	;UPSHIFTING OUTPUT
	aFS	= (amod1 - amod2)
		xout	aFS				;SEND AUDIO BACK TO CALLER INSTRUMENT
endop

instr 1	; read widgets
 gksubdiv 	chnget	"subdiv"	; read in widgets
 gkbarlen 	chnget	"barlen"
 gkphrase 	chnget	"phrase"
 gkrepeats	chnget	"repeats"
 gkstutspd	chnget	"stutspd"
 gkstutchnc	chnget	"stutchnc"

 gkClockSource	chnget	"ClockSource"
 if gkClockSource==0 then
  gkBPM    	chnget	"BPM"
 else
  gkBPM    	chnget	"HOST_BPM"
  gkBPM		limit	gkBPM, 10,500	
 endif

 gkfltdiv	chnget	"fltdiv"
 gkDryWet    	chnget	"DryWet"
 gkFltMix 	chnget	"FltMix"
 gkbw     	chnget	"bw"
 gkcfmin  	chnget	"cfmin"
 gkcfmax  	chnget	"cfmax"
 gki_h    	chnget	"i_h"
 gklayers    	chnget	"layers"
 gkgain		chnget	"gain"
 konoff		chnget	"onoff"
endin

instr	2
 kmetro		metro		4
 kSwitch	init	0
 if kmetro==1 then
  kSwitch	changed		gkBPM, gkrepeats, gkphrase, gkstutspd, gkstutchnc, gkbarlen, gksubdiv, gkfltdiv, gklayers	;GENERATE A MOMENTARY '1' PULSE IN OUTPUT 'kSwitch' IF ANY OF THE SCANNED INPUT VARIABLES CHANGE. (OUTPUT 'kSwitch' IS NORMALLY ZERO)
 endif
 if	kSwitch==1	then		;IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
 	reinit	UPDATE			;BEGIN A REINITIALISATION PASS FROM LABEL 'UPDATE'
 endif
 UPDATE:

 /* INPUT */
 aL,aR ins					; live input

;;;;  use a loop sound file for testing
;#define SOUNDFILE	#"loop.wav"#		; macro
; ilen	filelen	$SOUNDFILE			; length of sound file
; ibeats =	8				; number of beats in the drum loop
; ispd	=	(ilen/ibeats) * (i(gkBPM)/60)	; speed ratio for this sample to sync with master clock
; aL	diskin	$SOUNDFILE,ispd,0,1		; read sound file
; aR	=	aL				; right channel same as left

 iBPS	=	i(gkBPM)/60
 kmetro	metro	iBPS		; metronome used for triggering random parameter changes
 
 ; call UDO
 ;OUTPUT		OPCODE	        INPUT |   BPM      | SUBDIVISION | BAR_LENGTH | PHRASE_LENGTH | NUM.OF_REPEATS | STUTTER_SPEED | STUTTER_CHANCE	
 abbcutL,abbcutR	BBCutIteration	aL,aR, i(gkBPM)/60, i(gksubdiv),  i(gkbarlen),   i(gkphrase),    i(gkrepeats),   i(gkstutspd),   i(gkstutchnc),  1, i(gklayers)
 
 ;FILTER=================================================================================================================================================================
 ifreq	=	iBPS * i(gkfltdiv)			; FREQUENCY WITH WHICH NEW FILTER CUTOFF VALUES ARE GENERATED
 
 kcf1h		randomh	gkcfmin, gkcfmax, ifreq		; sample and hold random frequency values
 kcf1i		lineto	kcf1h, 1/ifreq			; interpolate values
 kcf1		ntrpol	kcf1i, kcf1h, gki_h   		; crossfade between interpolating and sample and hold type random values
 abbFltL	resonz	abbcutL, kcf1, kcf1*gkbw, 2	; band-pass filter
 abbMixL	ntrpol	abbcutL, abbFltL, gkFltMix	; crossfade between unfiltered and filter audio signal
 kcf2h		randomh	gkcfmin, gkcfmax, ifreq		;   RIGHT CHANNEL
 kcf2i		lineto	kcf2h, 1/ifreq			; 
 kcf2		ntrpol	kcf2i, kcf2h, gki_h   		; 
 abbFltR	resonz	abbcutR, kcf2, kcf2*gkbw, 2	; 
 abbMixR	ntrpol	abbcutR, abbFltR, gkFltMix	; 
 ;=======================================================================================================================================================================

 ;WGUIDE1================================================================================================================================================================
 kchance	chnget	"WguideChnc"
 kdice		trandom	kmetro,0,1
 if kdice<kchance then
  kwguidemin	chnget	"wguidemin"
  kwguidemax	chnget	"wguidemax"
  knum		randomh	kwguidemin,kwguidemax,iBPS
  afrq		interp	cpsmidinn(int(knum))
  kfb		randomi	0.8,0.99,iBPS/4
  kcf		randomi	800,4000,iBPS
  abbMixL	wguide1	abbMixL*0.7,afrq,kcf,kfb
  abbMixR	wguide1	abbMixR*0.7,afrq,kcf,kfb
 endif  
 ;=======================================================================================================================================================================

 ;SQUARE MOD==============================================================================================================================================================
 kchance	chnget	"SqModChnc"			; read in widgets
 ksqmodmin	chnget	"sqmodmin"			;
 ksqmodmax	chnget	"sqmodmax"			; 
 kDiceRoll	trandom	kmetro,0,1			; new 'roll of the dice' upon each new time period
 if kDiceRoll<kchance then				; if 'roll of the dice' is within chance boundary... 
  kratei	randomi	ksqmodmin,ksqmodmax,iBPS	; interpolating random function for modulating waveform frequency
  krateh	randomh	ksqmodmin,ksqmodmax,iBPS	; sample and hold random function for modulating waveform frequency
  kcross	randomi	0,1,iBPS			; crossfader for morphing between interpolating and S&H functions
  krate		ntrpol	kratei,krateh,kcross		; create crossfaded rate function
  amod		lfo	1,cpsoct(krate),2		; modulating waveform (square waveform)
  kcf		limit	cpsoct(krate)*4,20,sr/3		; cutoff freq for filtering some of the high freq. content of the square wave
  amod		clfilt	amod,kcf,0,2			; low-pass filter square wave
  abbMixL	=	abbMixL*amod			; ring modulate audio
  abbMixR	=	abbMixR*amod			;
 endif
 ;=======================================================================================================================================================================

 ;FSHIFT=================================================================================================================================================================
 kchance	chnget	"FshiftChnc"			; read in widgets                         
 kdice		trandom	kmetro,0,1			; new 'roll of the dice' upon each new time period                                                                         
 if kdice<kchance then					; if 'roll of the dice' is within chance boundary...                                                                           
  kfshiftmin	chnget	"fshiftmin"                     ; read in widgets                           
  kfshiftmax	chnget	"fshiftmax"			; 
  kfsfrqi	randomi	kfshiftmin,kfshiftmax,iBPS*2	; interpolating random function for modulating waveform frequency          
  kfsfrqh	randomh	kfshiftmin,kfshiftmax,iBPS*2	; sample and hold random function for modulating waveform frequency            
  kcross	randomi	0,1,iBPS*2			; crossfader for morphing between interpolating and S&H functions          
  kfsfrq	ntrpol	kfsfrqi,kfsfrqh,kcross          ; create crossfaded rate function  modulating waveform (square waveform)
  abbMixL	FreqShifter	abbMixL,kfsfrq,gisine   ;                                                 
  abbMixR	FreqShifter	abbMixR,kfsfrq,gisine   ;                                                         
 endif                                                  ;                                                                            
 ;=======================================================================================================================================================================

 rireturn						; RETURN FROM REINITIALISATION PASS TO PERFORMANCE TIME PASSES
 
 amixL	sum	aL*(1-gkDryWet), abbMixL*gkDryWet	;SUM AND MIX DRY SIGNAL AND BBCUT SIGNAL (LEFT CHANNEL)
 amixR	sum	aR*(1-gkDryWet), abbMixR*gkDryWet	;SUM AND MIX DRY SIGNAL AND BBCUT SIGNAL (RIGHT CHANNEL)




 outs	amixL*gkgain, amixR*gkgain			;SEND AUDIO TO OUTPUTS
endin

</CsInstruments>  
<CsScore>
i1 0 36000
i2 0 36000
</CsScore>
</CsoundSynthesizer>; CrossedDelays.csd
; Written by Iain McCurdy, 2016

; This effect implements a dual delay effect in which the feedbacks between the two channels are crossed over.
; This becomes particularly useful when we add in separate ring modulators or frequency shifters on each channel.

; It is intended that the delays will be used in a coherent rhythmic function therefore delay times are set by means of a tempo control 
;  (either by the Cabbage widget or from a host) and subsequent subdivisions for each channel.
; An assumption is made that the base time signature 4/4, therefore a tempo of 60 bpm with divisions of 1/4 will result in delays of 1 second

; Feedback can be greater than a ratio of 1 without overloading occuring, this is on account of the gain reducing effect of ring modulating.
; Nonetheless a BDJ clip is activated if feedback is raised above 1 to protect against samples out of range is feedback is pushed even further.
; It should be born in mind that feeding back ring modulators can produce aliasing artefacts - in this context they are regarded as a characteristic of the effect.

; --LEFT_INPUT---+---DELAY_1----MOD_1---+---OUT_1--->
;                 \                    /
;                  \ /----[F.BACK]----/
;                   X
;                  / \----[F.BACK]----\
;                 /                    \
; --RIGHT_INPUT--+---DELAY_2----MOD_2---+---OUT_2--->

; Controls
; --------
;  [DELAYS]
; Clock Source	-	tempo source can be from the built-in 'Tempo' control or from the host's tempo, if used as a VST plugin
; Tempo			-	Cabbage defined tempo used in defining actual delay times (in conjunction with subdivision values)
; Mix			-	dry/wet mix for the effect
; Feedback		-	delay feedback. Caution: this can be set above 100%, feedback will be attenuated by ring modulation (not frequency shifting),
; 					 but if feedback is greater than '1', soft clipping will be applied to protect against samples out of range
; Subdiv.1/Subdiv.2	-	metrical subdivisionsof the two delay times

;  [MODULATION]
; Type			-	choose between ring modulation and frequency shifting
; Freq.1/Freq.2	-	the frequencies of the ring modulators or frequency shifters

;  [OUTPUT]
; Pan1/Pan2 	-	pan locations of the outputs of the two delays (OUT_1 and OUT_2 in the diagram above)
; Level			-	output level (dry and wet signals)

<Cabbage>
form caption("Crossed Delays") size(815, 130), pluginid("CrDl") style("legacy")


image   bounds(  5,  5,370,120), outlinethickness(1), outlinecolour("white"), colour("black"), plant("Delays_Plant")
{
label    bounds(  0,  4,370, 12), text("D E L A Y S")
label    bounds(  5, 20, 80, 12), text("Clock Source")
combobox bounds(  5, 35, 80, 20), channel("ClockSource"), text("Cabbage","Host")
rslider  bounds( 75, 20, 90, 90), text("Tempo"), channel("Tempo"), valuetextbox(1), textbox(1), range(20,500,60,1,0.1)
rslider  bounds(140, 20, 90, 90), text("Mix"), channel("Mix"), valuetextbox(1), textbox(1), range(0,1,0.5,1,0.01)
rslider  bounds(205, 20, 90, 90), text("Feedback"), channel("Feedback"), valuetextbox(1), textbox(1), range(0,3,0.5,1,0.01)
label    bounds(285, 20, 70, 13), text("Subdiv.1")
combobox bounds(285, 33, 70, 20), channel("Div1"), text("1/1","1/2","1/3","1/4","1/6","1/8","1/12","1/16","1/24","1/32","1/48","1/64","1/96","1/128"), value(4)
label    bounds(285, 60, 70, 13), text("Subdiv.2")
combobox bounds(285, 73, 70, 20), channel("Div2"), text("1/1","1/2","1/3","1/4","1/6","1/8","1/12","1/16","1/24","1/32","1/48","1/64","1/96","1/128"), value(3)
}

image   bounds(380,  5,225,120), outlinethickness(1), outlinecolour("white"), colour("black"), plant("RM_Plant")
{
label    bounds(  0,  4,225, 12), text("M O D U L A T I O N")
label    bounds(  5, 55, 80, 12), text("Type")
combobox bounds(  5, 70, 80, 20), channel("ModType"), text("Ring Mod.","Freq.Shift"), value(2)
checkbox bounds(  5, 30,120, 12), text("On/Off"), channel("ModOnOff"), value(1)
rslider  bounds( 75, 20, 90, 90), text("Freq.1"), channel("Freq1"), valuetextbox(1), textbox(1), range(-6000,6000,200,1,1)
rslider  bounds(140, 20, 90, 90), text("Freq.2"), channel("Freq2"), valuetextbox(1), textbox(1), range(-6000,6000,333,1,1)
}

image   bounds(610,  5,200,120), outlinethickness(1), outlinecolour("white"), colour("black"), plant("Output_Plant")
{
label    bounds(  0,  4,200, 12), text("O U T P U T")
rslider  bounds(-10, 20, 90, 90), text("Pan 1"), channel("Pan1"), valuetextbox(1), textbox(1), range(0,1,0)
rslider  bounds( 55, 20, 90, 90), text("Pan 2"), channel("Pan2"), valuetextbox(1), textbox(1), range(0,1,1)
rslider  bounds(120, 20, 90, 90), text("Level"), channel("Level"), valuetextbox(1), textbox(1), range(0,1,1)
}

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -d -+rtmidi=NULL -M0 -m0d 
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 16
nchnls = 2
0dbfs = 1

gkDivs[]	fillarray	1,2,3,4,6,8,12,16,24,32,48,64,96,128

opcode	FreqShifterSimple,a,aki					; SIMPLE FREQUENCY SHIFTER
	asig,kfshift,ifn	xin				; READ IN INPUT ARGUMENTS
	areal, aimag hilbert asig				; HILBERT OPCODE OUTPUTS TWO PHASE SHIFTED SIGNALS, EACH 90 OUT OF PHASE WITH EACH OTHER
	asin 	oscili       1,    kfshift,     ifn,          0
	acos 	oscili       1,    kfshift,     ifn,          0.25	
	;RING MODULATE EACH SIGNAL USING THE QUADRATURE OSCILLATORS AS MODULATORS
	amod1	=		areal * acos
	amod2	=		aimag * asin	
	;UPSHIFTING OUTPUT
	ares	= (amod1 - amod2)				; MIX OUTPUTS (INVERTED WITH RESPECT TO EACH OTHER)
		xout	ares					; SEND AUDIO BACK TO CALLER INSTRUMENT
endop

gisine	ftgen	0,0,131072,10,1

instr	1
; aSig		diskin2	"808loopMono.wav",1,0,1
; ilen		filelen	"808loopMono.wav"
; klen		init	ilen

 kbpm		chnget	"HOST_BPM"
 kClockSource	chnget	"ClockSource"
 kClockSource	init	1
 if kClockSource==1 then				;if internal clock source has been chosen...
  ktempo	chnget	"Tempo"				;tempo taken from GUI knob control
 else
  ktempo	chnget	"bpm"				;tempo taken from host BPM
  ktempo	limit	ktempo,20,500		;limit range of possible tempo values. i.e. a tempo of zero would result in a delay time of infinity.
 endif

 aL,aR		ins
 klen		=		60*2/ktempo

 kMix		chnget	"Mix" 
 kFeedback	chnget	"Feedback"
 kModOnOff	chnget	"ModOnOff"
 kFreq1		chnget	"Freq1"
 kFreq2		chnget	"Freq2" 
 kDiv1		chnget	"Div1"
 kDiv2		chnget	"Div2"
 kModType	chnget	"ModType"
 
 aTap1,aTap2	init	0
 
 aBuf		delayr	60*2/20
 aTap1		deltapi	klen/gkDivs[kDiv1]
 aMod1		poscil	1,kFreq1
 if kModOnOff==1 then
  if kModType==1 then
   aTap1		*=		aMod1
  else
   aTap1		FreqShifterSimple	aTap1,kFreq1,gisine
  endif
 endif
 			delayw	aL + (aTap2 * kFeedback)
 
 aBuf		delayr	60*2/20
 aTap2		deltapi	klen/gkDivs[kDiv2]
 aMod2		poscil	1,kFreq2
 if kModOnOff==1 then
  if kModType==1 then
   aTap2		*=		aMod2
  else
   aTap2		FreqShifterSimple	aTap2,kFreq2,gisine
  endif                                               
 endif
 			delayw	aR + (aTap1 * kFeedback)
 
 if kFeedback>1 then
  aTap1 clip 	aTap1, 0, 0dbfs, 0dbfs
  aTap2 clip 	aTap2, 0, 0dbfs, 0dbfs
 endif

 kPan1		chnget	"Pan1"
 kPan2		chnget	"Pan2"
 kLevel		chnget	"Level"
 			
 aMixL		ntrpol	aL, aTap1*(1-kPan1) + aTap2*(1-kPan2), kMix
 aMixR		ntrpol	aR, aTap1*kPan1 + aTap2*kPan2, kMix
			outs	aMixL*kLevel, aMixR*kLevel
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7] 
</CsScore>

</CsoundSynthesizer>
; DelayGrain.csd
; Iain McCurdy, 2013
; 
; CONTROLS
; --------
; Grain Size		--	range of possible grain sizes (in seconds)
; Density			--	grain density in grains per second (note that the addition of delay will disrupt the regularity of grains)
; Delay			--	range of delay times possible (in seconds)
; Transpose		--	range of transpositions (in semitones)
; Spread			--	random panning spread of grains
; Amplitude Decay		--	the larger this value, the more grains are delayed, the more their amplitudes will be lowered
; Reversal Proability	--	probability of material within the grains being played backwards: 0 = all forwards
; 			                                                                          1 = all backwards
; 			                                                                          0.5 = 50:50
; 			        reversal might be hard to hear unless grain size is large
; Mix			--	dry/wet mix
; Level			--	output level (both dry and wet)
; Grain Env.		--	sets the amplitude enveloping window for each grain
; 				Hanning: natural sounding soft attack, soft decay envelope
; 				Half-sine: like the hanning but with a slightly sharper attack and decay
; 				Decay 1: a percussive decay envelope with linear segments
; 				Decay 2: a percussive decay envelope with a exponential decay segment. Probably more natural sounding than 'Decay 1' but longer grain sizes may be necessary
; 				Gate: sharp attack and decay. Rather synthetic sounding.
; Delay Distr.		--	random delay time distribution: exponential, linear or logarithmic. Effect are quite subtle but exponential might be most natural sounding.

<Cabbage>
form caption("Delay Grain") size(410, 520), pluginid("DGrn") style("legacy")

;hslider2 bounds(  5,  5, 400, 30), channel("GSize1","GSize2"), min(0.01), max(0.09)    range(0.005, 2, 0.01, 0.5, 0.0001)
hrange   bounds(  5,  5, 400, 30), channel("GSize1","GSize2"), range(0.005, 2, 0.01:0.09, 0.5, 0.0001)
label    bounds(161, 29,  90, 11), text("G R A I N   S I Z E"), fontcolour(105,105,255)

hslider  bounds(  5, 50, 400, 25), channel("Dens"), range(0.2, 2000, 50,0.5,0.001)
label    bounds(172, 69,  65, 11), text("D E N S I T Y"), fontcolour(105,105,255)

;hslider2 bounds(  5, 90, 400, 30), channel("Dly1","Dly2"), min(0.01), max(0.5)    range(0, 5, 0.01, 0.5, 0.0001)
hrange   bounds(  5,  90, 400, 30), channel("Dly1","Dly2"), range(0, 5, 0.01:0.5, 0.5, 0.0001)
label    bounds(180,114,  50, 11), text("D E L A Y"), fontcolour(105,105,255)

;hslider2 bounds(  5,140, 400, 30), channel("Trns1","Trns2"), min(0), max(0)    range(-12, 12, 0, 1, 0.001)
hrange   bounds(  5, 140, 400, 30), channel("Trns1","Trns2"), range(-12, 12, 0:0, 1, 0.001)
label    bounds(162,164,  88, 11), text("T R A N S P O S E"), fontcolour(105,105,255)

hslider  bounds(  5,195, 400, 25), channel("PanSpread"), range(0, 1.00, 0.5,1,0.001)
label    bounds(158,214,  95, 11), text("P A N   S P R E A D"), fontcolour(105,105,255)

hslider  bounds(  5,240, 400, 25), channel("AmpSpread"), range(0, 1.00, 0.5,1,0.001)
label    bounds(158,259,  95, 11), text("A M P   S P R E A D"), fontcolour(105,105,255)

hslider  bounds(  5,280, 400, 25), channel("FiltSpread"), range(0, 1.00, 0.5,1,0.001)
label    bounds(147,299, 120, 11), text("F I L T E R   S P R E A D"), fontcolour(105,105,255)

hslider  bounds(  5,320, 400, 25), channel("ampdecay"), range(0, 1.00, 0.5,1,0.001)
label    bounds(131,339, 150, 11), text("A M P L I T U D E   D E C A Y"), fontcolour(105,105,255)

hslider  bounds(  5,360, 400, 25), channel("reverse"), range(0, 1.00, 0,1,0.001)
label    bounds(112,379, 190, 11), text("R E V E R S A L   P R O B A B I L I T Y"), fontcolour(105,105,255)

hslider  bounds(  5,400, 400, 25), channel("mix"), range(0, 1.00, 1,1,0.001)
label    bounds(189,419,  30, 11), text("M I X"), fontcolour(105,105,255)

hslider  bounds(  5,440, 400, 25), channel("level"), range(0, 2.00, 1, 0.5, 0.001)
label    bounds(180,459,  50, 11), text("L E V E L"), fontcolour(105,105,255)

label    bounds( 19,475,  70, 11), text("GRAIN ENV."), fontcolour(105,105,255)
combobox bounds( 10,486,  90, 17), channel("window"), value(1), text("Hanning","Half Sine","Decay 1","Decay 2","Gate")

label    bounds(117,475,  75, 11), text("DELAY DISTR."), fontcolour(105,105,255)
combobox bounds(110,486,  90, 17), channel("DlyDst"), value(1), text("Exp.","Lin.","Log")

label    bounds(  5,508, 160, 11), text("Author: Iain McCurdy |2013|"), FontColour("grey")
</Cabbage>

<CsoundSynthesizer>
<CsOptions>
-dm0 -n
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;Author: Iain McCurdy (2013)

; window functions
giwfn1	ftgen	0,  0, 131072,  9,   .5, 1, 	0 				; HALF SINE
giwfn2	ftgen	0,  0, 131072,  7,    0, 3072,  1, 128000,     0		; PERCUSSIVE - STRAIGHT SEGMENTS
giwfn3	ftgen	0,  0, 131072, 16,    0, 3072,0,1, 128000,-2,  0		; PERCUSSIVE - EXPONENTIAL SEGMENTS
giwfn4	ftgen	0,  0, 131072,  7,     0, 3536,  1, 124000,     1, 3536, 0	; GATE - WITH ANTI-CLICK RAMP UP AND RAMP DOWN SEGMENTS
giwfn5	ftgen	0,  0, 131072,  7,    0, 128000,1, 3072,       0		; REVERSE PERCUSSIVE - STRAIGHT SEGMENTS
giwfn6	ftgen	0,  0, 131072,  5, .001, 128000,1, 3072,   0.001		; REVERSE PERCUSSIVE - EXPONENTIAL SEGMENTS
giwfn7	ftgen	0,  0, 131072,  20,   2, 1					; HANNING WINDOW
giwindows	ftgen	0,0,8,-2,giwfn7,giwfn1,giwfn2,giwfn3,giwfn4

giBufL	ftgen	0,0,1048576,-2,0	; function table used for storing audio
giBufR	ftgen	0,0,1048576,-2,0	; function table used for storing audio

gigaussian	ftgen	0,0,4096,20,6,1,1	; a gaussian distribution

gaGMixL,gaGMixR	init	0	; initialise stereo grain signal

	instr	1			; grain triggering instrument
kGSize1	chnget	"GSize1"		; grain size limit 1
kGSize2	chnget	"GSize2"		; grain size limit 2
kDens	chnget	"Dens"			; grain density
kDly1	chnget	"Dly1"			; delay time limit 1
kDly2	chnget	"Dly2"                  ; delay time limit 2
kTrns1	chnget	"Trns1"			; transposition in semitones
kTrns2	chnget	"Trns2"
kPanSpread	chnget	"PanSpread"	; random panning spread
kAmpSpread	chnget	"AmpSpread"	; random amplitude spread
kFiltSpread	chnget	"FiltSpread"	; random filter spread
kreverse	chnget	"reverse"	; reversal probability
kampdecay	chnget	"ampdecay"	; amount of delay->amplitude attenuation
kwindow	chnget	"window"		; window
kDlyDst	chnget	"DlyDst"		; delay time distribution
kmix	chnget	"mix"			; dry/wet mix
klevel	chnget	"level"			; output level (both dry and wet signals)

aL, aR	ins				; read audio input
	outs	aL*klevel*(1-kmix),aR*klevel*(1-kmix)

/* WRITE TO BUFFER TABLES */
ilen	=	ftlen(giBufL)		; table length (in samples)
aptr	phasor	sr/ilen			; phase pointer used to write to table
aptr	=	aptr*ilen		; rescale pointer according to table size
	tablew	aL, aptr, giBufL	; write audio to table
	tablew	aR, aptr, giBufR	; write audio to table
kptr	downsamp	aptr		; downsamp pointer to k-rate

ktrig		metro	kDens		; grain trigger

/* GRAIN SIZE */
kGSize		random	0,1		; random value 0 - 1
;kGSize	expcurve	kGSize,50	; exponentially redistribute range 0 - 1
kMinGSize	min	kGSize1,kGSize2	; find minimum grain size limit
kMaxGSize	max	kGSize1,kGSize2	; find maximum grain size limit
kGSize		scale	kGSize,kMaxGSize,kMinGSize	; rescale random value according to minimum and maximum limits

/* DELAY TIME */
kDly	random	0,1			; uniform random value 0 - 1
if kDlyDst=1 then			; if delay time distribution is exponential
 kDly	expcurve	kDly,100	; exponential distrubution range 0 - 1
elseif kDlyDst=3 then			; .. or if logarithmic
 kDly	logcurve	kDly,100	; exponential distrubution range 0 - 1
endif					; (other linear so do not alter)
if kDly1=kDly2 then
 kMinDly	=	kDly1		; delays can't be the same value!!	 
 kMaxDly	=	kDly2+0.001
else	
 kMinDly	min	kDly1,kDly2		; find minimum delay time limit
 kMaxDly	max	kDly1,kDly2		; find maximum delay time limit
endif

ioffset	=	1/sr			; delay offset (can't read at same location as write pointer!)
kDly	scale		kDly,kMaxDly,kMinDly; distribution rescaled to match the user defined limits

/* CALL GRAIN */
;		          p1 p2         p3     p4   p5         p6       p7   p8              p9             p10       p11         p12     p13        p14         p15    p16
schedkwhen	ktrig,0,0,2,kDly+0.0001,kGSize,kptr,kPanSpread,kreverse,kDly,kMinDly+ioffset,kMaxDly+0.0001,kampdecay,klevel*kmix,kwindow,kAmpSpread,kFiltSpread,kTrns1,kTrns2	; call grain instrument
	endin

instr	2				; grain instrument
iGStart	=	p4			; grain start position (in samples)
ispread	=	p5			; random panning spread
ireverse=	(rnd(1)>p6?1:-1)	; decide fwd/bwd status
iwindow	table	p12-1,giwindows		; amplitude envelope shape for this grain

/* AMPLITUDE CONTROL */
idly	=	p7					; delay time
iMinDly	=	p8					; minimum delay
iMaxDly	=	p9					; maximum delay
iampdecay=	p10					; amount of delaytime->amplitude attenuation
ilevel	=	p11					; grain output level
iAmpSpread	=	p13
iFiltSpread	=	p14

iRto	divz	idly-iMinDly , iMaxDly-iMinDly, 0	; create delay:amplitude ration (safely)
iamp	=	(1 - iRto) ^ 2				; invert range
iamp	ntrpol	1,iamp,iampdecay			; mix flat amplitude to scaled amplitude according to user setting
iRndAmp	random	1-iAmpSpread, 1				; random amplitude value for this grain
iamp	=	iamp*iRndAmp				; apply random amplitude

/* TRANSPOSITION */
iTrns	random	p15,p16
iRto	=	semitone(iTrns)
if iRto>1 then
 iStrtOS	=	(iRto-1)  * sr * p3
else
 iStrtOS	=	0
endif

aline	line	iGStart-iStrtOS,p3,iGStart-iStrtOS+(p3*iRto*sr*ireverse)	; grain pointer
aenv	oscili	iamp,1/p3,iwindow			; amplitude envelope
aL	tablei	aline,giBufL,0,0,1			; read audio from table 
aR	tablei	aline,giBufR,0,0,1			; read audio from table

if iFiltSpread>0 then
 iRndCfOct	random	14-(iFiltSpread*10),14
 iRndCf		=	cpsoct(iRndCfOct)
 aL		butlp	aL,iRndCf
 aR		butlp	aR,iRndCf
endif


ipan	random	0.5-(ispread*0.5),0.5+(ispread*0.5)	; random pan position for this grain
gaGMixL	=	gaGMixL + (aL*aenv*ipan*ilevel)		; left channel mix added to global variable
gaGMixR	=	gaGMixR + (aR*aenv*(1-ipan)*ilevel)	; right channel mix added to global variable
endin

instr	3						; output instrument (always on)
	outs	gaGMixL,gaGMixR				; send global audio signals to output
	clear	gaGMixL,gaGMixR				; clear global audio variables
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]	; read audio, write to buffers, call grains.
i 3 0 [60*60*24*7]	; output
</CsScore>

</CsoundSynthesizer>; LiveSndwarp.csd
; Iain McCurdy (2012)
; 
; Description and Instructions
; ----------------------------
; 
; This instrument implements live granulation of an audio input stream using the sndwarp opcode.                         
; 
; Live audio from the first input channel (left input if stereo) is written into a function table from which sndwarp reads 
; audio. (If 'stereo in/out' is chosen from 'In/Out Mode' then audio from the second/right channel is written into a second 
; table.) The key is that manual pointer read mode is used with sndwarp (as opposed to time-stretch mode) and that the read 
; pointer follows on behind the pointer which is used to write audio into the function table(s). Some care is needed to ensure 
; that the read pointer does not 'overtake' the write pointer (which would result in dicontinuities in the audio it reads). 
; This could be possible if pitch transposition upwards of grains is used as the grain pointer is then moving faster than the 
; write pointer. This example prevents this from happening internally so the user does not need to worry. The user can also 
; define a random offset for the grain read pointer using the 'Grain Delay' settings. Delay times are randomly chosen 
; according to a 'betarand' distribution the 'beta' of which the user can set: if distribution shape is 1 the distribution is 
; uniform, if it is 2 the distribution is linear and beyond 2 it is increasingly exponential.
; 
; Note that 'Size' (grain size) and 'Size Rnd.' (random grain size) are i-rate variables so that changing them requires 
; reinitialisation in the orchestra. For this reason discontinuity in the audio output can be heard when they are modified.
; Grain Size and Size Random (bandwith) are in sample frames. Divide by sample rate to derive a value in seconds.
; 
; Pitch transposition can be set using either the 'Pitch' knob (ratio multiplier) or 'Semis' (transposition in semitones).
; Changes made to 'Semis' will be reflected in the setting of the 'Pitch' knob, but not vice versa.
; Pitch can also be controlled through MIDI input (in which case 'Pitch' and 'Semis' will be ignored). Using MIDI will 
; polyphony will be possible. If you intend to use MIDI to start and stop sndwarp instances, turn 'On/Off [MIDI]' off.
; You can also adjust the MIDI note at which unison (no transposition) will occur using the 'Uni.Note' knob.
; 
; Sound output from sndwarp can be fed back into the input to be mixed with the live audio in. The amount of feedback can be 
; controlled using the 'Feedback' slider. Using high levels of feedback can result in overloading but this will also be 
; dependent upon other factors such as random delay time, grain size (window size), density and transposition so user caution 
; is advised. If the 'clip' button is activated the feedback signal will be clipped at the clip level set (a ratio of then 
; maximum amplitude) providing at least some control over a runaway feedback loop. Note that 'Clip Lev.' defines the amplitude 
; at which clipping begins, therefore lower settings will result in the signal being clipped sooner. The feedback signal can 
; also be filtered by a lowpass filter.
; 
; If 'balance' is activated the output of sndwarp is dynamically balanced with the input signal. This can be useful for 
; compensating for increases in amplitude caused when 'Number of Overlaps' (grain density) is increased. There are 3 
; mono/stereo modes: 'mono in - mono out (x2)', 'mono in - stereo out' (stereo effect is created using sndwarp's built-in 
; window/grain size randomisation, and 'stereo in - stereo out' mode.
; 
; The buffer size used in the example is just under 23 seconds long (function table size 1048576 at sr=44100). This could be 
; enlarged if required but bear in mind that sndwarp needs a power of two table size.        
; 
; Activating 'Freeze' will pause writing of live audio to the function table and allow the user to manually navigate through 
; the buffered audio. The feedback loop will also be deactivated when 'freeze' is active.

<Cabbage>
form caption("Live Sndwarp") size(530, 495), pluginid("lwrp") style("legacy")

groupbox bounds(  0,  0, 300,100), text("Master"), colour(30, 30, 40), fontcolour(255,125,125), plant("Master")
{
checkbox bounds( 10, 28, 110, 20), colour("yellow"), channel("OnOff"),  value(1), text("On/Off [MIDI]"), trackercolour("red")
label    bounds( 22, 53,  80, 13), text("In/Out Mode")
combobox bounds( 10, 69, 100, 20), channel("monostereo"), value(2), text("mono","stereo out","stereo in/out")
rslider  bounds(115, 30,  60, 60), text("In Gain"),  channel("InGain"), range(0, 2.00, 1, 0.5), colour( 67, 99, 99), trackercolour(207,239,239)
rslider  bounds(175, 30,  60, 60), text("Out Gain"), channel("amp"),    range(0, 2.00, 1, 0.5), colour( 67, 99, 99), trackercolour(207,239,239)
rslider  bounds(235, 30,  60, 60), text("Mix"),      channel("mix"),    range(0, 1.00, 1),      colour( 67, 99, 99), trackercolour(207,239,239)
}

groupbox bounds(300,  0, 230,100), text("Feedback - CAUTION!"), colour(25, 25, 35), fontcolour(250,120,120), plant("Feedback")
{
rslider  bounds(  5, 30,  60, 60), text("Amount"), channel("feedback"), range(0, 1.00, 0), colour( 67, 99, 99), trackercolour(207,239,239)
checkbox bounds( 65, 35,  70, 20), colour("yellow"), channel("clip"),  value(1), text("Clip"), trackercolour("red")
checkbox bounds( 65, 65,  70, 20), colour("yellow"), channel("LPF_On"),  value(0), text("LPF"), trackercolour("red")
rslider  bounds(110, 30,  60, 60), text("Clip Lev."), channel("ClipLev"), range(0.01, 1, 0.5, 0.5), colour( 67, 99, 99), trackercolour(207,239,239)
rslider  bounds(165, 30,  60, 60), text("LPF"), channel("Cutoff"), range(20, 20000,  4000, 0.5), colour( 67, 99, 99), trackercolour(207,239,239)
}

groupbox bounds(  0,100, 530,100), text("Grains"), colour(35, 35, 45), fontcolour(255,130,130), plant("Grains")
{
rslider  bounds(  5, 30,  60, 60), text("Size"), channel("wsize"), range(1, 88200, 7000, 0.25, 1), colour( 67, 99, 99), trackercolour(207,239,239)
rslider  bounds( 65, 30,  60, 60), text("Size Rnd."), channel("rnd"), range(0, 30000, 1000, 0.375, 1), colour( 67, 99, 99), trackercolour(207,239,239)
rslider  bounds(125, 30,  60, 60), text("Pitch"), channel("pch"), range(0.01, 8, 1, 0.5), colour( 67, 99, 99), trackercolour(207,239,239)
rslider  bounds(185, 30,  60, 60), text("Semis"), channel("semis"), range(-48, 48, 0,1,1), colour( 67, 99, 99), trackercolour(207,239,239)
rslider  bounds(245, 30,  60, 60), text("Density"), channel("olaps"), range(1, 100, 10, 1, 1), colour( 67, 99, 99), trackercolour(207,239,239)
label    bounds(305, 25, 100, 13), text("Grain Envelope")
combobox bounds(305, 41, 100, 20), channel("wfn"), value(1), text("Half Sine","Perc. 1","Perc. 2","Gate","Rev. Perc. 1 ","Rev. Perc. 2")
checkbox bounds(315, 70, 100, 20), colour("yellow"), channel("balance"),  value(0), text("Balance")
rslider  bounds(405, 30,  60, 60), text("Delay"), channel("dly"), range(0, 5, 0.01, 0.5), colour( 67, 99, 99), trackercolour(207,239,239)
rslider  bounds(465, 30,  60, 60), text("Distr."), channel("beta"), range(1, 16.0, 1, 0.5), colour( 67, 99, 99), trackercolour(207,239,239)
}

groupbox bounds(  0,200,530,165), text("Freeze"), colour(45, 45, 55), fontcolour(255,100,100), plant("Freeze")
{
button   bounds( 10, 25, 80, 20), fontcolour:0(50,50,100), fontcolour:1(205,205,255), colour:0(0,0,10), colour:1(100,100,150), channel("freeze"), text("FREEZE","FREEZE"),  value(0)
hslider  bounds( 90, 29,430, 10), text("Port.Time"), channel("ManPtrPort"), range(0, 1.00, 0.5), colour( 67, 99, 99), trackercolour(207,239,239)
gentable bounds( 10, 50,510, 80), tablenumber(1), tablecolour("lime"), amprange(-1,1,1), identchannel(table), zoom(-1), fill(0)
image    bounds(518, 50,  2, 80), colour(200,200,200,100), identchannel("wiper")
hslider  bounds(  5,132,522, 11), channel("ManPtr"), range(-1.00, 0, 0, 1, 0.001), colour( 67, 99, 99), trackercolour(207,239,239)
label    bounds(220,145,100, 13), text("Manual Pointer")
}

groupbox bounds(  0,365,530,100), text("MIDI"), colour(30, 30, 40), fontcolour(255,100,100), plant("MIDI")
{
rslider  bounds( 10, 35, 60, 60), text("Uni.Note"), channel("UniNote"), range(0, 127, 72,1,1), colour( 67, 99, 99), trackercolour(207,239,239)
keyboard bounds( 80,  0,450,100)
}
image bounds( 5, 470, 215, 20), colour(75, 85, 90, 100), plant("credit"), outlinethickness(0){
label bounds( 3,   3, 210, 14), text("Author: Iain McCurdy |2012|"), fontcolour("white")
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1
massign	0,2

giview		ftgen	1, 0, 512, 2, 0		; display buffer

gibuffer	ftgen	0, 0, 1048576, 2, 0	; Buffer table. Roughly 23 seconds duration.
gibufferR	ftgen	0, 0, 1048576, 2, 0	; right channel

;GRAIN ENVELOPE WINDOW FUNCTION TABLES:
giwfn1	ftgen	0,  0, 131072,  9,   .5, 1, 	0 							; HALF SINE
giwfn2	ftgen	0,  0, 131072,  7,    0, 3072,  1, 128000,     0			; PERCUSSIVE - STRAIGHT SEGMENTS
giwfn3	ftgen	0,  0, 131072,  5, .001, 3072,  1, 128000, 0.001			; PERCUSSIVE - EXPONENTIAL SEGMENTS
giwfn4	ftgen	0,  0, 131072,  7,    0, 1536,  1, 128000,     1, 1536, 0	; GATE - WITH ANTI-CLICK RAMP UP AND RAMP DOWN SEGMENTS
giwfn5	ftgen	0,  0, 131072,  7,    0, 128000,1, 3072,       0			; REVERSE PERCUSSIVE - STRAIGHT SEGMENTS
giwfn6	ftgen	0,  0, 131072,  5, .001, 128000,1, 3072,   0.001			; REVERSE PERCUSSIVE - EXPONENTIAL SEGMENTS

instr	1
	gkOnOff		chnget	"OnOff"
	ktrigger	trigger	gkOnOff,0.5,0
	schedkwhen	ktrigger,0,0,2,0,-1

	ginsamp		=	ftlen(gibuffer)-1			;index of the final sample in the function table

	gkamp		chnget	"amp"
	gkInGain	chnget	"InGain"
	gkmix		chnget	"mix"
	gkbalance	chnget	"balance"
	gkmonostereo	chnget	"monostereo"
	gkfback		chnget	"feedback"
	gkclip  	chnget	"clip"
	gkClipLev  	chnget	"ClipLev"
	gkCutoff	chnget	"Cutoff"
	gkpch		chnget	"pch"
	gkLPF_On  	chnget	"LPF_On"
	gkwsize		chnget	"wsize"
	gkwsize		=	int(gkwsize)	; workaround
	gkrnd		chnget	"rnd"
	gkornd		=	int(gkrnd)	; workaround
	gkolap		chnget	"olaps"
	gkolap		=	int(gkolap)	; workaround
	gkwfn		chnget	"wfn"
	gkdly		chnget	"dly"
	gkbeta		chnget	"beta"
	gkfreeze	chnget	"freeze"
	gkManPtrPort	chnget	"ManPtrPort"
	gkManPtr	chnget	"ManPtr"
	gkUniNote	chnget	"UniNote"

	ktrigger	trigger	gkfreeze,0.5,1				; if 'freeze' switch is turned off...
	if ktrigger==1 then						
	 chnset	1-ktrigger,"ManPtr"					; reset Manual Pointer slider to its default (maximum) position
	endif

	ain	inch	1						; read audio input from the left input channel
	ain	=	ain*gkInGain					; scale input signal according to 'In Gain' control position
		outch	1,ain*(1-gkmix)					; send some dry signal to output according to dry/wet 'Mix' control position
	gaFBackSig,gaFBackSigR	init	0				; audio feedback signal (initialised for first performance iteration)
	
	/*DC offset filter feedback signal*/
	aFBackSig	dcblock2	gaFBackSig			; filter dc offset from left channel feedback signal
	if gkmonostereo==3 then						; if 'stereo in' mode is active...
	 aFBackSigR	dcblock2	gaFBackSigR			; filter dc offset from right channel feedback signal
	endif
	
	/*lowpass filter feedback signal*/
	if gkLPF_On==1 then						; if lowpass filter button is on...
	 aFBackSig tone	aFBackSig,gkCutoff				; ...filter left feedback channel
	 if gkmonostereo==3 then					; if 'stereo in' mode is active...
	  aFBackSigR tone	aFBackSigR,gkCutoff			; lowpass filter the right channel
	 endif
	endif

	/*clip feedback signal*/
	if gkclip==1 then						; if clip switch is on...
	 ktrig	changed	gkClipLev					; if clip level control is adjusted generate a trigger impulse (momentary '1')
	 if ktrig==1 then						; if a trigger impulse has been received...
	  reinit	UPDATE_CLIP_L					; reinitialise clip opcode (clip level is i-rate only)
	 endif
	 UPDATE_CLIP_L:
	 aFBackSig	clip	aFBackSig, 0, 0dbfs*i(gkClipLev)	; clip left feedback signal at maximum amplitude using bram de jong method
	 if gkmonostereo==3 then					; and if stereo in/out mode is also chosen
	  aFBackSigR	clip	aFBackSigR, 0, 0dbfs*i(gkClipLev)	; clip right channel feedback signal
	  rireturn
	 endif
	endif
	gaphsW	phasor	(sr*(1-gkfreeze))/ginsamp			; pointer 0 - 1	;create a moving phase value that will be used to point to locations in a function table where input audio signal will be written

	/*write audio from left input to function table*/
	if gkfreeze==0 then
		tablew	ain+aFBackSig,gaphsW,gibuffer,1			; write input audio to table
		tablew	k(ain)*5,1-k(gaphsW),giview,1			; write a value to the view table (k-rate is sufficient). Boost its amplitude before writing.
	 if metro(32)==1 then								; peg rate of table updates
       	  chnset	"tablenumber(1)", "table"			; update table display	
	 endif

	endif
	
	/*if stereo in - stereo out mode*/
	if gkmonostereo==3 then						; if stereo in/out mode has been chosen...
	 aR	inch	2						; read right channel audio input
	 aR	=	aR*gkInGain					; rescale its amplitude with 'Input Gain' slider
	 if gkfreeze==0 then
		tablew	aR+aFBackSigR,gaphsW,gibufferR,1		; write right channel audio input audio to table
	 endif
		outch	2,aR*(1-gkmix)					; if 'stereo in' mode is selected, send some right channel dry signal to output according to dry/wet 'Mix' control position
	else
		outch	2,ain*(1-gkmix)					; otherwise not 'stereo in' mode so just send some left channel dry signal to output
	endif
		clear	gaFBackSig,gaFBackSigR				; clear feedback signals
		
	if changed(gkManPtr)==1 then
	 Smsg	sprintfk	"pos(%d,250)",10+((gkManPtr+1)*508)
	 	chnset		Smsg,"wiper"
	endif
endin

instr	2
	iMIDIActiveValue	=	1							; IF MIDI ACTIVATED
	iMIDIflag		=	0							; IF FLTK ACTIVATED
	mididefault	iMIDIActiveValue, iMIDIflag						; IF NOTE IS MIDI ACTIVATED REPLACE iMIDIflag WITH iMIDIActiveValue 
	kMIDIflag	init	iMIDIflag
	if gkOnOff==0&&iMIDIflag==0 then
	 turnoff
	endif

	if iMIDIflag==1 then
	 icps	cpsmidi
	 kpch	=	icps/cpsmidinn(gkUniNote)
	else
	 kpch		=	gkpch
	endif	

	kporttime	linseg	0,0.001,0.03							; portamento time. Rises quickly from zero to a held value.
	kpch		portk	kpch,kporttime							; Apply portamento smoothing to changes made to the pitch multiplier
	apch	interp	kpch									; interpolate pitch multiplier variable to create an a-rate version. This will produce higher quality results when pitch is modulated.
	
	kManPtr	portk	gkManPtr,kporttime*10*gkfreeze*gkManPtrPort

	kmetro	metro	5									; peg rate of reinits
	if kmetro==1 then
	 ktrig	changed	gkwsize,gkrnd,gkolap,gkwfn						; if any of the list of input args. change, generate a trigger impulse (momentary '1'). The input args are all i-rate in sndwarp so reinitialisation will be required for their changes to register.
	endif
	if ktrig==1 then									; if a trigger has been generated... 
	 reinit	UPDATE_SNDWARP									; ... begin a reinitialisation pass from the given label
	endif
	UPDATE_SNDWARP:										; a label. Reinitialisation begins from here.
	imode	=	1									; sndwarp mode. (1=pointer mode, timestretch mode not so useful in a live audio in application)
	ibeg	=	0									; point in the function table from which to begin reading audio (0=beginning)
	iwsize	=	i(gkwsize)								; window (grain) size in samples
	irnd	=	i(gkrnd)								; window (grain) size randomisation bandwidth in samples
	iolap	=	i(gkolap)								; number of grain overlaps
	kRndDly	betarand	gkdly,1,gkbeta							; random grain delay time
	if gkmonostereo!=0 then
	 kRndDlyR	betarand	gkdly,1,gkbeta						; random grain delay time
	endif
	
	iMaxDur	=	(iwsize+irnd)/sr							; maximum grain duration in seconds
	kTransComp	limit	iMaxDur*(kpch-1),0,ginsamp/sr
	kdelay	=	(kTransComp+kRndDly) / (ginsamp/sr)					; delay time required when reading grains from the function table
	if gkmonostereo!=0 then
	 kdelayR	=	(kTransComp+kRndDlyR) / (ginsamp/sr)				; delay time required when reading grains from the function table
	endif
	if gkfreeze==1 then
	 kdelay		=	kdelay + (sr/(ginsamp)*1.75*iwsize/sr)				; if freeze mode is active regress the read pointer a small amount
	 if gkmonostereo!=0 then
	  kdelayR	=	kdelayR + (sr/(ginsamp)*1.75*iwsize/sr)				; if freeze mode is active regress the read pointer a small amount
	 endif
	endif
	aphsR	wrap	(gaphsW-kdelay+kManPtr)*(ginsamp/sr),0,(ginsamp-iwsize-irnd)/sr		; location from which to read grain. This is always directly related to the poistion of the write pointer.
	aphsR_R	wrap	(gaphsW-kdelayR+kManPtr)*(ginsamp/sr),0,(ginsamp-iwsize-irnd)/sr	; location from which to read grain. This is always directly related to the poistion of the write pointer.
	iwfn	=	giwfn1+i(gkwfn)-1							; Grain amplitude windowing shape
	
	/*sndwarp*/
	asig,ac	sndwarp 1, aphsR, apch, gibuffer, ibeg, iwsize, irnd, iolap, iwfn, imode
	if gkbalance==1 then									; if 'balance switch is on...
	 asig	balance	asig,ac									; ... amplitude balance the signal
	endif
	if gkmonostereo==1 then									; if 'mono' mode seleced...
	 gaFBackSig	=	gaFBackSig+(asig*gkfback)					; create feedback signal for next iteration. (This will be written into the function table along with the live audio in.)
	 aR	=	asig
	elseif gkmonostereo==2 then								; or if 'stereo out' mode
	 aR,acR	sndwarp 1, aphsR_R, apch, gibuffer, ibeg, iwsize, irnd, iolap, iwfn, imode
	 if gkbalance==1 then
	  aR	balance	aR,acR
	 endif
	 gaFBackSig	=	gaFBackSig+((asig+aR)*gkfback)					; create feedback signal, a mixture of the left and right sndwarp output channels
	else											; otherwise 'stereo in/out' mode
	 aR,acR	sndwarp 1, aphsR_R, apch, gibufferR, ibeg, iwsize, irnd, iolap, iwfn, imode
	 if gkbalance==1 then
	  aR	balance	aR,acR
	 endif
	 gaFBackSig	=	gaFBackSig+(asig*gkfback)					; left channel feedback signal
	 gaFBackSig	=	gaFBackSig+(aR*gkfback)						; right channel feedback signal
	endif	
	rireturn										; return from reinitialisation
	aAntiClick	linsegr	0,0.03,1,0.03,0
		outs	asig*gkamp*gkmix*aAntiClick, aR*gkamp*gkmix*aAntiClick			; send audio to outputs
endin

instr	UpdateWidgets
	ksemis	chnget	"semis"									; read in 'semis' widget
	ktrig1	changed	ksemis									; if 'semis' knob is moved...
	if ktrig1==1 then			
	 chnset	semitone(ksemis), "pch"								; update 'Pitch' knob with the value of semis (converted to a ratio)
	endif
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
;i 2 0 [3600*24*7]
i "UpdateWidgets" 0 [3600*24*7]
</CsScore>


</CsoundSynthesizer>



























; Modulating Delays -  randomly modulating delays

; GATE (for gating the incoming signal)
; On Thrsh / Off Thrsh	-	thresholds at which the gate will open and close
; Rise Time		-	time it takes for the gate to ramp open
; Rel Time		-	time it takes for the gate to ramp closed

; SETUP
; Pan Width		-	extent of the random panning effect (0 = all layers centred)
; Spread		-	spread of the delay times of the different layers (if only 1 layer is active this control isn't really useful)
;				 if 'spread' is zero, all layers' delay time modulated between  'Min Time' and 'Max Time'
; Layers		-	Number of layers of modulating delays

; REVERB - there is a reverb effect within the each delay buffer
; Amount		-	amount of reverb signal added to the output of the delay buffer - within the delay buffer -, this will therefore be mixed into the feedback signal and fed back into to reverb also
; Time			-	reverb time
; Damping		-	damping of high frequencies within the delay effect
; ** CAUTION MUST BE TAKEN WHEN USING HIGH LEVELS OF DELAY FEEDBACK WITH A HIGH REVERB AMOUNT AS OVERLOADING CAN QUICKLY OCCUR **

; OUTPUT
; Dry			-	level control for the dry (post gate) signal
; Wet			-	level control for the wet (delayed) signal

; SLIDERS
; Min Time		-	Minimum delay time in the delay time random modulation
; Max Time		-	Maximum delay time in the delay time random modulation
; Min Rate		-	Minimum rate in the random modulation
; Max Rate		-	Maximum rate in the random modulation
; Min F.back		-	Minimum feedback value in the modulation of delay feedback values
; Max F.back		-	Maximum feedback value in the modulation of delay feedback values
; Min Tone		-	Minimum cutoff frequency in a randomly modulting low-pass filter within each delay buffer
; Max Tone		-	Maximum cutoff frequency in a randomly modulting low-pass filter within each delay buffer


<Cabbage>
form size(960, 260), caption("Modulating Delays"), pluginid("mdel") style("legacy")

label    bounds(200,  5, 80, 11), text("G A T E"), fontcolour("white")
checkbox bounds( 10, 35,100, 15), text("Gate On/Off") channel("GateActive"), FontColour("White"), colour("lime")  value(1)
rslider  bounds(100, 20, 60, 60), channel("OnThreshold"),  text("On Thrsh."),  range(0, 1, 0.05, 0.5, 0.001),  colour(30,30,30) trackercolour(white)
rslider  bounds(160, 20, 60, 60), channel("OffThreshold"), text("Off Thrsh."), range(0, 1, 0.01, 0.5, 0.001),  colour(30,30,30) trackercolour(white)
rslider  bounds(220, 20, 60, 60), channel("RiseTime"),     text("Rise Time"),  range(0, 10, 1, 0.5, 0.001),    colour(30,30,30) trackercolour(white)
rslider  bounds(280, 20, 60, 60), channel("RelTime"),      text("Rel.Time"),   range(0, 10, 0.01, 0.5, 0.001), colour(30,30,30) trackercolour(white)
checkbox bounds(340, 35, 90, 15), text("Gating") channel("gating"), FontColour("White"), colour("red")  value(0) shape(ellipse)

label    bounds(487,  5, 80, 11), text("S E T U P"), fontcolour("white")
line     bounds(405, 25,  3, 50), colour("Grey")
rslider  bounds(420, 20, 60, 60), channel("width"),  text("Pan Width"),range(0, 0.5, 0.5),         colour(100,100,100) trackercolour(white)
rslider  bounds(480, 20, 60, 60), channel("spread"), text("Spread"),   range(0, 4, 1, 0.5, 0.001), colour(100,100,100) trackercolour(white)
rslider  bounds(540, 20, 60, 60), channel("layers"), text("Layers"),   range(1, 22, 8,1,1),        colour(100,100,100) trackercolour(white)
line     bounds(610, 25,  3, 50), colour("Grey")
label    bounds(680,  5, 80, 11), text("R E V E R B"), fontcolour("white")
rslider  bounds(620, 20, 60, 60), channel("RvbAmt"),  text("Amount"),   range(0, 0.2, 0.06,1,0.001), colour(100,100,100) trackercolour(white)
rslider  bounds(680, 20, 60, 60), channel("RvbTime"), text("Time"),     range(0.01,10,    7),        colour(100,100,100) trackercolour(white)
rslider  bounds(740, 20, 60, 60), channel("damping"), text("Damping"),  range(0, 1, 0.5),            colour(100,100,100) trackercolour(white)
line     bounds(810, 25,  3, 50), colour("Grey")
label    bounds(856,  5, 80, 11), text("O U T P U T"), fontcolour("white")
rslider  bounds(825, 20, 60, 60), channel("dry"),    text("Dry"),      range(0, 4, 0, 0.5, 0.001), colour(160,160,160) trackercolour(white)
rslider  bounds(885, 20, 60, 60), channel("wet"),    text("Wet"),      range(0, 4, 1, 0.5, 0.001), colour(160,160,160) trackercolour(white)

line     bounds(  0, 95,960, 3), colour("Grey")

;hslider2 bounds(10,110, 940, 30), channel("MinTime","MaxTime"), text(Time), min(0.131), max(0.9)    range(0.001, 10,1,0.5),  colour("blue"),   trackercolour(blue)
hrange    bounds(10,110, 940, 30), channel("MinTime","MaxTime"), text("Time"), range(0.001, 10, 0.131:0.9, 0.5),  colour("blue"),   trackercolour("blue")
;hslider2 bounds(10,140, 940, 30), channel("MinRate","MaxRate"), min(0.1),  max(0.2),   text("Rate"),    range(0.001, 10,1,0.5),   colour("red"),    trackercolour(red)
hrange    bounds(10,140, 940, 30), channel("MinRate","MaxRate"), text("Rate"), range(0.001, 10, 0.1:0.2, 0.5),  colour("red"),   trackercolour("red")
;hslider2 bounds(10,170, 940, 30), channel("MinFB","MaxFB"),     min(0.95), max(0.975), text("F.back"),  range(0, 0.999, 0.95,1,0.001),  colour("yellow"), trackercolour(yellow)
hrange    bounds(10,170, 940, 30), channel("MinFB","MaxFB"), text("F.back"), range(0, 0.999, 0.95:0.975, 0.5),  colour("yellow"),   trackercolour("yellow")
;hslider2 bounds(10,200, 940, 30), channel("MinTone","MaxTone"), min(11),   max(14),    text("Tone"),    range(4, 14, 11),               colour(purple),   trackercolour(purple)
hrange    bounds(10,200, 940, 30), channel("MinTone","MaxTone"), text("Tone"), range(4, 14, 11:14, 1),  colour("purple"),   trackercolour("purple")

label   bounds(  5,240, 170, 12), text("Author: Iain McCurdy |2013|"), FontColour("grey")

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -d
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 16
nchnls = 2
0dbfs=1


opcode	DelayIteration,aa,aakkkkkkkkkkkKiii
 aL,aR,kMinTime,kMaxTime,kMinRate,kMaxRate,kMinFB,kMaxFB,kwidth,kMinTone,kMaxTone,kRvbAmt,kRvbTime,kdamping,ispread,icount,ilayers	xin

 kdel		rspline	kMinTime,kMaxTime,kMinRate,kMaxRate
 kdel		limit	kdel,0.001,10
 adel		interp	kdel
 kFB		rspline	kMinFB,kMaxFB,kMinRate,kMaxRate
 kFB		limit	kFB,0,1
 
 iMaxDel	=	10
 iws		=	4
 aout1, aout2	init	0

 ktone		rspline	kMinTone, kMaxTone,kMinRate,kMaxRate
 ktone		=	cpsoct(ktone)
 
 idelOS		random	0,ispread
  
 abuf		delayr	iMaxDel+idelOS
 aout1		deltap3	adel+idelOS
 arvb 		nreverb aout1, kRvbTime, kdamping
 aout1		=	aout1 + arvb*kRvbAmt
 aout1		dcblock2	aout1
 aout1		tone	aout1,ktone
 		delayw	aL + aout1*kFB
 		
 abuf		delayr	iMaxDel+idelOS
 aout2		deltap3	adel+idelOS
 arvb 		nreverb aout2, kRvbTime, kdamping
 aout2		=	aout2 + arvb*kRvbAmt
 aout2		dcblock2	aout2
 aout2		tone	aout2,ktone
 		delayw	aR + aout2*kFB

 kpan		rspline	0.5-kwidth,0.5+kwidth,kMinRate,kMaxRate
 kpan		limit	kpan,0,1
 apan		interp	kpan
 aout1		=	aout1*(1-apan)
 aout2		=	aout2*(apan)
 amix1,amix2	init	0
 
 amix1	=	0
 amix2	=	0
 
 if icount<ilayers then
  amix1,amix2	DelayIteration	aL,aR,kMinTime,kMaxTime,kMinRate,kMaxRate,kMinFB,kMaxFB,kwidth,kMinTone,kMaxTone,kRvbAmt,kRvbTime,kdamping,ispread,icount+1,ilayers
 endif
 
		xout	aout1+amix1, aout2+amix2
endop

opcode	SwitchPort, k, kki
	kin,kupport,idnport	xin
	kold			init	0
	kporttime		=	(kin<kold?idnport:kupport)
	kout			portk	kin, kporttime
	kold			=	kout
				xout	kout
endop


instr	1
 kporttime	linseg	0,0.001,1
 aL,aR	ins
 ;aL,aR	diskin2	"Synthpad.wav",1,0,1
 ;aL	diskin2	"loop.wav",1,0,1
 ;aR	=	aL
 
 kMinTime	chnget	"MinTime"
 kMaxTime	chnget	"MaxTime"
 kMinTime	portk	kMinTime,kMinTime			
 kMaxTime	portk	kMaxTime,kMaxTime			
 kspread	chnget	"spread"
 kMinRate	chnget	"MinRate"
 kMaxRate	chnget	"MaxRate"
 kMinFB		chnget	"MinFB"
 kMaxFB		chnget	"MaxFB"
 kwidth		chnget	"width"
 kMinTone	chnget	"MinTone"
 kMaxTone	chnget	"MaxTone"
 kres		chnget	"res"
 klayers	chnget	"layers"
 klayers	init	1
 
 kdry		chnget	"dry"
 kwet		chnget	"wet"
 kGateActive	chnget	"GateActive"
 kOnThreshold	chnget	"OnThreshold"
 kOffThreshold	chnget	"OffThreshold"
 kRiseTime	chnget	"RiseTime"
 kRelTime	chnget	"RelTime"

 kRvbAmt	chnget	"RvbAmt"
 kRvbTime	chnget	"RvbTime"
 kdamping	chnget	"damping"
 
 /* GATE */
 if kGateActive=1 then
  krms	rms	(aL+aR)*0.5
  kthreshold	init	i(kOnThreshold)
  kon	=	1
  koff	=	0
  if krms>kthreshold then
   kgate	=	1
   kthreshold	=	kOnThreshold
   		chnset	koff,"gating"
  else
   kgate	=	0
   kthreshold	=	kOffThreshold
   		chnset	kon,"gating"
  endif    
  kgate	SwitchPort	kgate,kRiseTime,0.1
  kgate	expcurve	kgate,8
  agate	interp	kgate
  aL	=	aL * agate
  aR	=	aR * agate
 endif
 ktrig	trigger	kGateActive,0.5,1
 if ktrig=1 then
  chnset	koff,"gating"
 endif


 /* REINITIALISING */
 ktrig	changed	klayers,kspread
 if ktrig=1 then
  reinit UPDATE
 endif
 UPDATE:
 
 /* CALL THE UDO */
 aout1,aout2	DelayIteration	aL,aR,kMinTime,kMaxTime,kMinRate,kMaxRate,kMinFB,kMaxFB,kwidth,kMinTone,kMaxTone,kRvbAmt,kRvbTime,kdamping,i(kspread),1,i(klayers)
 rireturn

 		outs	(aout1 * kwet) + (aL * kdry), (aout2 * kwet) + (aR * kdry)
endin

</CsInstruments>  

<CsScore>
i 1 0 360000
</CsScore>

</CsoundSynthesizer>; MultiModeDelay.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("Multi-mode Delay") size(435, 90), pluginid("MMDl") style("legacy")
image                    bounds(0, 0,435, 90), colour("Maroon"), shape("rounded"), outlinecolour("white"), outlinethickness(4)
label    bounds( 10, 22, 80, 12), text("Type"), fontcolour("white")
combobox bounds( 10, 35, 80, 20),  text("Ping Pong","Stereo"), channel("type"), value(1)
rslider  bounds( 95, 11, 70, 70),  text("Time"),     channel("time"),     range(0.001, 10, 0.4, 0.5), colour( 85,  0,  0) trackercolour("silver"), textcolour("silver")
rslider  bounds(160, 11, 70, 70),  text("Cutoff"),   channel("cutoff"),   range(20,20000,20000,0.5),  colour( 85,  0,  0) trackercolour("silver"), textcolour("silver")
rslider  bounds(225, 11, 70, 70), text("Feedback"), channel("feedback"), range(0, 1.00, 0.5),        colour( 85,  0,  0) trackercolour("silver"), textcolour("silver")
rslider  bounds(290, 11, 70, 70), text("Mix"),      channel("mix"),      range(0, 1.00, 0.5),        colour( 85,  0,  0) trackercolour("silver"), textcolour("silver")
rslider  bounds(355, 11, 70, 70), text("Level"),    channel("level"),    range(0, 1.00, 0.7),        colour( 85,  0,  0) trackercolour("silver"), textcolour("silver")

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

instr	1
	ktime		chnget	"time"					;READ WIDGETS...
	kcutoff		chnget	"cutoff"				;
	kfeedback	chnget	"feedback"				;
	kmix		chnget	"mix"					;
	klevel		chnget	"level"					;
	asigL, asigR	ins
	kporttime	linseg	0,0.01,0.03				;CREATE A VARIABLE THAT WILL BE USED FOR PORTAMENTO TIME
	ktime		portk	ktime,kporttime				;PORTAMENTO SMOOTHING OF DELAT TIME
	atime		interp	ktime					;INTERPOLATED A-RATE VERSION OF DELAY TIME
	ktype		chnget	"type"
	if ktype==1 then
	 aL_OS		vdelay	asigL,(atime*1000)/2,(10*1000)/2	;DELAYED OFFSET OF LEFT CHANNEL (FIRST 'PING')
	 ;LEFT CHANNEL
	 abuf		delayr	10					;ESTABLISH DELAY BUFFER
	 aDelL		deltapi	atime					;TAP BUFFER
	 aDelL		tone	aDelL,kcutoff				;LOWPASS FILTER DELAY TAP 
	 		delayw	aL_OS+(aDelL*kfeedback)			;WRITE INPUT AUDIO INTO BUFFER
	 ;RIGHT CHANNEL
	 abuf		delayr	10					;ESTABLISH DELAY BUFFER
	 aDelR		deltapi	atime					;TAP BUFFER
	 aDelR		tone	aDelR,kcutoff				;LOWPASS FILTER DELAY TAP
	 		delayw	asigR+(aDelR*kfeedback)			;WRITE INPUT AUDIO INTO BUFFER
	 amixL		ntrpol	asigL,aDelL+aL_OS,kmix			;MIX DRY AND WET SIGNALS (LEFT CHANNEL)
	 amixR		ntrpol	asigR,aDelR,kmix			;MIX DRY AND WET SIGNALS (RIGHT CHANNEL)
	elseif ktype==2 then
	 ;LEFT CHANNEL
	 abuf		delayr	10					;ESTABLISH DELAY BUFFER
	 aDelL		deltapi	atime					;TAP BUFFER
	 aDelL		tone	aDelL,kcutoff				;LOWPASS FILTER DELAY TAP 
	 		delayw	asigL+(aDelL*kfeedback)			;WRITE INPUT AUDIO INTO BUFFER
	 ;RIGHT CHANNEL
	 abuf		delayr	10					;ESTABLISH DELAY BUFFER
	 aDelR		deltapi	atime					;TAP BUFFER
	 aDelR		tone	aDelR,kcutoff				;LOWPASS FILTER DELAY TAP
	 		delayw	asigR+(aDelR*kfeedback)			;WRITE INPUT AUDIO INTO BUFFER
	 amixL		ntrpol	asigL,aDelL,kmix			;MIX DRY AND WET SIGNALS (LEFT CHANNEL)
	 amixR		ntrpol	asigR,aDelR,kmix			;MIX DRY AND WET SIGNALS (RIGHT CHANNEL) 		
	endif
			outs	amixL*klevel, amixR*klevel		;PING PONG DELAY OUTPUTS ARE SENT OUT
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>; MultitapDelay.csd
; Written by Iain McCurdy, 2015

; Tone controls control the cutoff frequency of a lowpass filter on each tap

; Three modes are offered which implement feedback in different ways:

; Mode 1
; ------
; All 4 taps are taken from the same buffer **
; Only the 4th (and longest) tap is fed back into the input

; Mode 2
; ------
; All 4 delays are independent buffers
; All four feedback into themselves independently

; Mode 3
; ------
; All 4 delays are independent buffers
; Feedback into each delay is a mix of all 4 delays outputs.

<Cabbage>
form caption("Multitap Delay") size(300,385), pluginid("MtDl") style("legacy")
image pos(0, 0),               size(300,385), colour( 170, 90,10), shape("rounded"), outlinecolour("white"), outlinethickness(4) 

label     bounds( 10, 45, 70, 14), fontcolour("white"), text("%")
nslider bounds( 10, 10, 70, 35), channel("DelTim1"),   text("Time 1"), colour(  0, 40, 50), textcolour("white"), range(0, 100, 12.5, 1, 0.001)
rslider   bounds( 10, 65, 70, 70), channel("Tone1"), text("Tone 1"),   colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 20000, 12000, 0.5)
rslider   bounds( 10,145, 70, 70), channel("Pan1"), text("Pan 1"),     colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.2)
rslider   bounds( 10,215, 70, 70), channel("Level1"), text("Level 1"), colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.8, 0.5,0.001)

label     bounds( 80, 45, 70, 14), fontcolour("white"), text("%")
nslider bounds( 80, 10, 70, 35), channel("DelTim2"),  text("Time 2"), colour(  0, 40, 50), textcolour("white"), range(0, 100, 50, 1, 0.001)
rslider   bounds( 80, 65, 70, 70),   channel("Tone2"),  text("Tone 2"), colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 20000, 5000, 0.5)
rslider   bounds( 80,145, 70, 70),    channel("Pan2"),  text("Pan 2"),  colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.4)
rslider   bounds( 80,215, 70, 70),  channel("Level2"),  text("Level 2"),colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.25, 0.5,0.001)

label     bounds(150, 45, 70, 14), fontcolour("white"), text("%")
nslider bounds(150, 10, 70, 35), channel("DelTim3"),  text("Time 3"), colour(  0, 40, 50), textcolour("white"), range(0, 100, 87.5, 1, 0.001)
rslider   bounds(150, 65, 70, 70),   channel("Tone3"),  text("Tone 3"), colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 20000, 16000, 0.5)
rslider   bounds(150,145, 70, 70),    channel("Pan3"),  text("Pan 3"),  colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.8)
rslider   bounds(150,215, 70, 70),  channel("Level3"),  text("Level 3"),colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.5, 0.5,0.001)

label     bounds(220, 45, 70, 14), fontcolour("white"), text("secs")
nslider bounds(220, 10, 70, 35), channel("DelTim4"),  text("Time 4"), colour(  0, 40, 50), textcolour("white"), range(0.001, 30, 1.5, 1, 0.001)
rslider   bounds(220, 65, 70, 70),   channel("Tone4"),  text("Tone 4"), colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 20000, 8000, 0.5)
rslider   bounds(220,145, 70, 70),    channel("Pan4"),  text("Pan 4"),  colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.6)
rslider   bounds(220,215, 70, 70),  channel("Level4"),  text("Level 4"),colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.7, 0.5,0.001)

line      bounds( 10,295,280,2)
label     bounds( 10,310, 70, 14), fontcolour("white"), text("Type")
combobox  bounds( 10,325, 70, 20),  channel("Mode"),text("Mode 1","Mode 2","Mode 3"), colour(  0, 40, 50), textcolour("white")
rslider   bounds( 80,305, 70, 70),  channel("Mix"),text("Mix"), colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.5)
rslider   bounds(150,305, 70, 70),  channel("Feedback"),text("Feedback"), colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0.75)
rslider   bounds(220,305, 70, 70),  channel("Level"),text("Level"), colour(  0, 40, 50), trackercolour(200,240,250), textcolour("white"), range(0, 1, 1)

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2015)

instr	1
 kDelTim1	chnget	"DelTim1"
 aDelTim1	interp	kDelTim1*0.01
 kTone1		chnget	"Tone1"
 kPan1		chnget	"Pan1"
 kLevel1	chnget	"Level1"

 kDelTim2	chnget	"DelTim2"
 aDelTim2	interp	kDelTim2*0.01
   kTone2	chnget	  "Tone2"
 kPan2		chnget	"Pan2"
  kLevel2	chnget	 "Level2"

 kDelTim3	chnget	"DelTim3"
 aDelTim3	interp	kDelTim3*0.01
   kTone3	chnget	  "Tone3"
 kPan3		chnget	"Pan3"
  kLevel3	chnget	 "Level3"

 kDelTim4	chnget	"DelTim4"
 aDelTim4	interp	kDelTim4
   kTone4	chnget	  "Tone4"
 kPan4		chnget	"Pan4"
  kLevel4	chnget	 "Level4"

  kFeedback	chnget	 "Feedback"
  kLevel	chnget	 "Level"
  kMix		chnget	 "Mix"
  kMode		chnget	"Mode"

 aInL,aInR	ins


 if kMode==1 then
 
 /* left channel */
 abufL	delayr	30
 aTapL1	deltapi	aDelTim1 * aDelTim4
 aTapL1	tone	aTapL1, kTone1
 aTapL2	deltapi	aDelTim2 * aDelTim4
 aTapL2	tone	aTapL2, kTone2
 aTapL3	deltapi	aDelTim3 * aDelTim4
 aTapL3	tone	aTapL3, kTone3
 aTapL4	deltapi	aDelTim4
 aTapL4	tone	aTapL4, kTone4
	delayw	aInL + (aTapL4*kFeedback)

 /* right channel */
 abufR	delayr	30
 aTapR1	deltapi	aDelTim1 * aDelTim4
 aTapR1	tone	aTapR1, kTone1
 aTapR2	deltapi	aDelTim2 * aDelTim4
 aTapR2	tone	aTapR2, kTone2
 aTapR3	deltapi	aDelTim3 * aDelTim4
 aTapR3	tone	aTapR3, kTone3
 aTapR4	deltapi	aDelTim4
 aTapR4	tone	aTapR4, kTone4
	delayw	aInR + (aTapR4*kFeedback)


 elseif kMode==2 then
  
 /* left channel */
  abuf	delayr	30
 aTapL1	deltapi	aDelTim1 * aDelTim4
 aTapL1	tone	aTapL1, kTone1
 	delayw	aInL + (aTapL1*kFeedback)	
 abuf	delayr	30
 aTapL2	deltapi	aDelTim2 * aDelTim4
 aTapL2	tone	aTapL2, kTone2
 	delayw	aInL + (aTapL2*kFeedback)	
 abuf	delayr	30
 aTapL3	deltapi	aDelTim3 * aDelTim4
 aTapL3	tone	aTapL3, kTone3
 	delayw	aInL + (aTapL3*kFeedback)	
 abuf	delayr	30
 aTapL4	deltapi	aDelTim4
 aTapL4	tone	aTapL4, kTone4
 	delayw	aInL + (aTapL4*kFeedback)	

 /* right channel */
 abuf	delayr	30
 aTapR1	deltapi	aDelTim1 * aDelTim4
 aTapR1	tone	aTapR1, kTone1
 	delayw	aInR + (aTapR1*kFeedback)	
 abuf	delayr	30
 aTapR2	deltapi	aDelTim2 * aDelTim4
 aTapR2	tone	aTapR2, kTone2
 	delayw	aInR + (aTapR2*kFeedback)	
 abuf	delayr	30
 aTapR3	deltapi	aDelTim3 * aDelTim4
 aTapR3	tone	aTapR3, kTone3
 	delayw	aInR + (aTapR3*kFeedback)	
 abuf	delayr	30
 aTapR4	deltapi	aDelTim4
 aTapR4	tone	aTapR4, kTone4
 	delayw	aInR + (aTapR4*kFeedback)	


 elseif kMode==3 then
  
 aFBmixL,aFBmixR	init	0 
 aTapL1	vdelay	aInL+aFBmixL, aDelTim1*aDelTim4*1000, 30000
 aTapL2	vdelay	aInL+aFBmixL, aDelTim2*aDelTim4*1000, 30000
 aTapL3	vdelay	aInL+aFBmixL, aDelTim3*aDelTim4*1000, 30000
 aTapL4	vdelay	aInL+aFBmixL, aDelTim4         *1000, 30000
 aTapR1	vdelay	aInR+aFBmixR, aDelTim1*aDelTim4*1000, 30000
 aTapR2	vdelay	aInR+aFBmixR, aDelTim2*aDelTim4*1000, 30000
 aTapR3	vdelay	aInR+aFBmixR, aDelTim3*aDelTim4*1000, 30000
 aTapR4	vdelay	aInR+aFBmixR, aDelTim4         *1000, 30000
 
 aTapL1	tone	aTapL1,kTone1
 aTapL2	tone	aTapL2,kTone2
 aTapL3	tone	aTapL3,kTone3
 aTapL4	tone	aTapL4,kTone4
 aTapR1	tone	aTapR1,kTone1
 aTapR2	tone	aTapR2,kTone2
 aTapR3	tone	aTapR3,kTone3
 aTapR4	tone	aTapR4,kTone4
  
 aFBmixL	=	(aTapL1 + aTapL2 + aTapL3 + aTapL4) * kFeedback / 4
 aFBmixR	=	(aTapR1 + aTapR2 + aTapR3 + aTapR4) * kFeedback / 4
 
endif

 aMixL	sum	aTapL1*kLevel1*kPan1, aTapL2*kLevel2*kPan2, aTapL3*kLevel3*kPan3, aTapL4*kLevel4*kPan4 
 aMixR	sum	aTapR1*kLevel1*(1-kPan1), aTapR2*kLevel2*(1-kPan2), aTapR3*kLevel3*(1-kPan3), aTapR4*kLevel4*(1-kPan4)




	outs	((aMixL*kMix) + (aInL*(1-kMix)))*kLevel, ((aMixR*kMix) + (aInR*(1-kMix)))*kLevel
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; Peeaaoooh.csd
; Written by Iain McCurdy, 2015

; Generates reverberation effects reminiscent of spring reverbs.

; The main element is a stack of delays with geometrically related delay times

; NB. although delays are used, their delay times are typically quite short and are expressed here in hertz, i.e. frequency of echoes (freq = 1/delay_time).
; Furthermore, ratios between delay times of parallel delays are expressed in semitones.

; Base		-	Base Frequency of the stack of delays (in hertz)	
; Layers	-	Number of layers (delays). Bear in mind that increasing this increaeses CPU and memory demand.
; Shape		-	Shapes the amplitude relationship between layers. If Shape=0, all layers are equal in amplitude, as Shape is increased, longer delays have their amplitudes attenuated.
; Interval	-	Interval between consecutive delays (in semitones).
; Scatter	-	Adds a fixed random value to the delay times of the delays. Increasing this value will gradually obliterate the distinctive 'peeaaoo' sound and also add a stereo broadening effect.
; Spread	-	Amount by which left and right fo the same delat layer are alternately panned left or right. This can be used as an alternative to 'Scatter' to create stereo broadening but without the obliteration of the 'peeaaoo' sound.
; Feedback	-	Ratio of the output signal from each delay that is fed back into the input. The knob turns red to warn of greater than 100% feedback.
; HPF		-	Cutoff frequency of a highpass filter within the feedback loop of each delay
; LPF		-	Cutoff frequency of a lowpass filter within the feedback loop of each delay
; Test Noise-	When activated, the live audio input is replaced with a sparse 'dust' source sound. Good for testing the effect.
; Sep.Mode	-	There are two separation modes: Linear: sequential delays in the stack are separated by equal pitch intervals
;							Exponential: intervals between sequential delays increase exponentially
;			Linear offers a more distinctive 'peeaaoooh' sound and arpeggios when 'Base' is low. Exponential offers a more 'scattered' sounding reverb.
;			When 'Interval' is low, both modes sound quite similar.
; Post-Filter
; HPF		-	Cutoff frequency of a highpass filter applied to the output signal (dry and wet signals)
; LPF		-	Cutoff frequency of a lowpass filter applied to the output signal (dry and wet signals)

; Mix		-	Dry/wet mix
; Level		-	Output level (dry and wet signals)

; NB. Feedback greater than 1 (i.e. more than 100% of the signal) are possible. 
; Normally this would result in a runaway increase in amplitude but control is still possible if the main highpass and lowpass filters also remove part of the audio in the feedback loop.
; Nonetheless surity is not guaranteed so therefore experimentation and caution is advised. 
; There is however a safety mechanism which will reduce the feedback control if the amplitude starts to runaway.

;                   (feedback)
;             +----[LPF]--[HPF]---+
;             |                   |  
;             v   +-----------+   | (mix)  +-----------+
;  --IN--+----+---|DELAY_STACK|---+---+----|POST FILTER|--OUT-->
;        |        +-----------+       ^    +-----------+
;        |                            |
;        +----------------------------+

<Cabbage>
form caption("Peeaaoooh") size(650,207), pluginid("Peao") style("legacy")
image pos(0, 0),          size(650,207), colour( 10, 20, 30), shape("sharp"), outlinecolour("white"), outlinethickness(0) 

rslider   bounds( 10, 10, 70, 70),  channel("Base"),text("Base"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(0.5, 1000, 50, 0.5, 0.001)
rslider   bounds( 80, 10, 70, 70),  channel("Layers"),text("Layers"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(1, 60, 8,1,1)
rslider   bounds(150, 10, 70, 70),  channel("Interval"),text("Interval"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(0.001, 1, 0.07,0.5,0.001)
rslider   bounds(220, 10, 70, 70),  channel("Shape"),text("Shape"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(0, 3, 0,1,0.001)
rslider   bounds(290, 10, 70, 70),  channel("Scatter"),text("Scatter"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0,0.5,0.0001)
rslider   bounds(360, 10, 70, 70),  channel("Spread"),text("Spread"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(0, 1, 0)
rslider   bounds(430, 10, 70, 70),  channel("Feedback"),text("Feedback"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(0, 1.5, 0.95), identchannel("FeedbackID")
checkbox  bounds(430, 82, 80, 14),  channel("Overload"),text("Overload"), colour(255, 60, 60), textcolour("white") shape("Ellipse"), active(0)
rslider   bounds(500, 10, 70, 70),  channel("HPF"),   text("HPF"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(20,20000,20,0.5,1)
rslider   bounds(570, 10, 70, 70),  channel("LPF"),   text("LPF"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(20,20000,20000,0.5,1)

checkbox  bounds(320,112,110, 15), text("Test Clicks"), channel("TestNoise"), fontcolour("white")

label     bounds(320,137,110, 12), text("Separation Mode"), fontcolour("white") 
combobox  bounds(320,150,110, 20),  channel("SepMode"),text("Linear","Exponential"), textcolour("white"), value(1)

image     bounds( 20,100,245, 95), outlinecolour("white"), outlinethickness(1), colour(50,50,50,100), plant("PostFilter") {
label     bounds(  0,  6,245, 14), text("G l o b a l    F i l t e r"), fontcolour("white") 
combobox  bounds( 10, 40, 75, 20),  channel("PrePostFilter"),text("Pre-mix","Post-mix"), textcolour("white"), value(2)
rslider   bounds( 85, 22, 70, 70),  channel("PostHPF"),   text("HPF"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(20,20000,20,0.5,1)
rslider   bounds(155, 22, 70, 70),  channel("PostLPF"),   text("LPF"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(20,20000,20000,0.5,1)
}

rslider   bounds(480,110, 70, 70),  channel("Mix"),text("Mix"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(0, 1, 1)
rslider   bounds(560,110, 70, 70),  channel("Level"),text("Level"), colour( 20, 60, 70), trackercolour(200,240,250), textcolour("white"), range(0, 2, 1,0.5,0.001)

label     bounds(530,195,100, 10), text("Iain McCurdy |2015|"), fontcolour(200,200,200) 

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	16	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1
		seed	0
		
opcode	DelayLayer,a,akkkkkkkkkip
 aInSig,kBase,kShape,kInterval,kScatter,kSpread,kSepMode,kHPF,kLPF,kFeedback,iLayers,iCount	xin
 iRnd	random	-0.5,0.5			; i-time random value. A unique fixed value for each delay layer (and channel).
 kRnd	=	octave(iRnd * kScatter)		; scale random value by GUI widget control
 /* SELECT THE SEPARATION MODE */
 if kSepMode==1 then								; linear
  aDel	interp	limit:k(kRnd/(kBase * semitone(kInterval*(iCount-1))),1/kr,2)
 else										; exponential
  aDel	interp	limit:k(kRnd/(kBase * semitone((kInterval+1)^iCount)),1/kr,2)
 endif
 kAmp	=	(iCount/iLayers) ^ kShape
 abuf	delayr	2
 aWG	deltapi	aDel
 aWG	atone	aWG,kHPF
 aWG	tone	aWG,kLPF
 aWG	dcblock2	aWG
 	delayw	aInSig + (aWG*kFeedback)
 if iCount<iLayers then
  aMix	DelayLayer	aInSig,kBase,kShape,kInterval,kScatter,1-kSpread,kSepMode,kHPF,kLPF,kFeedback,iLayers,iCount+1
 endif
	xout	aWG*limit:k(kSpread*2,0,1)*kAmp + aMix
 aMix	=	0
endop

instr	1

 /* READ IN WIDGETS */
 kporttime	linseg	0,0.001,0.1
 kBase		chnget	"Base"
 iBase		chnget	"Base"
 kBase		init	iBase
 kBase		portk	kBase,kporttime
 kInterval	chnget	"Interval"
 iInterval	chnget	"Interval"
 kinterval	init	iInterval
 kInterval	portk	kInterval,kporttime
 kScatter	chnget	"Scatter"
 kScatter	portk	kScatter,kporttime
 kSpread	chnget	"Spread"
 kFeedback	chnget	"Feedback"
 kLevel		chnget	"Level"
 kLayers	chnget	"Layers"
 kShape		chnget	"Shape"
 kHPF		chnget	"HPF"
 kLPF		chnget	"LPF"
 kSepMode	chnget	"SepMode"
 kPostHPF	chnget	"PostHPF"
 kPostLPF	chnget	"PostLPF"
 kMix		chnget	"Mix"
 kPrePostFilter		chnget	"PrePostFilter"
 kTestNoise	chnget	"TestNoise"
 
 if kTestNoise==1 then
  aL	dust2	1,0.5*randomi:k(0.5,2,1,1)
  aR	dust2	1,0.5*randomi:k(0.5,2,1,1)
  aL	butlp	aL,cpsoct(randomh:k(5,11,10))
  aR	butlp	aR,cpsoct(randomh:k(5,11,10))
 else
  aL,aR	ins
 endif
  
 /* CALL DELAY STACK (VIA A UDO) */
 if changed(kLayers)==1 then
  reinit	UPDATE
 endif
 UPDATE:
 iAmpScl	=	sqrt(i(kLayers))							; amplitude will be scaled according to the number of layers selected
 aWG_L	DelayLayer	aL,kBase,kShape,kInterval,kScatter,0.5+kSpread/2,kSepMode,kHPF,kLPF,kFeedback,i(kLayers)
 aWG_R	DelayLayer	aR,kBase,kShape,kInterval,kScatter,0.5-kSpread/2,kSepMode,kHPF,kLPF,kFeedback,i(kLayers)
 aWG_L	/=	iAmpScl										; scale amplitude according to the number of layers chosen
 aWG_R	/=	iAmpScl
 rireturn
        
 /* TURN FEEDBACK KNOB RED IF GREATER THAN 1 */       
 if trigger:k(kFeedback,1,0)==1 then		; trigger to turn red
  chnset "colour(170, 60, 70)","FeedbackID"	; send message
 elseif trigger:k(kFeedback,1,1)==1 then	; trigger to turn back to normal
  chnset "colour( 20, 60, 70)","FeedbackID"	; send message
 endif
         
 /* PREVENT OVERLOADS */
 kRMS	rms	aWG_L				; scan rms
 kOn	=	1				; on value (needs to be a k-rate var.)
 kOff	=	0				; off value (needs to be a k-rate var.)
 kOverload	chnget	"Overload"		; read in value of 'Overload' LED
 if kRMS>0.9 then				; if rms exceeds a given value...
  chnset	kOn,"Overload"			; turn on 'Overload' LED
  chnset	(kFeedback - (0.0003)) - ((kFeedback-1)*0.001),"Feedback"	; decrement 'Feedback' slider. This will be repeated every k-cycle until rms is back below the threshold value prescribed above.
 elseif kOverload==1 then			; otherwise..., i.e. if 'Overload' LED is on but rms is beneath the threshold...  
  chnset	kOff,"Overload"			; turn 'overload' LED off
 endif	

 /* GLOBAL FILTERING CAN BE APPLIED TO JUST THE WET SIGNAL OR A MIXTURE OF THE WET AND DRY SIGNALS, ACCORDING TO A SELECTION MADE USING A COMBOBOX */ 
 /* PRE-MIXER FILTERING OPTION */
 if kPrePostFilter==1 then
  if kPostHPF>20 then			; if HPF is at its minimum value (20) bypass filtering to conserve CPU
   aWG_L	buthp	aWG_L,kPostHPF	; highpass filter left channel
   aWG_R	buthp	aWG_R,kPostHPF	; highpass fiter right channel
  endif
  if kPostLPF<20000 then 		; if HPF is at its minimum value (20) bypass filtering to conserve CPU
   aWG_L	butlp	aWG_L,kPostLPF		
   aWG_R	butlp	aWG_R,kPostLPF		
  endif
  aMixL	ntrpol	aL, aWG_L, kMix
  aMixR	ntrpol	aR, aWG_R, kMix
 /* PRE-MIXER FILTERING OPTION */
 elseif kPrePostFilter==2 then
  aMixL	ntrpol	aL, aWG_L, kMix
  aMixR	ntrpol	aR, aWG_R, kMix
  if kPostHPF>20 then
   aMixL	buthp	aMixL,kPostHPF		
   aMixR	buthp	aMixR,kPostHPF		
  endif
  if kPostLPF<20000 then 
   aMixL	butlp	aMixL,kPostLPF		
   aMixR	butlp	aMixR,kPostLPF		
  endif
 endif

	outs	aMixL*kLevel, aMixR*kLevel
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; Reverse.csd
; Iain McCurdy [2012]
; 
; Buffers audio for reversed (and forward) playback.
; 
; INSTRUCTIONS
; ------------
; Time L  	--	length of the left channel delay buffer 
; Time R  	--	length of the right channel delay buffer
; Spread		--	stereo spread of the two channel. 1 = hard left and right
; Mix		--	dry/wet mix
; Level		--	output level
; Reverse 	--	(switch) activate reversed buffer
; Forward	--	(switch) activate forward buffer
; Link L&R	--	(switch) pair the left and right Time controls (functions differently if 'Time Mod' is activated)
; Time Mod	--	(switch) if this switch is on the delay times for both channels will modulate randomly between 'Time L' and 'Time R'. If 'Link L&R' is active this modulation is done in tandem for both channels.
; Pan Mod	--	(switch) if this switch is on the panning modulates randomly



<Cabbage>
form caption("Reverse") size(455, 95), pluginid("rvrs") style("legacy")
image           bounds(0, 0, 455, 95), colour("darkslategrey"), shape("rounded"), outlinecolour("white"), line(4)
rslider  bounds( 10, 10,  75, 75), text("Time L"),    channel("timeL"),   range(0.010, 4, 1, 0.5,0.001),colour(37,59,59)   textcolour(255,255,200), trackercolour(lightblue)
rslider  bounds( 80, 10,  75, 75), text("Time R"),    channel("timeR"),   range(0.010, 4, 1, 0.5,0.001),colour(37,59,59)   textcolour(255,255,200), trackercolour(lightblue)
rslider  bounds(150, 10, 75, 75),  text("Spread"),    channel("spread"),  range(0, 1.00, 1),            colour(37,59,59)   textcolour(255,255,200), trackercolour(lightblue)
rslider  bounds(220, 10, 75, 75),  text("Mix"),       channel("mix"),     range(0, 1.00, 1),            colour(37,59,59)   textcolour(255,255,200), trackercolour(lightblue)
rslider  bounds(290, 10, 75, 75),  text("Level"),     channel("level"),   range(0, 1.00, 1, 0.5),       colour(37,59,59)   textcolour(255,255,200), trackercolour(lightblue)
checkbox bounds(370, 12, 100, 12), text("Reverse"),   channel("reverse"),  value(1),                    colour(255,255, 50)     fontcolour(255,255,200)
checkbox bounds(370, 27, 100, 12), text("Forward"),   channel("forward"),  value(0),                    colour(255,255, 50)     fontcolour(255,255,200)
checkbox bounds(370, 42, 100, 12), text("Link L&R"),  channel("link"),     value(0),                    colour(255,255, 50)     fontcolour(255,255,200)
checkbox bounds(370, 57, 100, 12), text("Time Mod."), channel("TMod"),    value(0),                     colour(255,255, 50)     fontcolour(255,255,200)
checkbox bounds(370, 72, 100, 12), text("Pan Mod."),  channel("PMod"),    value(0),                     colour(255,255, 50)     fontcolour(255,255,200)
}
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-d -n
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;Author: Iain McCurdy (2012)
;http://iainmccurdy.org/csound.html

opcode	Reverse, a, aKkkk			;nb. CAPITAL K CREATE A K-RATE VARIABLE THAT HAS A USEFUL VALUE ALSO AT I-TIME
	ain,ktime,kreverse,kforward,klink	xin			;READ IN INPUT ARGUMENTS
	;four windowing envelopes. An appropriate one will be chosen based on the reversed chunk duration
	ienv1	ftgenonce			0, 0, 131072, 7, 0, 1024,           1, 131072-(1024*2),           1,  1024,       0	;for longest chunk times
	ienv2	ftgenonce			0, 0, 131072, 7, 0, 4096,           1, 131072-(4096*2),           1,  4096,       0
	ienv3	ftgenonce			0, 0, 131072, 7, 0,16384,           1, 131072-(16384*2),          1, 16384,       0
	ienv4	ftgenonce			0, 0, 131072, 7, 0,32768,           1, 131072-(32768*2),          1, 32768,       0	;for shortest chunk times

	atime	interp	ktime			;INTERPOLATE TO CREATE A-RATE VERSION OF K-TIME
		
	iratio	=	octave(1)
	
	ktrig	trigger	klink,0.5,0		;if 'Link L&R' is turned on restart delay time phasors to ensure sync between the two channels
	if ktrig=1 then
	 reinit	RESTART_PHASOR
	endif
	RESTART_PHASOR:
	aptr	phasor	(2/ktime)		;CREATE A MOVING PHASOR THAT WITH BE USED TO TAP THE DELAY BUFFER
	rireturn
	if ktime<0.2 then			;IF CHUNK TIME IS LESS THAN 0.2... (VERY SHORT) 
	 aenv	table3	aptr,ienv4,1		;CREATE AMPLITUDE ENVELOPE
	elseif ktime<0.4 then
	 aenv	table3	aptr,ienv3,1
	elseif ktime<2 then
	 aenv	table3	aptr,ienv2,1
	else					;other longest bracket of delay times
	 aenv	table3	aptr,ienv1,1
	endif
	aptr	=	aptr*atime		;SCALE PHASOR ACCORDING TO THE LENGTH OF THE DELAY TIME CHOSEN BY THE USER
 
 	abuffer	delayr	4 ;+ 0.01		;CREATE A DELAY BUFFER
	abwd	deltap3	aptr			;READ AUDIO FROM A TAP WITHIN THE DELAY BUFFER
	afwd	deltap3	atime			;FORWARD DELAY
		delayw	ain			;WRITE AUDIO INTO DELAY BUFFER
	
	;rireturn				;RETURN FROM REINITIALISATION PASS
	xout	(abwd*aenv*kreverse)+(afwd*kforward)	;SEND AUDIO BACK TO CALLER INSTRUMENT. APPLY AMPLITUDE ENVELOPE TO PREVENT CLICKS.
endop


instr 1
ktimeL   chnget "timeL"
ktimeR   chnget "timeR"
kspread  chnget "spread"
kmix     chnget "mix"
klevel   chnget "level"
kreverse chnget "reverse"
kforward chnget "forward"
kTMod    chnget "TMod"
kPMod    chnget "PMod"

/* LINK */
klink chnget "link"			; if 'Link L&R' is selected
if klink=1&&kTMod=0 then		
 ktrigL	changed	ktimeL,klink
 ktrigR	changed	ktimeR
 if ktrigL=1 then
  chnset	ktimeL,"timeR"
 elseif ktrigR=1 then
  chnset	ktimeR,"timeL"
 endif
endif

a1,a2	ins

if kTMod=1 then						; if time modulation is selected....
 if klink=0 then					; and if 'link L&R' is off...
  ktime1	rspline	ktimeL,ktimeR,0.2,1		; generate delay time value: random spline between ktimeL and ktimeR 
  ktime2	rspline	ktimeL,ktimeR,0.2,1
  ktimeL	limit	ktime1,0.01,4			; assign to delay time variable and limit to prevent out of range values (possible with rspline)
  ktimeR	limit	ktime2,0.01,4
 else
  ktime		rspline	ktimeL,ktimeR,0.2,1		
  ktimeL	limit	ktime,0.01,4
  ktimeR	=	ktimeL				; right channel delay the same as left
 endif
endif

arev1	Reverse	a1,ktimeL,kreverse,kforward,klink		; call UDO
arev2	Reverse	a2,ktimeR,kreverse,kforward,klink

if kPMod=1 then						; if panning modulation is on...
 kpan	rspline	0,1,0.2,1				; pan position generated as a random spline
 ap1	=	(arev1*kpan)     + (arev2*(1-kpan))	; create new left channel
 ap2	=	(arev1*(1-kpan)) + (arev2*kpan)		; create new right channel
 arev1	=	ap1					; reassign left channel to new left channel
 arev2	=	ap2 					; reassign right channel to new right channel
endif

a1	ntrpol	a1,arev1,kmix			; dry/wet mix
a2	ntrpol	a2,arev2,kmix
a1	=	a1 * klevel			; apply level control
a2	=	a2 * klevel
kspread	scale	kspread,1,0.5 			; rescale from range 0 - 1 to 0.5 - 1
aL	sum	a1*kspread,a2*(1-kspread)	; create stereo mix according to Spread control
aR	sum	a2*kspread,a1*(1-kspread)	; create stereo mix according to Spread control
	outs	aL,aR
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; SpectralDelay.csd
; Written by Iain McCurdy, 2016

; This effect implements a spectral delay wherein banded analysed data - amplitudes and frequencies - can be delayed on a band by band basis 
;  and independently for each data type.

; Delay times are typically controlled using function tables as individual controls for each delay time would be impractical.
; In this example the user can choosed from 9 preset table types for delaying amplitude and frequency data. 
; In the future I will add further tables and a user-drawable table option.

; Max.Delay		-	Maximum delay time (before scaling by the table). This is an i-rate control.
; FFT Size		-	FFT size affects the quality of the effect. Small FFT sizes will result in distortions of frequency data.
; Feedback		-	feedback around the spectral delay is performed while the signal is stoll in the format of an f-signal
; Dry/Wet		-	dry/wet control of the effect
; Level			-	output level

<Cabbage>
form caption("") size(530,345), colour("black"), pluginid("SpDl") style("legacy")
image     pos(0, 0), size(530,345), colour("black"), shape("rounded"), outlinecolour(125,130,155), outlinethickness(5) 
;line      bounds(15, 53, 610,  1), colour(150,150,150)

label   bounds(  0,  1,530, 58), text("SPECTRAL DELAY"), fontcolour( 70, 50, 50)
label   bounds(  0,  4,530, 52), text("SPECTRAL DELAY"), fontcolour( 75, 95, 75)
label   bounds(  0,  7,530, 46), text("SPECTRAL DELAY"), fontcolour(150,150,200)
label   bounds(  0, 10,530, 40), text("SPECTRAL DELAY"), fontcolour(220,220,220)

rslider bounds( 25, 60, 90,120), text("Max.Delay"), textbox(1), valuetextbox(1), channel("MaxDelay"), range(0.01, 8, 1, 0.5), colour(105,70,70), trackercolour(205,170,170)

label    bounds(125, 65, 80, 14), text("FFT Size")
combobox bounds(125, 80, 80, 20), text("64","128","256","512","1024","2048"), channel("FFTindex"), value(3)

rslider  bounds(215, 60, 90,120), text("Feedback"), textbox(1), valuetextbox(1), channel("Feedback"), range(0, 1, 0.85), colour(105,70,70), trackercolour(205,170,170)
rslider  bounds(315, 60, 90,120), text("Dry/Wet Mix"), textbox(1), valuetextbox(1), channel("DryWetMix"), range(0, 1, 1), colour(105,70,70), trackercolour(205,170,170)
rslider  bounds(415, 60, 90,120), text("Level"), textbox(1), valuetextbox(1), channel("Level"), range(0, 1, 0.5), colour(105,70,70), trackercolour(205,170,170)

label    bounds( 20,193, 80, 14), text("Amp.Table")
combobox bounds( 20,208, 80, 20), text("Hi to Lo","Lo to Hi","Random","Peak 1","Peak 2","Peak 3","Comb 1","Comb 2","Spring","Flat"), channel("AmpTable"), value(3)
gentable bounds( 20,230,235, 90), identchannel("AmpTableID"), tablenumber(101), amprange(0,1,101), tablecolour("DarkBlue"), zoom(-1), tablebackgroundcolour(200,200,200), tablegridcolour(100,100,100)
label    bounds( 20,322,235, 14), text("Amplitudes Table")

label    bounds(275,193, 80, 14), text("Freq.Table")
combobox bounds(275,208, 80, 20), text("Hi to Lo","Lo to Hi","Random","Peak 1","Peak 2","Peak 3","Comb 1","Comb 2","Spring","Flat"), channel("FrqTable"), value(7)
gentable bounds(275,230,235, 90), identchannel("FrqTableID"), tablenumber(102), amprange(0,1,102), tablecolour("DarkGreen"), zoom(-1), tablebackgroundcolour(200,200,200), tablegridcolour(100,100,100)
label    bounds(275,322,235, 14), text("Frequencies Table")

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -d -+rtmidi=NULL -M0 -m0d 
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 16
nchnls = 2
0dbfs = 1

giViewTabSize	=	-235*2
giAmpTableView	ftgen	101,0,giViewTabSize,10,1
giFrqTableView	ftgen	102,0,giViewTabSize,10,1

; Tables used purely for viewing
giV1				ftgen			201,0,giViewTabSize,-7,1,abs(giViewTabSize),0									; Hi to Lo
giV2				ftgen			202,0,giViewTabSize,-7,0,abs(giViewTabSize),1									; Lo to Hi
giV3				ftgen			203,0,giViewTabSize,-21,1,1													; Random
giV4				ftgen			204,0,giViewTabSize,-16,0,abs(giViewTabSize)*0.25,-4,1,abs(giViewTabSize)*0.75,4,0	; Peak 1
giV5				ftgen			205,0,giViewTabSize,-16,0,abs(giViewTabSize)*0.125,-4,1,abs(giViewTabSize)*0.75,4,0	; Peak 2
giV6				ftgen			206,0,giViewTabSize,-16,0,abs(giViewTabSize)*0.0125,-4,1,abs(giViewTabSize)*0.075,4,0	; Peak 3
giV7				ftgen			207,0,giViewTabSize,-19,8,1*0.5,0,1*0.5										; Comb 1
giV8				ftgen			208,0,giViewTabSize,-19,16,1*0.5,0,1*0.5									; Comb 2
giV9				ftgen			209,0,giViewTabSize,-7,0.9,abs(giViewTabSize),1			; Spring
giV9				ftgen			210,0,giViewTabSize,-7,1,abs(giViewTabSize),1			; Flat

instr	1
 ; read in widgets
 kFFTindex		chnget				"FFTindex"
 kFFTindex		init				1
 kAmpTable		chnget				"AmpTable"
 kAmpTable		init				1
 kFrqTable		chnget				"FrqTable"
 kFrqTable		init				1
 kMaxDelay		chnget				"MaxDelay"
 kDryWetMix		chnget				"DryWetMix"
 kFeedback		chnget				"Feedback"
 kLevel			chnget				"Level"

 iFFTsizes[]	fillarray	64,128,256,512,1024,2048	; array of FFT size values

 aL,aR				ins
 
 ; if changed reinitialise mechanism
 if changed(kFFTindex,kAmpTable,kFrqTable,kMaxDelay)==1 then	; if any of the variables in the brackets change...
  reinit	RESTART													; begin a reinitialisation pass from the label
 endif
 RESTART:															; a label
 
 iFFT				=				iFFTsizes[i(kFFTindex)-1]		; retrieve FFT size value from array
 iMaxDelay			limit			i(kMaxDelay), iFFT/sr,8			; max.delay time must be i-rate

 iftamps1			ftgen			1,0,iFFT,-7,iMaxDelay,iFFT,0							; Hi to Lo
 iftamps2			ftgen			2,0,iFFT,-7,0,iFFT,iMaxDelay							; Lo to Hi
 iftamps3			ftgen			3,0,iFFT,-21,1,iMaxDelay								; Random
 iftamps4			ftgen			4,0,iFFT,-16,0,iFFT*0.25,-4,iMaxDelay,iFFT*0.75,4,0		; Peak 1
 iftamps5			ftgen			5,0,iFFT,-16,0,iFFT*0.125,-4,iMaxDelay,iFFT*0.75,4,0	; Peak 2
 iftamps6			ftgen			6,0,iFFT,-16,0,iFFT*0.0125,-4,iMaxDelay,iFFT*0.075,4,0	; Peak 3
 iftamps7			ftgen			7,0,iFFT,-19,8,iMaxDelay*0.5,0,iMaxDelay*0.5			; Comb 1
 iftamps8			ftgen			8,0,iFFT,-19,16,iMaxDelay*0.5,0,iMaxDelay*0.5			; Comb 2
 iftamps9			ftgen			9,0,iFFT,-7,iMaxDelay-(iMaxDelay*0.1),iFFT,iMaxDelay	; Spring
 iftamps10			ftgen			10,0,iFFT,-7,iFFT,iFFT,iFFT								; Flat
 
 iftfrqs1			ftgen			51,0,iFFT,-7,iMaxDelay,iFFT,0							; Hi to Lo		
 iftfrqs2			ftgen			52,0,iFFT,-7,0,iFFT,iMaxDelay							; Lo to hi
 iftfrqs3			ftgen			53,0,iFFT,-21,1,iMaxDelay								; Random
 iftfrqs4			ftgen			54,0,iFFT,-16,0,iFFT*0.25,-4,iMaxDelay,iFFT*0.75,4,0	; Peak 1
 iftfrqs5			ftgen			55,0,iFFT,-16,0,iFFT*0.125,-4,iMaxDelay,iFFT*0.75,4,0	; Peak 2
 iftfrqs6			ftgen			56,0,iFFT,-16,0,iFFT*0.0125,-4,iMaxDelay,iFFT*0.075,4,0	; Peak 3
 iftfrqs7			ftgen			57,0,iFFT,-19,8,iMaxDelay*0.5,0,iMaxDelay*0.5			; Comb 1
 iftfrqs8			ftgen			58,0,iFFT,-19,16,iMaxDelay*0.5,0,iMaxDelay*0.5			; Comb 2
 iftfrqs9			ftgen			59,0,iFFT,-7,iMaxDelay-(iMaxDelay*0.1),iFFT,iMaxDelay	; Spring
 iftfrqs10			ftgen			60,0,iFFT,-7,iFFT,iFFT,iFFT								; Flat

 					tablecopy		101,200+i(kAmpTable)
 					tablecopy		102,200+i(kFrqTable)
 					chnset			"tablenumber(101)","AmpTableID"
 					chnset			"tablenumber(102)","FrqTableID"
 					
 fsig_outL			pvsinit			iFFT,iFFT/4,iFFT,1
 fsig_inL			pvsanal			aL,iFFT,iFFT/4,iFFT,1									; analyse signal
 fsig_FBL			pvsgain			fsig_outL,kFeedback
 fsig_mixL			pvsmix			fsig_inL,fsig_FBL
 ihandleL, ktimeL	pvsbuffer		fsig_mixL, iMaxDelay									; write into PV buffer
 fsig_outL 			pvsbufread2		ktimeL, ihandleL, i(kAmpTable), 50+i(kFrqTable) 		; read from buffer (with delays)
 awetL				pvsynth			fsig_outL												; resynthesise
 amixL				ntrpol			aL,awetL,kDryWetMix										; dry/wet mix

 fsig_outR			pvsinit			iFFT,iFFT/4,iFFT,1
 fsig_inR			pvsanal			aL,iFFT,iFFT/4,iFFT,1									; analyse signal
 fsig_FBR			pvsgain			fsig_outR,kFeedback
 fsig_mixR			pvsmix			fsig_inR,fsig_FBR
 ihandleR, ktimeR	pvsbuffer		fsig_mixR, iMaxDelay									; write into PV buffer
 fsig_outR 			pvsbufread2		ktimeR, ihandleR, i(kAmpTable), 50+i(kFrqTable) 		; read from buffer (with delays)
 awetR				pvsynth			fsig_outR												; resynthesise
 amixR				ntrpol			aR,awetR,kDryWetMix										; dry/wet mix
 
 					outs			amixL*kLevel, amixR*kLevel
endin

</CsInstruments>

<CsScore>
i 1 0 -1
f 0 3700
</CsScore>

</CsoundSynthesizer>
; StuckBuffer.csd
; Written by Iain McCurdy 2014

; Imitates the sound of a audio stuck buffer.

; CONTROLS
; Thresh.	-	probability of there being a stuck buffer
; Freq.Min	-	Rate of probability test (minimum)
; Freq.Max	-	Rate of probability test (maximum)
;			Threshold setting will also affect the frequency with which new buffer sizes are generated. i.e. a threshold setting of '1' will mean that a stuck buffer will be held indefinitely.
; Hold (button)	-	Hold the current buffer indefinitely
; Size.Min.	-	Random Buffer Size (minimum)
; Size.Max.	-	Random Buffer Size (maximum) - (these values raised to the power of 2 give the actual buffer size in samples)
; Intergerise (button)	- round generated buffer size values to the nearest integer. (Fractional offset of Size.Min is retained)
;			This option also integerises transposition values (see below) 
; Trans.Min.	-	Random Transpose (minimum) in octaves 
; Trans.Max.	-	Random Transpose (maximum) in octaves. Transposition is achieved by playing a stuck buffer faster or slower
; Quality (combobox)	-	interpolation used in playing back the buffer: none/linear/cubic. 
;			This will affect the quality of playback when transposed. Lower quality may be desired for 'Lo Fi' effects.
; Width		-	width of random panning of stuck buffers

<Cabbage>
#define RSliderStyle # colour(150,150,150), trackercolour(white), outlinecolour(85,85,85)#

form caption("Stuck Buffer") size(600,110), colour(50,50,50), pluginid("StBu") style("legacy")

image pos(0, 0), size(600, 110), colour(50,50,50), shape("sharp"), outlinecolour("grey"), outlinethickness(1)

line     bounds( 10, 10,160, 2), colour("grey")
label    bounds( 50,  5, 80, 12), text("PROBABILITY"), colour(50,50,50)
rslider  bounds(  0, 20, 60, 60), text("Thresh."),   channel("thresh"),  range(0, 1.00, 0.4), $RSliderStyle
checkbox bounds( 10, 85,100, 12), text("HOLD"), colour("lime"), channel("hold"),  value(0)
rslider  bounds( 60, 20, 60, 60), text("Freq.Min."), channel("FreqMin"), range(0.1,100.00, 2, 0.5), $RSliderStyle
rslider  bounds(120, 20, 60, 60), text("Freq.Max."), channel("FreqMax"), range(0.1,100.00, 8, 0.5), $RSliderStyle

button   bounds( 95, 84, 50, 16), text("STUCK","STUCK"), active(0), channel("STUCK"), fontcolour:0(40,40,40), fontcolour:1(255,200,200), colour:1(255,80,80)

line     bounds(190, 10,100,  2), colour("grey")
label    bounds(203	,  5, 75, 12), text("BUFFER SIZE"), colour(50,50,50)
rslider  bounds(180, 20, 60, 60), text("Size.Min."), channel("SizeMin"), range(2.00, 16, 10), $RSliderStyle
rslider  bounds(240, 20, 60, 60), text("Size.Max."), channel("SizeMax"), range(2.00, 16, 14), $RSliderStyle

line     bounds(310, 10,100,  2), colour("grey")
label    bounds(325,  5, 70, 12), text("TRANSPOSE"), colour(50,50,50)
rslider  bounds(300, 20, 60, 60), text("Trans.Min."), channel("TransMin"), range(-7.00, 7, 0), $RSliderStyle
rslider  bounds(360, 20, 60, 60), text("Trans.Max."), channel("TransMax"), range(-7.00, 7, 0), $RSliderStyle
combobox bounds(315, 82, 90, 18	), channel("interp"), value(2), text("No Interp.", "Linear", "Cubic")

line     bounds(430, 10,160,  2), colour("grey")
label    bounds(484,  5, 50, 12), text("OUTPUT"), colour(50,50,50)
rslider  bounds(420,20, 60, 60), text("Width"), channel("PanWidth"), range(0, 1.00, 0.5), $RSliderStyle
rslider  bounds(480,20, 60, 60), text("Mix"), channel("mix"), range(0, 1.00, 0.85), $RSliderStyle
rslider  bounds(540,20, 60, 60), text("Level"), channel("level"), range(0, 1.00, 1), $RSliderStyle

checkbox bounds(190, 85,100, 12), text("INTEGERISE"), colour("lime"), channel("integer"),  value(0)

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0
;-odac -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs=1

gibufferL	ftgen	0,0,131072,2,0	; buffer tables
gibufferR	ftgen	0,0,131072,2,0


instr	1

 ;aInL,aInR	diskin	"ClassicalGuitar.wav",1,0,1	; for testing
 ;aL	diskin	"MFEM.wav",1,0,1	; for testing
 ;aR	=	aL
 aInL,aInR	ins

 kporttime	linseg	0,0.01,0.05	; portamento time
 kthresh	chnget	"thresh"
 khold		chnget	"hold"
 kthresh	+=	khold		; add hold value to threshold value
 kFreqMin	chnget	"FreqMin"
 kFreqMax	chnget	"FreqMax"
 kSizeMin	chnget	"SizeMin"
 kSizeMax	chnget	"SizeMax"
 kinteger	chnget	"integer"
 kTransMin	chnget	"TransMin"
 kTransMax	chnget	"TransMax"
 kinterp	chnget	"interp"
 kPanWidth	chnget	"PanWidth"
 kmix		chnget	"mix"
 klevel		chnget	"level"

 kwet		limit	kmix*2,0,1
 kdry		limit	2-(kmix*2),0,1
 
 kSizeMin	portk	kSizeMin,kporttime		; smooth changes to widgets
 kSizeMax	portk   kSizeMax,kporttime	
 kTransMin	portk	kTransMin,kporttime		
 kTransMax	portk   kTransMax,kporttime	

 krate		randomh kFreqMin,kFreqMax,1	; rate of generation of random values
 kTestVal	randomh	0,1,krate		; generate a random value for testing
 
 ktrig	trigger	kTestVal,kthresh,1		; if we are exiting a stuck buffer event, generate a trigger (i.e. new buffer sizes are only generated when a stuck buffer becomes unstuck)
 ksize	trandom	ktrig,kSizeMin,kSizeMax		; generate a new buffer size when a stuck buffer unsticks

 kpan	trandom	ktrig,0.5-(kPanWidth*0.5),0.5+(kPanWidth*0.5)	; generate a random pan value when triggered
 ktrans	trandom	ktrig,kTransMin,kTransMax			; generate a random transposition value when triggered

 if kinteger==1 then				; if 'INTEGERISE' is on...
  kfrac	=	frac(kSizeMin)			; remember fractional value of Size.Min. 
  ksize	=	int(ksize)+kfrac
  ktrans	=	int(ktrans)
 endif

 ksize	limit	ksize,kSizeMin,kSizeMax		; limit buffer size value
 if kinterp==1 then
  ksize	=	int(2 ^ ksize)			; create power of two value (integer)
 else
  ksize	=	2 ^ ksize			; create power of two value
 endif
 
 ktrans	limit	ktrans,kTransMin,kTransMax	; limit transposition
 
 ; write to buffer
 
 if kTestVal>=kthresh then			; normal
  kPhsFrq	=	sr/ksize
 else
  kPhsFrq	=	(sr*octave(ktrans))/ksize
 endif 
 
 aphsr	phasor	kPhsFrq			; create a moving phasor
 aphsr	=	aphsr * ksize		; rescale scope of phasor according to buffer size
 
 if kTestVal>=kthresh then		; normal
  	tablew	aInL,aphsr,gibufferL	; write to buffer
  	tablew	aInR,aphsr,gibufferR
 else					; stuck buffer
  if kinterp==1 then			; choose interpolation method:
   aL	table	aphsr,gibufferL		; none
   aR	table	aphsr,gibufferR
  elseif kinterp==2 then		; linear
   aL	tablei	aphsr,gibufferL
   aR	tablei	aphsr,gibufferR
  else					; cubic
   aL	table3	aphsr,gibufferL
   aR	table3	aphsr,gibufferR
  endif
  aL	=	aL * kpan * kwet	; pan audio
  aR	=	aR * (1-kpan) * kwet
 endif

  aL	sum	aL*kwet, aInL*kdry
  aR	sum	aR*kwet, aInR*kdry
 
 	outs	aL*klevel, aR*klevel
  aL	=	0
  aR	=	0

  ; toggle GUI "STUCK" indicator
  if trigger:k(kTestVal-khold,kthresh,0)==1 then
   chnset	k(0),"STUCK"
  elseif  trigger:k(kTestVal+khold,kthresh,1)==1 then
   chnset	k(1),"STUCK"
  endif
endin

</CsInstruments>  

<CsScore>
i 1 0 3600
e
</CsScore>

</CsoundSynthesizer>
; TempoDelay.csd
; Written by Iain McCurdy, 2012.

; Units for the delay are assumed to be demi-semiquavers.
; Knob for Rhy.Mult. will be replaced with a combobox once comboboxes work in plugins within hosts.
; Width control only applicable when ping-pong delay selected.
; If 'external' is selected as clock source tempo is taken from the host's BPM. 

<Cabbage>
form caption("Tempo Delay") size(565, 90), pluginid("TpDl") style("legacy")
image pos(0, 0), size(565, 90), colour("LightBlue"), shape("rounded"), outlinecolour("white"), outlinethickness(4) 
rslider bounds(10, 11, 70, 70), text("Tempo"), 		textcolour("black"), 		channel("tempo"), 	range(40, 500, 90, 1, 1),   colour(100,100,255),trackercolour(100,100,150)
rslider bounds(75, 11, 70, 70), text("Rhy.Mult."),	textcolour("black"), 		channel("RhyMlt"), 	range(1, 16, 4, 1, 1),      colour(100,100,255),trackercolour(100,100,150)
rslider bounds(140, 11, 70, 70), text("Damping"), 	textcolour("black"), 		channel("damp"), 	range(20,20000, 20000,0.5), colour(100,100,255),trackercolour(100,100,150)
rslider bounds(205, 11, 70, 70), text("Feedback"), 	textcolour("black"), 		channel("fback"), 	range(0, 1.00, 0.8),        colour(100,100,255),trackercolour(100,100,150)
rslider bounds(270, 11, 70, 70), text("Width"),	textcolour("black"), 			channel("width"), 	range(0,  1.00, 1),         colour(100,100,255),trackercolour(100,100,150)
label  bounds(342,  10, 75, 12), text("Clock Source"), FontColour("black")
button bounds(340,  22, 80, 20), text("Internal","External"), channel("ClockSource"), value(0), fontcolour:0("yellow"), fontcolour:1("yellow")
label  bounds(345,  45, 70, 12), text("Delay Type"), FontColour("black")
button bounds(340,  57, 80, 20), text("Simple","Ping-pong"), channel("DelType"), value(1), fontcolour:0("yellow"), fontcolour:1("yellow")
rslider bounds(420, 11, 70, 70), text("Mix"), 		textcolour("black"), 		channel("mix"), 	range(0, 1.00, 0.5), colour(100,100,255),trackercolour(100,100,150)
rslider bounds(485, 11, 70, 70), text("Level"),		textcolour("black"), 		channel("level"), 	range(0, 1.00, 1),   colour(100,100,255),trackercolour(100,100,150)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

instr	1
	kfback		chnget	"fback"				;read in widgets
	kdamp		chnget	"damp"				;
	kmix		chnget	"mix"				;
	klevel		chnget	"level"				;
	kbpm		chnget	"HOST_BPM"			;
	kRhyMlt		chnget	"RhyMlt"			;
	kClockSource	chnget	"ClockSource"			;
	kDelType	chnget	"DelType"			;
	kwidth		chnget	"width"				;
	if kClockSource==0 then				;if internal clock source has been chosen...
	 ktempo	chnget	"tempo"				;tempo taken from GUI knob control
	else
	 ktempo	chnget	"bpm"				;tempo taken from host BPM
	 ktempo	limit	ktempo,40,500			;limit range of possible tempo values. i.e. a tempo of zero would result in a delay time of infinity.
	endif

	ktime	divz	(60*kRhyMlt),(ktempo*8),0.1		;derive delay time. 8 in the denominator indicates that kRhyMult will be in demisemiquaver divisions
	atime	interp	ktime				;interpolate k-rate delay time to create an a-rate version which will give smoother results when tempo is modulated
	
	ainL,ainR	ins				;read stereo inputs
	
	if kDelType==0 then				;if 'simple' delay type is chosen...
	 abuf	delayr	5
	 atapL	deltap3	atime
	 atapL	tone	atapL,kdamp
		delayw	ainL+(atapL*kfback)

	 abuf	delayr	5
	 atapR	deltap3	atime
	 atapR	tone	atapR,kdamp
		delayw	ainR+(atapR*kfback)	
	else						;otherwise 'ping-pong' delay type must have been chosen
	 ;offset delay (no feedback)
	 abuf	delayr	5
	 afirst	deltap3	atime
	 afirst	tone	afirst,kdamp
		delayw	ainL

	 ;left channel delay (note that 'atime' is doubled) 
	 abuf	delayr	10			;
	 atapL	deltap3	atime*2
	 atapL	tone	atapL,kdamp
		delayw	afirst+(atapL*kfback)

	 ;right channel delay (note that 'atime' is doubled) 
	 abuf	delayr	10
	 atapR	deltap3	atime*2
	 atapR	tone	atapR,kdamp;		delayw	ainR+(atapR*kfback)
		delayw	ainR+(atapR*kfback)
	
	 ;create width control. note that if width is zero the result is the same as 'simple' mode
	 atapL	=	afirst+atapL+(atapR*(1-kwidth))
	 atapR	=	atapR+(atapL*(1-kwidth))

	endif
	
	amixL		ntrpol		ainL, atapL, kmix	;CREATE A DRY/WET MIX BETWEEN THE DRY AND THE EFFECT SIGNAL
	amixR		ntrpol		ainR, atapR, kmix	;CREATE A DRY/WET MIX BETWEEN THE DRY AND THE EFFECT SIGNAL
			outs		amixL * klevel, amixR * klevel
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; TimeSlip.csd
; Written by Iain McCurdy, 2015

; Implements realtime time stretching by buffering the realtime audio stream and then triggering event grains reading from the buffer.

; Time Stretch	-	amount of time stretching.
;			e.g. 
;			 1 = no time stretching
;			 2 = half speed
;			 4 = quarter speed etc...
;			 As soon as 'Time Stretch' returns to '1' a quick crossfade is made back to the live audio stream.
; Freeze	-	Activating this button if time stretching is already in progress will freeze time stretching completely (time stretch = infinity)
; 			 Sliding Time Stretch all the way to the right will also trigger the freeze button. 
;			 Density and grain size will be unaffected. 

; Overlaps	-	Number of grains allowed to overlaps simultaneously. Normally set to 2.
; Density	-	Initial density when time stretching begins. 
;			Density also depends upon time stretching factor 
;			Density reduces as stretch increases while grain duration increases, therefore overlaps remains constant.
; Rand.When	-	Adds a random factor to when grains will start. This can be used to reduce or prevent artefacts produced through strict periodic production of grains.
; Rand.Where	-	Adds a random factor to from where in the buffer grains will be read. This can be used to reduce or prevent artefacts produced through strict periodic production of grains.
; Wet		-	Level control of the wet (time stretching) sound. 
;			 This should be adjusted to set a good balance between the dry sound (time stretch=1) and when the time stretching begins (time stretch>1)
;			 Higher densities will result in higher amplitudes when stretching.

<Cabbage>
form caption("Time Slip"), size(700,210), pluginid("TmSl") style("legacy")
image                bounds(0,0,700,210), colour( 40, 40, 60), shape("sharp")
groupbox bounds(  0,  0,700, 90), plant("SlowSlider"), text("Time Ratio"), colour(0,0,0,10) {
hslider  bounds(  5, 15,690, 60), range(1,20,1,0.5,0.0001), channel("stretch"), trackercolour(140,140,160)
label    bounds(  5, 65,690, 14), text("Time Stretch")
button   bounds(  5, 65, 60, 18), fontcolour:0(50,50,50), fontcolour:1(205,255,205), colour:0(0,10,0), colour:1(150,250,150), text("Realtime","Realtime"),channel("realtime")
button   bounds(630, 65, 60, 18), fontcolour:0(50,50,50), fontcolour:1(205,205,255), colour:0(0,0,10), colour:1(150,150,250), text("Freeze","Freeze"), channel("freeze")
}

button   bounds( 60,145,90,18), fontcolour:0(50,50,50), fontcolour:1(255,205,205), colour:0(10,0,0), colour:1(250,150,150), text("Grain Scale","Grain Scale"), channel("GrainScale"), latched(1), value(1)
rslider  bounds(170,100,80,95), range(1,50,4,1,1),         channel("overlaps"), valuetextbox(1), textbox(1), trackercolour(140,140,160), text("Overlaps")
rslider  bounds(250,100,80,95), range(1,50,8,1,1),         channel("dens"),     valuetextbox(1), textbox(1), trackercolour(140,140,160), text("Density")
rslider  bounds(330,100,80,95), range(0,1,0.05,0.5,0.001), channel("RndWhen"),  valuetextbox(1), textbox(1), trackercolour(140,140,160), text("Rand.When")
rslider  bounds(410,100,80,95), range(0,1,0.05,0.5,0.001), channel("RndWhere"), valuetextbox(1), textbox(1), trackercolour(140,140,160), text("Rand.Where")
rslider  bounds(490,100,80,95), range(0,1,0.5),            channel("wet"),      valuetextbox(1), textbox(1), trackercolour(140,140,160), text("Wet")
rslider  bounds(570,100,80,95), range(0,1,1),              channel("level"),    valuetextbox(1), textbox(1), trackercolour(140,140,160), text("Level")

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE
			
giBuffL	ftgen	1,0,(2^24)+1,2,0
giBuffR	ftgen	2,0,(2^24)+1,2,0
gihanning	ftgen	0,  0, 131073,  20,   2, 1					; HANNING WINDOW

instr	1
 kporttime	linseg	0,0.01,0.1
 gkstretch	chnget	"stretch"
 gkstretchP	portk	gkstretch,kporttime
 gkoverlaps	chnget	"overlaps"
 gkdens		chnget	"dens"
 gkRndWhen	chnget	"RndWhen"
 gkRndWhere	chnget	"RndWhere"
 gkwet		chnget	"wet"
 gklevel	chnget	"level"
 gkfreeze	chnget	"freeze"
 gkrealtime	chnget	"realtime"
 gkGrainScale	chnget	"GrainScale"
 gkfreeze	chnget	"freeze"
  
 gaInL,gaInR	ins							; READ REALTIME AUDIO INPUT
 
 gaWPhasor	phasor	sr/ftlen(giBuffL)		; WRITE PHASOR
 kWPhasor	downsamp	gaWPhasor			; K RATE VERSION OF WRITE PHASOR
 		tablew	gaInL,gaWPhasor,giBuffL,1	; WRITE STEREO AUDIO TO TABLES
 		tablew	gaInR,gaWPhasor,giBuffR,1	;
  
 if	gkstretch==1&&active:k(2)==0 then		; IF TIME STRETCH SLIDER IS AT '1' AND 'REALTIME' MODE IS NOT YET ACTIVE, ACTIVATE IT
  event	"i",2,0,-1
  kOn	=	1								; TURN ON REALTIME BUTTON
 	chnset	kOn,"realtime"
 elseif	gkstretch>1&&active:k(3)==0 then	; IF TIME STRETCH SLIDER IS INCREASED BEYOND '1' AND 'TIME STRETCH' MODE IS NOT YET ACTIVE, ACTIVATE IT
  kOff	=	0
 	chnset	kOff,"realtime"					; TURN OFF REALTIME BUTTON
  event	"i",3,0,-1,kWPhasor					; TURN ON TIME STRETCH INSTRUMENT AND SEND IT CURRENT WRITE PHASOR POSITION
 endif
 
endin

instr	2	; NORMAL PLAYBACK
 if gkstretch>1 then						; IF TIME STRETCH SLIDER IS INCREASED BEYOND '1' (LEFT-MOST) TURN OFF THIS NOTE
  turnoff
 endif
 aenv	linsegr	0,0.1,1,4/i(gkdens),0				; RELEASE ENVELOPE
 	outs	gaInL*aenv*gklevel, gaInR*aenv*gklevel
endin

instr	3	; SLOWED PLAYBACK (TRIGGER SOUND GRAINS)
 gkRPhasor	phasor	(sr*(1-gkfreeze))/(ftlen(1)*gkstretchP),p4	; READ START POINT PHASOR
 
 if gkstretch==1 then				; IS TIME STRETCH SLIDER IS RETURNED TO '1' (LEFT-MOST), DEACTIVATE FREEZE BUTTON
  kOff	=	0
  	chnset	kOff,"freeze"
  turnoff
 endif
 
 if gkstretch==20&&gkfreeze==0 then		; TURN ON FREEZE BUTTON IF TIME STRETCH SLIDER IS MOVED ALL THE WAY TO THE RIGHT 
  kOn	=	1
  	chnset	kOn,"freeze"
 elseif trigger:k(gkstretch,19.999,1)==1 then
  	chnset	kOff,"freeze"	
 endif

 if trigger:k(gkrealtime,0.5,0)==1&&gkstretch>1 then	; IF REALTIME BUTTON IS ACTIVATED RETURN TIME STRETCH SLIDER TO '1' (LEFT-MOST)
  kReset	=	1
  		chnset	kReset,"stretch"
 endif

 ksize	 	=	gkGrainScale==1 ? (2*gkstretchP)/gkdens          : 1/gkdens
 kdens		=	gkGrainScale==1 ? (gkdens*gkoverlaps)/gkstretchP : (gkdens*gkoverlaps)/4
 
 ktrig	metro	kdens						; METRONOME TO TRIGGER GRAINS
 schedkwhen	ktrig,0,0,4,random:k(0,gkRndWhen),ksize 	; TRIGGER GRAINS
endin

instr	4	; SOUND GRAINS
 aenv	poscil	1,1/p3,gihanning
 aPtr	line	0,p3,p3*sr
 aPtr	+=	(i(gkRPhasor)*ftlen(giBuffL)) + (random:i(-i(gkRndWhere),0) * sr)
 aSigL	tablei	aPtr,giBuffL
 aSigR	tablei	aPtr,giBuffR

 if gkstretch==1 then			; RELEASE ENVELOPE - USED IF GRAINS ARE INTERRUPTED BY THE TIME STRETCH SLIDER IS RETURNED TO '1'/REALTIME EITHER BY DRAGGING THE SLIDER OR BY ACTIVATING THE REALTIME BUTTON
  arel	linsegr	1,0.2,0
  aSigL	*=	arel
  aSigR	*=	arel
  	turnoff
 endif

 	outs	aSigL*aenv*gklevel*gkwet, aSigR*aenv*gklevel*gkwet
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; TriggerDelay.csd
; Written by Iain McCurdy, 2012.

; This example works best with sharp percussive sounds

; A trigger impulse is generated each time the rms of the input signal crosses the defined 'Threshold' value.
; Each time a new trigger is generated a new random delay time (between user definable limits)
; - and a new random feedback value (again between user definable limits) are generated.

; It is possible to generate feedback values of 1 and greater (which can lead to a continuous build-up of sound)
;  this is included intentionally and the increasing sound will be clipped and can be filtered by reducing the 'Damping' control to produce increasing distortion of the sound within the delay buffer as it repeats 

; Increasing the 'Portamento' control damps the otherwise abrupt changes in delay time.

; 'Width' allows the user to vary the delay from a simple monophonic delay to a ping-pong style delay

<Cabbage>
form caption("Trigger Delay") size(540,240), pluginid("TrDl") style("legacy")
image                  bounds(0, 0,540,240), colour(150,150,205), shape("rounded"), outlinecolour("white"), outlinethickness(4) 

rslider  bounds(  5, 11, 70, 70),  text("Threshold"), textcolour("black"),  channel("threshold"), range(0, 1.00, 0.1, 0.5),      colour( 40, 40, 95),trackercolour("white")
                     
line     bounds( 83, 10, 95, 3), colour("Grey")
label    bounds(100,  6, 60, 10), text("DELAY TIME"), fontcolour("black"), colour(150,150,205)

rslider bounds( 72, 18, 63, 63),  text("Min."),	    textcolour("black"),  channel("dly1"), 	range(0.0001, 2, 0.001,0.5), colour( 40, 40, 95),trackercolour("white")
rslider bounds(130, 18, 63, 63), text("Max."), 	    textcolour("black"),  channel("dly2"), 	range(0.0001, 2, 0.1, 0.5),  colour( 40, 40, 95),trackercolour("white")

line     bounds(202, 10,  95,  3), colour("Grey")
label    bounds(222,  6,  55, 10), text("FEEDBACK"), fontcolour("black"), colour(150,150,205)

rslider bounds(190, 18, 63, 63), text("Min."),      textcolour("black"),  channel("fback1"), 	range(0, 1.200, 0.5),        colour( 40, 40, 95),trackercolour("white")
rslider bounds(248, 18, 63, 63), text("Max."),      textcolour("black"),  channel("fback2"), 	range(0, 1.200, 0.9),        colour( 40, 40, 95),trackercolour("white")

rslider bounds(  5, 81, 70, 70), text("Portamento"), textcolour("black"),  channel("porttime"), 	range(0,  5.00, 0,0.5),         colour( 40, 40, 95),trackercolour("white")
rslider bounds( 65, 81, 70, 70), text("Cutoff"),     textcolour("black"),  channel("cf"), 	range(50,10000, 5000,0.5), colour( 40, 40, 95),trackercolour("white")
rslider bounds(125, 81, 70, 70), text("Bandwidth"),  textcolour("black"),  channel("bw"), 	range(600,22050, 4000,0.5), colour( 40, 40, 95),trackercolour("white")

rslider bounds(  5,151, 70, 70), text("Width"),	    textcolour("black"),  channel("width"), 	range(0,  1.00, 1),         colour( 40, 40, 95),trackercolour("white")
rslider bounds( 65,151, 70, 70), text("Mix"), 	    textcolour("black"),  channel("mix"), 	range(0, 1.00, 0.5),        colour( 40, 40, 95),trackercolour("white")
rslider bounds(125,151, 70, 70), text("Level"),	    textcolour("black"),  channel("level"), 	range(0, 1.00, 1),          colour( 40, 40, 95),trackercolour("white")


xypad bounds(315, 5, 210, 230), channel("cf", "bw"), rangex(50, 10000, 5000), rangey(600, 22050, 4000), text("CF/BW")
}                 
</Cabbage>

<CsoundSynthesizer>                       

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

instr	1
	kthreshold	chnget	"threshold"				;read in widgets
	kdly1		chnget	"dly1"				;read in widgets
	kdly2		chnget	"dly2"				;read in widgets
	kfback1		chnget	"fback1"				;read in widgets
	kfback2		chnget	"fback2"				;read in widgets
	kwidth		chnget	"width"				;
	kmix		chnget	"mix"				;
	klevel		chnget	"level"				;
	kporttime	chnget	"porttime"				;
	kcf		chnget	"cf"
	kbw		chnget	"bw"
	ainL,ainR	ins				;read stereo inputs

	krms	rms	(ainL+ainR)*0.5
	
	ktrig	trigger	krms, kthreshold, 0
	
	kdly	trandom	ktrig, 0, 1
	kdly	expcurve	kdly,8
	kMinDly	min	kdly1,kdly2
	kdly	=	(kdly * abs(kdly2 - kdly1) ) + kMinDly
	
	
	kramp	linseg	0,0.001,1
	
	kcf	portk	kcf, kramp * 0.05
	kbw	portk	kbw, kramp * 0.05
	
	kdly	portk	kdly, kporttime*kramp
	atime	interp	kdly

	kfback	trandom	ktrig, kfback1, kfback2
	
	;offset delay (no feedback)
	abuf	delayr	5
	afirst	deltap3	atime
	afirst	butbp	afirst,kcf,kbw
		delayw	ainL

	;left channel delay (note that 'atime' is doubled) 
	abuf	delayr	10			;
	atapL	deltap3	atime*2
	atapL	clip	atapL,0,0.9
	atapL	butbp	atapL,kcf,kbw
		delayw	afirst+(atapL*kfback)

	 ;right channel delay (note that 'atime' is doubled) 
	 abuf	delayr	10
	 atapR	deltap3	atime*2
	 atapR	clip	atapR,0,0.9
	 atapR	butbp	atapR,kcf,kbw
		delayw	ainR+(atapR*kfback)
	
	 ;create width control. note that if width is zero the result is the same as 'simple' mode
	 atapL	=	afirst+atapL+(atapR*(1-kwidth))
	 atapR	=	atapR+(atapL*(1-kwidth))
	
	amixL		ntrpol		ainL, atapL, kmix	;CREATE A DRY/WET MIX BETWEEN THE DRY AND THE EFFECT SIGNAL
	amixR		ntrpol		ainR, atapR, kmix	;CREATE A DRY/WET MIX BETWEEN THE DRY AND THE EFFECT SIGNAL
			outs		amixL * klevel, amixR * klevel
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; waveset.csd

; 'freeze' is not technically a freeze but instead a very large number of repeats.

; Waveset opcode can be reinitialised by three different methods:
; Manually, using the 'Reset' button, 
; by a built-in metronome, the rate of which can be adjusted by the user
; or by the dynamics of the input sound (the threshold of this dynamic triggereing can be adjusted by the user)
; 'Metro' resetting is disabled when 'Metro Rate' = 0
; 'Threshold' (retrigering by input signal dynamics) is disabled when 'Threshold' = 1 (maximum setting)
; (resetting the opcode will reset its internal buffer and cancel out any time displacement induced by wavelet repetitions) 

<Cabbage>
form caption("waveset") size(510, 90), pluginid("wset") style("legacy")
image pos(0, 0), size(510, 90), colour("Green"), shape("rounded"), outlinecolour("Grey"), outlinethickness(4) 
rslider bounds(5, 10, 70, 70),   text("Repeats"), channel("repeats"), range(1, 100, 1, 1, 1),   colour("yellow"), textcolour("white"), trackercolour("white")
rslider bounds(70, 10, 70, 70),  text("Mult."),   channel("mult"),    range(1, 100, 1, 0.5, 1), colour("yellow"), textcolour("white"), trackercolour("white")
checkbox bounds(140, 23, 100, 30),          channel("freeze"), text("Freeze"), value(0), colour("red"), fontcolour("white"), shape("ellipse")
line bounds(220, 2, 3, 86), colour("Grey")
button bounds(235, 15, 45,45), channel("reset"), text("Reset","Reset"), fontcolour:0("grey"), latched(0)
rslider bounds(290, 10, 70, 70), text("Threshold"),  channel("thresh"), range(0, 1.00, 1), colour("orange"), textcolour("white"), trackercolour("white")
rslider bounds(355, 10, 70, 70), text("Metro Rate"), channel("rate"),   range(0, 5.00, 0), colour("orange"), textcolour("white"), trackercolour("white")
line bounds(430, 2, 3, 86), colour("Grey")
rslider bounds(435,  10, 70, 70), text("Level"), channel("level"), range(0, 1.00, 0.7), colour(255,150, 50), textcolour("white"), trackercolour("white")
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-d -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

;Author: Iain McCurdy (2012)

instr	1
	krep		chnget	"repeats"				;READ WIDGETS...
	kmult		chnget	"mult"					;
	klevel		chnget	"level"					;
	kreset		chnget	"reset"					;
	kthresh		chnget	"thresh"				;
	krate		chnget	"rate"					;
	ktrigger	trigger	kreset,0.5,0			;
	kmetro		metro	krate, 0.99
	kfreeze		chnget	"freeze"
	;asigL, asigR	diskin2	"Songpan.wav",1,0,1			;USE SOUND FILE FOR TESTING
	asigL, asigR	ins
	krms		rms	(asigL+asigR)*0.5
	kDynTrig	trigger	krms,kthresh,0

	if (ktrigger+kmetro+kDynTrig)>0 then
	 reinit UPDATE
	endif
	UPDATE:
	aL 		waveset 	asigL,(krep*kmult)+(kfreeze*1000000000),5*60*sr		;PASS THE AUDIO SIGNAL THROUGH waveset OPCODE. Input duration is defined in samples - in this example the expression given equats to a 5 minute buffer
	aR 		waveset 	asigR,(krep*kmult)+(kfreeze*1000000000),5*60*sr		;PASS THE AUDIO SIGNAL THROUGH waveset OPCODE. Input duration is defined in samples - in this example the expression given equats to a 5 minute buffer
	rireturn
			outs		aL*klevel, aR*klevel		;WAVESET OUTPUT ARE SENT TO THE SPEAKERS
endin
		
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>


</CsoundSynthesizer>



























DiskinFilePlayer.csd

Plays a user selected sound file using diskin2 opcode. 
This file player is best suited for the playback of very long sound files and is less well suited for polyphonic playback.

The sound file can be played back using the Play/Stop button (and the 'Transpose' / 'Speed' buttons to implement pitch/speed change)
 or it can be played back using the MIDI keyboard.

Note that for 'reverse' to be effective either 'loop' needs to be active or inskip needs to be something other than zero

The stretch function works by reducing the speed during silent sections. 
'Threshold' defines the RMS value beneath which audio is regarded as silence.
During 'silent' sections, audio will be muted completely and 'Str.Ratio' will be multipled to the main 'Speed' 

<Cabbage>
form caption("Diskin File Player") size(1025, 310), pluginid("DkPl") style("legacy")
image                    bounds(  0,  0,1025, 310), colour( 70, 30, 30), shape("sharp"), outlinecolour("White"), line(3)	; main panel colouration    

soundfiler           bounds(  5,  5,1015,140), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255)
label bounds(6, 4, 560, 14), text(""), align(left), colour(0,0,0,0), fontcolour(200,200,200), identchannel("stringbox")

image bounds(0,150,1025,160), colour(0,0,0,0), plant("controls"){
filebutton bounds(  5,  5, 80, 25), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5, 40, 95, 25), channel("PlayStop"), text("Play/Stop"), colour("lime"), fontcolour("white")
checkbox   bounds(105,  5,100, 15), channel("loop"), text("Loop On/Off"), colour("yellow"), fontcolour("white")
checkbox   bounds(105, 22,100, 15), channel("reverse"), text("Reverse"), colour("yellow"), fontcolour("white")
label      bounds(118, 40, 75, 12), text("Interpolation"), fontcolour("white")
combobox   bounds(105, 53,100, 20), channel("interp"), items("No interp.", "Linear", "Cubic", "Point Sinc"), value(3), fontcolour("white")
rslider    bounds(215,  5, 70, 70), channel("transpose"), range(-48, 24, 0,1,1),            colour( 90, 50, 50), trackercolour("silver"), text("Transpose"), textcolour("white")
rslider    bounds(280,  5, 70, 70), channel("speed"),     range( -4,  4.00, 1),             colour( 90, 50, 50), trackercolour("silver"), text("Speed"),     textcolour("white")
rslider    bounds(345,  5, 70, 70), channel("inskip"),    range(  0,  1.00, 0),             colour( 90, 50, 50), trackercolour("silver"), text("In Skip"),   textcolour("white")
rslider    bounds(410,  5, 70, 70), channel("AttTim"),    range(0, 5, 0, 0.5, 0.001),       colour( 90, 50, 50), trackercolour("silver"), text("Att.Tim"),   textcolour("white")
rslider    bounds(475,  5, 70, 70), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), colour( 90, 50, 50), trackercolour("silver"), text("Rel.Tim"),   textcolour("white")
rslider    bounds(540,  5, 70, 70), channel("MidiRef"),   range(0,127,60, 1, 1),            colour( 90, 50, 50), trackercolour("silver"), text("MIDI Ref."), textcolour("white")
rslider    bounds(605,  5, 70, 70), channel("level"),     range(  0,  3.00, 1, 0.5),        colour( 90, 50, 50), trackercolour("silver"), text("Level"),     textcolour("white")
}

image      bounds(675,155,140, 65), colour(0,0,0,0), outlinecolour("silver"), outlinethickness(1), shape("sharp"), plant("stretch") {
checkbox   bounds(  5,  5, 80, 15), channel("StretchOnOff"), text("Stretch"), fontcolour("white")
nslider  bounds(  5, 25, 60, 30), channel("threshold"), range(0,1,0.005,1,0.001),  colour( 90, 50, 50), text("Threshold"), textcolour("white")
nslider  bounds( 75, 25, 60, 30), channel("stretchratio"), range(0.01,8.00,0.25,1,0.01),  colour( 90, 50, 50), trackercolour("silver"), text("Str.Ratio"), textcolour("white")
}

image bounds(820, 155,200, 65), colour(0,0,0,0), outlinecolour("silver"), outlinethickness(1), shape("sharp"), plant("speedmod") {
label      bounds(  0,  5,200, 12), text("Speed Modulation"), fontcolour("white")
nslider  bounds(  5, 25, 60, 30), channel("ModRange"), range(0,4,0,1,0.001),  colour( 90, 50, 50), text("Mod.Range"), textcolour("white")
nslider  bounds( 70, 25, 60, 30), channel("Rate1"), range(0,30,1,1,0.001),  colour( 90, 50, 50), text("Rate 1"), textcolour("white")
nslider  bounds(135, 25, 60, 30), channel("Rate2"), range(0,30,2,1,0.001),  colour( 90, 50, 50), text("Rate 2"), textcolour("white")
}

keyboard bounds( 5,230,1015, 75)


</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

massign	0,3	; all midi notes on all channels sent to instrument 3

giInterpArr[] array 1, 2, 4, 8
gSfilepath	init	""


opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin				; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:					; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:				; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1		; Create a new string of just the file name
	xout	Sname			; Send it back to the caller instrument
endop



instr	1
 gkPlayStop	chnget	"PlayStop"		; read in widgets
 gkloop		chnget	"loop"
 gktranspose	chnget	"transpose"
 gkspeed	chnget	"speed"
 gkinterp	chnget	"interp"
 gkreverse	chnget	"reverse"
 gklevel	chnget	"level"
 gSfilepath	chnget	"filename"		; read in file path string from filebutton widget
 gkStretchOnOff	chnget	"StretchOnOff"
 gkstretchratio	chnget	"stretchratio"
 gkthreshold	chnget	"threshold"
 gkModRange	chnget	"ModRange"
 gkRate1	chnget	"Rate1"
 gkRate2	chnget	"Rate2"
 
 if changed:k(gSfilepath)==1 then		; call instrument to update waveform viewer  
  event "i",99,0,0
 endif
 
 ktrig		trigger	gkPlayStop,0.5,0	; if play/stop button toggles from low (0) to high (1) generate a '1' trigger
 schedkwhen	ktrig,0,0,2,0,-1		; start instrument 2
 
 ktrig1	changed	gktranspose			; if 'transpose' button is changed generate a '1' trigger
 ktrig2	changed	gkspeed				; if 'speed' button is changed generate a '1' trigger
 
 if ktrig1==1 then				; if transpose control has been changed...
  chnset	semitone(gktranspose),"speed"	; set speed according to transpose value
 elseif ktrig2==1&&gkspeed>=0 then		; if speed control has been changed...
  chnset	log2(gkspeed)*12,"transpose"	; set transpose control according to speed value
 endif
endin

instr	2

 if gkPlayStop==0 then				; if play/stop is off (stop)...
  turnoff					; turn off this instrument
 endif						
 iStrLen 	strlen gSfilepath		; derive string length
 if iStrLen > 0 then				; if string length is greater than zero (i.e. a file has been selected) then...
  iAttTim	chnget	"AttTim"		; read in amplitude envelope attack time widget
  iRelTim	chnget	"RelTim"		; read in amplitude envelope attack time widget
  if iAttTim>0 then				; 
   kenv	linsegr	0,iAttTim,1,iRelTim,0
  else								
   kenv	linsegr	1,iRelTim,0			; attack time is zero so ignore this segment of the envelope (a segment of duration zero is not permitted
  endif
  kenv	expcurve	kenv,8			; remap amplitude value with a more natural curve
  aenv	interp		kenv			; interpolate and create a-rate envelope
  iFileLen	filelen	gSfilepath		; derive chosen sound file length
  iNChns	filenchnls	gSfilepath	; derive the number of channels (mono=1 / stereo=2) from the chosen  sound file
  iinskip	chnget	"inskip"		; read in inskip widget
  iloop	chnget	"loop"				; read in 'loop mode' widget
  ktrig	changed	gkloop,gkinterp			; if loop setting or interpolation mode setting
  if ktrig==1 then				; if loop setting has been changed...
   reinit RESTART				; reinitialise from label RESTART
  endif						
  RESTART:					
  kporttime	linseg	0,0.001,0.05		; portamento time function. (Rises quickly from zero to a held value.)
  kspeed	portk	gkspeed,kporttime	; apply portamento smoothing to changes in speed
  
  kMod		jspline	gkModRange,gkRate1,gkRate2
  kspeed	*=	octave(kMod)
  
  if gkStretchOnOff!=1 kgoto SKIP_STRETCH
   a1,a2	init	0
   krms	rms	a1+a2
   if krms<gkthreshold then
    kspeed	*=	gkstretchratio
    kmute	=	0
   else
    kmute	=	1
   endif
   amute		interp	kmute
   aenv		*=	amute
  SKIP_STRETCH:
  
  if iNChns==2 then				; if stereo...
   a1,a2	diskin2	gSfilepath,kspeed*(1-(gkreverse*2)),iinskip*iFileLen,i(gkloop),0,giInterpArr[i(gkinterp)-1]	; use stereo diskin2
  	outs	a1*gklevel*aenv, a2*gklevel*aenv	; send audio to outputs
  elseif iNChns==1 then				; if mono
   a1	diskin2	gSfilepath,kspeed*(1-(gkreverse*2)),iinskip*iFileLen,i(gkloop),0,giInterpArr[i(gkinterp)-1]	; use mono diskin2
  	outs	a1*gklevel*aenv, a1*gklevel*aenv	; send audio to outputs
  endif
 endif
endin


instr	3
 icps	cpsmidi							; read in midi note data as cycles per second
 iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
 iStrLen 	strlen	gSfilepath				; derive string length
 if iStrLen > 0 then						; if string length is greater than zero (i.e. a file has been selected) then...
  iMidiRef	chnget	"MidiRef"				; MIDI unison reference note
  iinskip	chnget	"inskip"				; read in inskip widget
  iloop		chnget	"loop"					; read in 'loop mode' widget
  iAttTim	chnget	"AttTim"				; read in amplitude envelope attack time widget
  iRelTim	chnget	"RelTim"				; read in amplitude envelope attack time widget
  if iAttTim>0 then						; 
   kenv	linsegr	0,iAttTim,1,iRelTim,0
  else								
   kenv	linsegr	1,iRelTim,0					; attack time is zero so ignore this segment of the envelope (a segment of duration zero is not permitted
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  iFileLen	filelen	gSfilepath				; derive chosen sound file length
  ispeed		=	icps/cpsmidinn(iMidiRef)	; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)
  iNChns	filenchnls	gSfilepath			; derive the number of channels (mono=1 / stereo=2) from the chosen  sound file
  if iNChns==2 then						; if stereo...
   a1,a2	diskin2	gSfilepath,ispeed*(1-(gkreverse*2)),iinskip*iFileLen,i(gkloop),0,giInterpArr[i(gkinterp)-1]	; use stereo diskin2
  	outs	a1*gklevel*aenv*iamp, a2*gklevel*aenv*iamp	; send audio to outputs
  elseif iNChns==1 then						; if mono
   a1		diskin2	gSfilepath,ispeed*(1-(gkreverse*2)),iinskip*iFileLen,i(gkloop),0,giInterpArr[i(gkinterp)-1]	; use mono diskin2
  	outs	a1*gklevel*aenv*iamp, a1*gklevel*aenv*iamp	; send audio to outputs
  endif
 endif
endin

instr	99
 Smessage sprintfk "file(%s)", gSfilepath			; print sound file image to fileplayer
 chnset Smessage, "filer1"

 /* write file name to GUI */
 Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
 Smessage sprintfk "text(%s)",Sname				; create string to update text() identifier for label widget
 chnset Smessage, "stringbox"					; send string to  widget

endin

</CsInstruments>  

<CsScore>
i 1 0 10000
</CsScore>

</CsoundSynthesizer>
; FileRecorder.csd
; Written by Iain McCurdy, 2014
; 
; Records audio to a file on disk. 
; 
; The audio file name includes the date and time. (This idea comes courtesy of Rory Walsh.)
; 
; Toggling record off and on will append the new recording onto the end of the previously recorded audio.
; To start a new file, click 'New File'.


<Cabbage>
form caption("File Recorder") size(230, 45), colour(0,0,0) pluginid("FRec") style("legacy")
image               bounds(  0,  0,230, 45), colour(100,100,100), outlinecolour("White"), line(3)
checkbox bounds( 10, 10, 75, 25), channel("record"), text("Record"), colour("red"), fontcolour("white")
button   bounds( 90, 10, 65, 25), colour("red"), text("New File","New File"), channel("reset"), latched(0)
checkbox bounds(165, 10, 75, 25), channel("play"), text("Play"), colour("green"), fontcolour("white")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs = 1

gkRecordingActiveFlag	init	0
gkFileRecorded		init	0

instr	1
 gaL,gaR	ins
 gkrecord	chnget	"record"
 gkreset	chnget	"reset"
 gkplay		chnget	"play"
 kRecStart	trigger	gkrecord,0.5,0

 if kRecStart==1 && gkRecordingActiveFlag==0 then
  event	"i",9000,0,-1
  gkRecordingActiveFlag	=	1
 endif
 
 kPlayStart	trigger	gkplay,0.5,0
 if kPlayStart==1 && gkFileRecorded==1 then
  event	"i",9001,ksmps/sr,3600
 endif

 kResetTrig	trigger	gkreset,0.5,1
 if kResetTrig==1 && gkRecordingActiveFlag==1 then
  event	"i",9000,0,-1
 endif  
endin


instr 9000	; record file
 print	p1
 if gkplay==1 then
  chnset	k(0),"record"
  turnoff
 endif
 gkFileRecorded		init	1
 itim     date
 Stim     dates     itim
 itim     date
 Stim     dates     itim
 Syear    strsub    Stim, 20, 24
 Smonth   strsub    Stim, 4, 7
 Sday     strsub    Stim, 8, 10
 iday     strtod    Sday
 Shor     strsub    Stim, 11, 13
 Smin     strsub    Stim, 14, 16
 Ssec     strsub    Stim, 17, 19
 Sfilnam  sprintf  "%s_%s_%02d_%s_%s_%s.wav", Syear, Smonth, iday, Shor,Smin, Ssec
 gSname   sprintf "FileRecorder_%s", Sfilnam
 if gkrecord==1 then			; record
  fout gSname, 8, gaL, gaR
 endif
 gkRecordingActiveFlag	=	1 - release()
endin

instr	9001	; play file
 if gkplay==0 then
  turnoff
 endif 
   aL,aR	diskin2	gSname,1
  	outs	aL,aR
 iFileLen	filelen	gSname
 p3	=	iFileLen
 xtratim	0.1 
 krelease	release
 	chnset	1-krelease,"play"
endin

</CsInstruments>  

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>; FileStretcher.csd
; Written by Iain McCurdy, 2014

; Used to create a time-stretched version of an input file
; Often when time-stretching a sound when wishing to retain the priniciple characteristics of the source sound,
;  we play the attack portion of the sound at normal speed (as well, often, as the release portion) and only stretch
;  sound in the middle of the source - often called the 'sustain' portion.
; This example facilitates this technique by allowing the user to select the portion of sound to stretch by 
;  clicking and dragging upon the waveform view creating a highlighted area. Time stretching will only be applied to this 
;  portion of the sound.

; The user defines a time-stretching zone by clicking and dragging on the waveform view once a file has been opened.
; 'Duration' defines the total duration of the output file.

; 'Play' auditions the file stretch. 
; 'Record' renders the time-stretched audio to disk offline.
; The console reports the name of the output file and a message: 'Done!' when the rendering is complete. 
;    The output file will be created in the same directory as the input file and with the same name but with the word '_stretched' and a unique number suffixed. 

; 'Aud.Lev.' provides a amplitude level control (the rendered file is unaffected and always renders at full amplitude.

; Adding a small amount of jitter to the file reading pointer when time-stretching can reduce the sense of a frozen spectrum 
;  evident during long time stretches. Jitter depth and rate can be modified.

<Cabbage>
form caption("File Stretcher") size(580,430), colour(0,0,0) pluginid("FiSt"), guirefresh(10)  style("legacy")
image                bounds(  0,  0,580,430), colour(50,50,60), outlinecolour("White"), line(3), shape("sharp")

soundfiler           bounds(  5,  5,570,150), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255)
label bounds(6, 4, 560, 14), text(""), align(left), colour(0,0,0,0), fontcolour(200,200,200), identchannel("stringbox")
label      bounds( 6, 20,450, 13), text("Click and drag on waveform to select sound portion for time stretching..."), align(left), colour("black"), fontcolour("white"), visible(0), identchannel("InstructionID")

filebutton bounds(  7,160, 83, 20), text("OPEN FILE","OPEN FILE"), fontcolour(255,255,100) channel("filename"), shape("ellipse"), channel("beg","len")
button     bounds(  7,183, 83, 20), text("PLAY STR.","PLAY STR."), channel("PlayStr"), value(0), latched(0), fontcolour(100,255,100)
button     bounds( 96,183, 83, 20), text("PLAY NORM.","PLAY NORM."), channel("PlayNorm"), value(0), latched(0), fontcolour(150,150,255)
button     bounds(  7,206, 83, 20), text("RECORD","RECORD"), channel("Record"), value(0), latched(0), fontcolour(255,100,100)
button     bounds( 96,206, 83, 20), text("STOP","STOP"), channel("Stop"), value(0), latched(0), fontcolour(150,150,255)

rslider    bounds(178,160, 60, 60), text("Duration"), channel("Duration"), range(0.1, 60.00, 3,0.5,0.001), colour(30,30,40), trackercolour("white"), fontcolour("white"), outlinecolour(150,150,150)
rslider    bounds(238,160, 60, 60), text("Transpose"), channel("Transpose"), range(-48, 48.00, 0,1,0.5), colour(30,30,40), trackercolour("white"), fontcolour("white"), outlinecolour(150,150,150)
;nslider  bounds(180,160,110, 35), text("Stretched Duration"), channel("Duration"), range(0.1, 800.00, 3,1,0.001), colour(0,0,0), fontcolour("white"), textbox(1)
label      bounds(300,160, 80, 13), text("FFT Size"), fontcolour("white")
combobox   bounds(300,177, 80, 17), channel("FFTSize"), items("32768", "16384", "8192", "4096", "2048", "1024", "512", "256", "128", "64", "32"), value(5), fontcolour("white")
checkbox   bounds(300,198, 95, 15), channel("lock"), text("Phase Lock"), fontcolour("white"), colour(255,0,0)

rslider    bounds(390,160, 60, 60), text("Aud.Lev."), channel("Level"),  range(0, 1.00, 0.9),       colour(30,30,40), trackercolour("white"), fontcolour("white"), outlinecolour(150,150,150)
rslider    bounds(450,160, 60, 60), text("Jit.Dep."), channel("JitDep"), range(0, 1.00, 0.2),       colour(30,30,40), trackercolour("white"), fontcolour("white"), outlinecolour(150,150,150)
rslider    bounds(510,160, 60, 60), text("Jit.Rte."), channel("JitRte"), range(0.5, 100.00, 2,0.5), colour(30,30,40), trackercolour("white"), fontcolour("white"), outlinecolour(150,150,150)

csoundoutput bounds(  0,230,580,200), text("Csound Output")

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

gichans		init	0		; 
giReady		init	0		; flag to indicate function table readiness
gSfilepath	init	""
giFFTSizes[]	array	32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32	; an array is used to store FFT window sizes
;maxalloc	2,1	; Only allow one sound playing/stretching instrument at a time
gkactive	init	0


opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin						; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:							; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:						; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1	; Create a new string of just the file name
	xout	Sname				; Send it back to the caller instrument
endop

instr	1
 gkPlayStr	chnget	"PlayStr"
 gkPlayNorm	chnget	"PlayNorm"
 gkRecord	chnget	"Record"
 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 gkLevel	chnget	"Level"
 gkTranspose	chnget	"Transpose"
 kporttime	linseg	0,0.01,0.05
 gkTranspose	portk	semitone(gkTranspose),kporttime
 gklock		chnget	"lock"			; Phase locking in mincer opcode
 gkAttack	chnget	"beg"
 gkLen		chnget	"len" 
 
 if trigger(gkAttack,1,0)==1 then		; Hide instruction once stretch area has been selected
  chnset "visible(0)", "InstructionID" 
 endif
 
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0.01				; call instrument to update sample storage function table 
 endif   
 
 ktrig	trigger	gkPlayStr,0.5,0			; Generate an impulse if PLAY STRETCH button is clicked
 schedkwhen	ktrig,0,0,2,0,0.01

 ktrig	trigger	gkPlayNorm,0.5,0		; Generate an impulse if PLAY NORM. button is clicked
 schedkwhen	ktrig,0,0,3,0,0.01

 ktrig	trigger	gkRecord,0.5,0			; Generate an impulse if RECORD button is clicked
 schedkwhen	ktrig,0,0,4,0,0.1
 
endin

instr	99	; load sound file
 
 /* write file selection to function tables */
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 gitableL	ftgen	1,0,0,1,gSfilepath,0,0,1
 if gichans==2 then
  gitableR	ftgen	2,0,0,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero
 Smessage sprintfk "file(%s)", gSfilepath			; print sound file image to fileplayer
 chnset Smessage, "filer1"

 /* write file name to GUI */
 Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
 Smessage sprintfk "text(%s)",Sname				; create string to update text() identifier for label widget
 chnset Smessage, "stringbox"					; send string to  widget

 if i(gkAttack)==0 then						; Reveal instruction when a file is opened for the first time
  chnset "visible(1)", "InstructionID"
 endif	

 /* write to pvx files */					; experimental
 ;#define	ANALYSISFILE_L	#"pvswriteFileL.pvx"#		; experimental
 ;#define	ANALYSISFILE_R	#"pvswriteFileR.pvx"#		; experimental
 ;kcount	=	0					; experimental
 ;loop:								; experimental
 ;acount	interp	kcount					; experimental
 ;asampL	table3	acount,1				; experimental	
 ;asampR	table3	acount,2                                ; experimental
 ;fsigL	pvsanal		asampL, 1024, 256, 1024, 1  		; experimental
 ;fsigR	pvsanal		asampR, 1024, 256, 1024, 1      	; experimental
 ;pvsfwrite 	fsigL, $ANALYSISFILE_L				; experimental
 ;pvsfwrite 	fsigR, $ANALYSISFILE_R				; experimental
 ;loop_lt	kcount,1,ftlen(1),loop				; experimental
 ;turnoff							; experimental

endin

instr	2	; play stretched
 if giReady = 1 then				; i.e. if a file has been loaded
  
  gkactive init i(gkactive) + 1	;INCREMENT NOTE COUNTER
  if gkactive>1 then		;IF POLYPHONY IS EXCEEDED (THROUGH THE ADDITION OF NEW NOTE)
   turnoff			;REMOVE THIS NOTE
  endif
  krel release			;IF NOTE HELD = 0, IF NOTE RELEASED = 1
  ktrig trigger krel,0.5,0	;WHEN RELEASE FLAG CROSSES 0.5 UPWARDS, I.E. NOTE HAS BEEN RELEASED...	
  if ktrig==1 then		
   gkactive = gkactive - 1	;...DECREMENT ACTIVE NOTES COUNTER
  endif
  
  kStop		chnget	"Stop"
  ktrig		trigger	kStop,0.5,0		; Generate an impulse if 'STOP' is clicked
  if ktrig==1 then
   turnoff
  endif

  iFileLen	=	ftlen(gitableL)/sr											; File length in seconds
  iAttPnt	=	(i(gkAttack) == 0 ? 0.01 : (i(gkAttack)/sr))				; If stretch points haven't been set, replace with defaults. 
  iRelPnt	=	(i(gkAttack) == 0 ? 0.01 : ((i(gkAttack) + i(gkLen))/sr))
  
  iDuration	chnget	"Duration"
  
  p3		limit	iDuration, iFileLen, iDuration
  
  iFFTSize	chnget	"FFTSize"
  iFFTSize	=	giFFTSizes[iFFTSize-1]
  
  ; File reading pointer main shape
  aptr		linseg	0,iAttPnt,iAttPnt, p3-iAttPnt-(iFileLen-iRelPnt), iRelPnt, iFileLen-iRelPnt, iFileLen

  ; File reading pointer jitter
  kJitDep	chnget	"JitDep"
  kJitRte	chnget	"JitRte"
  irise		=	0.01
  kJitEnv	linseg	0,iAttPnt,0, irise, .1, p3-iAttPnt-(iFileLen-iRelPnt) - (2*irise), .1, irise, 0 
  ajit		jspline	kJitDep*kJitEnv,kJitRte*0.5,kJitRte*2

  if gichans=1 then						; Mono
   a1	mincer		aptr+ajit, 1, gkTranspose, gitableL, gklock, iFFTSize
   ;kptr	linseg	0,iAttPnt,iAttPnt, p3-iAttPnt-(iFileLen-iRelPnt), iRelPnt, iFileLen-iRelPnt, iFileLen	; experimental
   ;a1	pvoc		kptr, gkTranspose, $ANALYSISFILE_L							; experimental
  	outs	a1*gkLevel,a1*gkLevel

  elseif gichans=2 then						; Stereo
   a1	mincer		aptr+ajit, 1, gkTranspose, gitableL, gklock, iFFTSize
   a2	mincer		aptr+ajit, 1, gkTranspose, gitableR, gklock, iFFTSize
   ;kptr	linseg	0,iAttPnt,iAttPnt, p3-iAttPnt-(iFileLen-iRelPnt), iRelPnt, iFileLen-iRelPnt, iFileLen	; experimental
   ;a1	pvoc		kptr, gkTranspose, $ANALYSISFILE_L							; experimental
   ;a2	pvoc		kptr, gkTranspose, $ANALYSISFILE_R							; experimental
  	outs	a1*gkLevel,a2*gkLevel
  endif
 endif
endin

instr	3	; normal speed playback
 p3	=	ftlen(gitableL)/(sr*i(gkTranspose))
 aptr	line	0,p3,1
 aL	table3	aptr,gitableL,1
 if gichans==1 then
 	outs	aL*gkLevel,aL*gkLevel
 else
 aR	table3	aptr,gitableR,1
	outs	aL*gkLevel,aR*gkLevel 
 endif 
 kStop		chnget	"Stop"
 ktrig		trigger	kStop,0.5,0		; Generate an impulse if 'STOP' is clicked
 if ktrig==1 then
  turnoff
 endif
endin


instr	4	; record/render
 if giReady = 1 then				; i.e. if a file has been loaded

  iFileLen	=	ftlen(gitableL)/sr						; File length in seconds
  iAttPnt	=	(i(gkAttack) == 0 ? 0.01 : (i(gkAttack)/sr))			; If stretch points haven't been set, replace with defaults. 
  iRelPnt	=	(i(gkAttack) == 0 ? 0.01 : ((i(gkAttack) + i(gkLen))/sr))
  
  iDuration	chnget	"Duration"
  
  p3		=	iDuration
     		
  ilen		strlen	gSfilepath			; Derive string length.
  SOutputName	strsub	gSfilepath,0,ilen-4		; Remove ".wav"
  SOutputName	strcat	SOutputName,"_stretched"	; Add suffix
  iDate		date
  SDate		sprintf	"%i",iDate
  SOutputName	strcat	SOutputName,SDate		; Add date
  SOutputName	strcat	SOutputName,".wav"		; Add extension
  
  
  iFFTSize	chnget	"FFTSize"
  iFFTSize	=	giFFTSizes[iFFTSize-1]
  
  iNKCycles	=	(iDuration * sr) / ksmps
  kCount	init	0
  
  loop:
  
  ; File reading pointer main shape
  aptr		linseg	0,iAttPnt,iAttPnt, p3-iAttPnt-(iFileLen-iRelPnt), iRelPnt, iFileLen-iRelPnt, iFileLen

  ; File reading pointer jitter
  kJitDep	chnget	"JitDep"
  kJitRte	chnget	"JitRte"
  irise		=	0.01
  kJitEnv	linseg	0,iAttPnt,0, irise, .1, p3-iAttPnt-(iFileLen-iRelPnt) - (2*irise), .1, irise, 0 
  ajit		jspline	kJitDep*kJitEnv,kJitRte*0.5,kJitRte*2

  if gichans=1 then						; Mono
   a1	mincer		aptr+ajit, 1, gkTranspose, gitableL, gklock, iFFTSize
   ;kptr	linseg	0,iAttPnt,iAttPnt, p3-iAttPnt-(iFileLen-iRelPnt), iRelPnt, iFileLen-iRelPnt, iFileLen	; experimental
   ;a1	pvoc		kptr, gkTranspose, $ANALYSISFILE_L							; experimental
  	fout	SOutputName,8,a1

  elseif gichans=2 then						; Stereo
   a1	mincer		aptr+ajit, 1, gkTranspose, gitableL, gklock, iFFTSize
   a2	mincer		aptr+ajit, 1, gkTranspose, gitableR, gklock, iFFTSize
   ;kptr	linseg	0,iAttPnt,iAttPnt, p3-iAttPnt-(iFileLen-iRelPnt), iRelPnt, iFileLen-iRelPnt, iFileLen	; experimental
   ;a1	pvoc		kptr, gkTranspose, $ANALYSISFILE_L							; experimental
   ;a2	pvoc		kptr, gkTranspose, $ANALYSISFILE_R							; experimental
  	fout	SOutputName,8,a1,a2
  endif

	loop_lt	kCount, 1, iNKCycles, loop
	printks	SOutputName,0
	printks	"\nDone!\n",0
	turnoff
	
 endif
endin

</CsInstruments>  

<CsScore>
i 1 0 10000
</CsScore>

</CsoundSynthesizer>
; Flooper2FilePlayer.csd
; Written by Iain McCurdy, 2014

; Load a user selected sound file into a GEN 01 function table and plays it back using flooper2. 
; This file player is best suited for polyphonic playback and is less well suited for the playback of very long sound files .
; 
; The sound file can be played back using the Play/Stop button (and the 'Transpose' / 'Speed' buttons to implement pitch/speed change)
;  or it can be played back using the MIDI keyboard.
; 
; The loop points can be set either by using the loop 'Start' and 'End' sliders or by clicking and dragging on the waveform view -
;  - flooper2 will take the values from the last control input moved.

<Cabbage>
form caption("Flooper2 File Player") size(805,340), colour(0,0,0) pluginid("FlFP") style("legacy")
image                     bounds(  0,  0,805,340), colour(155, 50,  0), outlinecolour("White"), line(3), shape("sharp")	; main panel colouration    

soundfiler bounds(  5,  5,795,175), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 
label bounds(6, 4, 560, 14), text(""), align(left), colour(0,0,0,0), fontcolour(200,200,200), identchannel("stringbox")

image    bounds(  0,180,805,160), colour(155,30,0,0), outlinecolour("white"), line(2), shape("sharp"), plant("controls"){
filebutton bounds(  5, 10, 80, 25), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5, 40, 95, 25), channel("PlayStop"), text("Play/Stop"), colour("yellow"), fontcolour("white")

label      bounds(110, 12, 80, 12), text("Looping Mode"), fontcolour("white")
combobox   bounds(110, 25, 80, 20), channel("mode"), items("Forward", "Backward", "Fwd./Bwd."), value(1), fontcolour("white")

line       bounds(207, 10,  2, 65), colour("Grey")
                        
label      bounds(302,  4, 43, 8), text("L   O   O   P"), fontcolour("white")
rslider    bounds(210, 15, 60, 60), channel("LoopStart"), range(0, 1, 0),                   colour(100, 30, 10), text("Start"),     textcolour("white"), trackercolour(175,130,110)
rslider    bounds(265, 15, 60, 60), channel("LoopEnd"),   range(0, 1, 1),                   colour(100, 30, 10), text("End"),       textcolour("white"), trackercolour(175,130,110)
rslider    bounds(320, 15, 60, 60), channel("crossfade"), range(0, 1.00, 0.01,0.5),         colour(100, 30, 10), text("Fade"),      textcolour("white"), trackercolour(175,130,110)
rslider    bounds(375, 15, 60, 60), channel("inskip"),    range(0, 1.00, 0),                colour(100, 30, 10), text("inskip"),    textcolour("white"), trackercolour(175,130,110)
line       bounds(440, 10,  2, 65), colour("Grey")

label      bounds(475,  4, 53, 8), text("S   P   E   E   D"), fontcolour("white")
rslider    bounds(445, 15, 60, 60), channel("transpose"), range(-24, 24, 0,1,1),            colour(100, 30, 10), text("Transpose"), textcolour("white"), trackercolour(175,130,110)
rslider    bounds(500, 15, 60, 60), channel("speed"),     range( 0, 4.00, 1, 0.5),          colour(100, 30, 10), text("Speed"),     textcolour("white"), trackercolour(175,130,110)
line       bounds(560, 10,  2, 65), colour("Grey")

label      bounds(576,  4, 90, 8), text("E   N   V   E   L   O   P   E"), fontcolour("white")
rslider    bounds(565, 15, 60, 60), channel("AttTim"),    range(0, 5, 0, 0.5, 0.001),       colour(100, 30, 10), text("Att.Tim"),   textcolour("white"), trackercolour(175,130,110)
rslider    bounds(620, 15, 60, 60), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), colour(100, 30, 10), text("Rel.Tim"),   textcolour("white"), trackercolour(175,130,110)
line       bounds(680, 10,  2, 65), colour("Grey")

label      bounds(702,  4, 80, 8), text("C   O   N   T   R   O   L"), fontcolour("white")
rslider    bounds(685, 15, 60, 60), channel("MidiRef"),   range(0,127,60, 1, 1),            colour(100, 30, 10), text("MIDI Ref."), textcolour("white"), trackercolour(175,130,110)
rslider    bounds(740, 15, 60, 60), channel("level"),     range(  0,  3.00, 1, 0.5),        colour(100, 30, 10), text("Level"),     textcolour("white"), trackercolour(175,130,110)

keyboard bounds(5, 80, 795, 75)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0 -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs = 1

		massign	0,3
gichans		init	0
giReady		init	0
gSfilepath	init	""

gitableL	ftgen	1,0,2,2,0
gkTabLen	init	ftlen(gitableL)

opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin						; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:							; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:						; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1	; Create a new string of just the file name
	xout	Sname				; Send it back to the caller instrument
endop

instr	1
 gkmode		chnget	"mode"
 kLoopStart	chnget	"LoopStart"		; sliders
 kLoopEnd	chnget	"LoopEnd"		;  "
 kbeg		chnget	"beg"			; click and drag
 klen		chnget	"len"			;  "
 kTrigSlid	changed	kLoopStart,kLoopEnd
 kTrigCAD	changed	kbeg,klen
 if kTrigSlid==1 then
  gkLoopStart	=	kLoopStart
  gkLoopEnd	=	kLoopEnd
 elseif kTrigCAD==1 then
  gkLoopStart	=	kbeg/gkTabLen
  gkLoopEnd	=	(kbeg+klen)/gkTabLen
 endif

 gkLoopEnd	limit	gkLoopEnd,gkLoopStart+0.01,1	; limit loop end to prevent crashes
 gkcrossfade	chnget	"crossfade"
 gkinskip	chnget	"inskip"
 gkPlayStop	chnget	"PlayStop"
 gktranspose	chnget	"transpose"
 gkspeed	chnget	"speed"
 gklevel	chnget	"level"

 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0				; call instrument to update sample storage function table 
 endif  
 
 ktrig	trigger	gkPlayStop,0.5,0		; if play button changes to 'play', generate a trigger
 schedkwhen	ktrig,0,0,2,0,-1		; start instr 2 playing a held note

 ktrig1	changed	gktranspose			; if 'transpose' button is changed generate a '1' trigger
 ktrig2	changed	gkspeed				; if 'speed' button is changed generate a '1' trigger
 
 if ktrig1==1 then				; if transpose control has been changed...
  chnset	semitone(gktranspose),"speed"	; set speed according to transpose value
 elseif ktrig2==1 then		; if speed control has been changed...
  chnset	log2(gkspeed)*12,"transpose"	; set transpose control according to speed value
 endif

endin



instr	99	; load sound file
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 gitableL	ftgen	1,0,0,1,gSfilepath,0,0,1
 giFileLen	filelen		gSfilepath			; derive the file duration
 gkTabLen	init		ftlen(gitableL)			; table length in sample frames
 if gichans==2 then
  gitableR	ftgen	2,0,0,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero

 Smessage sprintfk "file(%s)", gSfilepath			; print sound file to viewer
 chnset Smessage, "filer1"	

 /* write file name to GUI */
 Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
 Smessage sprintfk "text(%s)",Sname				; create string to update text() identifier for label widget
 chnset Smessage, "stringbox"					; send string to  widget

endin



instr	2	; sample triggered by 'play/stop' button
 if gkPlayStop==0 then
  turnoff
 endif
 ktrig changed	gkmode
 if ktrig==1 then
  reinit RESTART
 endif
 RESTART:
 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)
  kspeed	portk	gkspeed,kporttime			; apply portamento smoothing to changes in speed
  klevel	portk	gklevel,kporttime			; apply portamento smoothing to changes in level
  kcrossfade	=	0.01
  istart	=	0
  ifenv		=	0
  iskip		=	0
  if gichans==1 then						; if mono...
   a1	flooper2	klevel,kspeed, gkLoopStart*giFileLen, gkLoopEnd*giFileLen, gkcrossfade, gitableL, i(gkinskip)*giFileLen, i(gkmode)-1, ifenv, iskip
	outs	a1*aenv,a1*aenv					; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	flooper2	klevel,kspeed, gkLoopStart*giFileLen, gkLoopEnd*giFileLen, gkcrossfade, gitableL, i(gkinskip)*giFileLen, i(gkmode)-1, ifenv, iskip
   a2	flooper2	klevel,kspeed, gkLoopStart*giFileLen, gkLoopEnd*giFileLen, gkcrossfade, gitableR, i(gkinskip)*giFileLen, i(gkmode)-1, ifenv, iskip
 	outs	a1*aenv,a2*aenv					; send stereo signal to outputs
  endif               
 endif
endin

instr	3	; sample triggered by midi note
 icps	cpsmidi							; read in midi note data as cycles per second
 iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
 iMidiRef	chnget	"MidiRef"

 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)
  klevel	portk	gklevel,kporttime			; apply portamento smoothing to changes in level
  kcrossfade	=	0.01
  istart	=	0
  ifenv		=	0
  iskip		=	0
  if gichans==1 then						; if mono...
   a1	flooper2	klevel*iamp,icps/cpsmidinn(iMidiRef), gkLoopStart*giFileLen, gkLoopEnd*giFileLen, gkcrossfade, gitableL, i(gkinskip)*giFileLen, i(gkmode)-1, ifenv, iskip
	outs	a1*aenv,a1*aenv			; send mono audio to both outputs 
  elseif gichans==2 then					; otherwise, if stereo...
   a1	flooper2	klevel*iamp,icps/cpsmidinn(iMidiRef), gkLoopStart*giFileLen, gkLoopEnd*giFileLen, gkcrossfade, gitableL, i(gkinskip)*giFileLen, i(gkmode)-1, ifenv, iskip
   a2	flooper2	klevel*iamp,icps/cpsmidinn(iMidiRef), gkLoopStart*giFileLen, gkLoopEnd*giFileLen, gkcrossfade, gitableR, i(gkinskip)*giFileLen, i(gkmode)-1, ifenv, iskip
 	outs	a1*aenv,a2*aenv			; send stereo signal to outputs
  endif               
 endif

endin
 
</CsInstruments>  

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>
; FogFilePlayer.csd
; Written by Iain McCurdy, 2015

; File player based around the granular synthesis opcode, 'fog'.
; A second voice can be activated (basically another parallel granular synthesiser) with parameter variations of density, transposition, pointer location (Phs) and delay.
; Two modes of playback are available: manual pointer and speed
; The pointer and grain density can also be modulated by clicking and dragging on the waveform view.
;  * This will also start and stop the grain producing instrument.
;  * In click-and-drag mode mouse X position equates to pointer position and mouse Y position equates to grain density. 
; If played from the MIDI keyboard, note number translates to 'Transposition' and key velocity translates to amplitude for the grain stream for that note.

; In 'Pointer' mode pointer position is controlled by the long 'Manual' slider with an optional amount of randomisation determined ny the 'Phs.Mod' slider.  

; Selecting 'Speed' pointer mode bring up some additional controls:
; Speed		-	speed ratio
; Freeze	-	freezes the pointer at its present locations 
; Range		-	ratio of the full sound file duration that will be played back. 1=the_entire_file, 0.5=half_the_file, etc. 
; Shape		-	shape of playback function: 	'Phasor' looping in a single direction
;												'Tri' back and forth looping
;												'Sine' back and forth looping using a sinudoidal shape - i.e. slowing at the extremes of the oscillation
; The 'Manual' control functions as an pointer offset when using 'Speed' pointer mode

; Density	-	grains per second
; Oct.Div	-	thinning the density in overlapping octave steps. I.e. density is halved and then halved again etc. 
; Transpose	-	transposition as a ratio. Negative values result in grains playing in reverse.
; Transposition Mode - timing of transposition changes: 'Grain by Grain' 	- grains always maintain the transposition with which they began
;														'Continuous'		- even grains in progress can be altered by changes made to 'Transpose' 

; --Randomisation--
; Trans.Mod.	-	randomisation of transposition (in octaves)
; Ptr.Mod.	-	randomisation of pointer position
; Dens Mod.	-	randomisation of grain density
; Amp.Mod.	-	randomisation of grain amplitude. Note that this is done on a grain by grain basis, grains retain the amplitude with which they start.

; --Density LFO--
; Depth		-	depth of LFO modulation of grain density
; Rate		-	rate of LFO modulation of grain density

; --Voice 2--
; Dens.Ratio	-	ratio of grain density of voice 2 with respect to the main voice (also adjustable using the adjacent number box for precise value input)
; Ptr.Diff.	-	pointer position offset of voice 2 with respect to the main voice (also adjustable using the adjacent number box for precise value input)
; Trans.Diff.	-	transposition offset of voice 2 with respect to the main voice (also adjustable using the adjacent number box for precise value input)
; Delay		-	a delay applied to voice 2 which is defined as a ratio of the gap between grains (therefore delay time will be inversely proportional to garin density)
;			 This is a little like a phase offset for voice 2 with respect to that of the main voice.
;			 When using this control 'Dens.Ratio' should be '1' otherwise continuous temporally shifting between the grains of voice 2 and the main voice will be occurring anyway.

; --Envelope--
; Attack	-	amplitude envelope attack time for the envelope applied to complete notes
; Release	-	amplitude envelope release time for the envelope applied to complete notes

; --Control--
; MIDI Ref.	-	MIDI note that represent unison (no transposition) for when using the MIDI keyboard
; Level	-	output amplitude control


<Cabbage>
form caption("fog File Player") size(1130,445), colour(0,0,0), pluginid("FgFP"), guirefresh(16)	; guirefresh value adjusts how often the cabbage valuators are read. This can affect the usability of parameters used in realtime gesturing. style("legacy")

#define RSliderStyle # trackercolour(130,135,170), textcolour("white"), outlinecolour( 10, 15, 50), colour( 50, 45, 90)#

image       bounds(  0,  0,1130,445), colour( 30, 35, 70), outlinecolour("White"), shape("sharp"), line(3)	; main panel colouration    
soundfiler  bounds(  5,  5,1120,175), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 
label bounds(7, 5, 560, 14), text(""), align(left), colour(0,0,0,0), fontcolour(200,200,200), identchannel("stringbox")

hslider    bounds(  0,180,1120, 15), channel("phs"),   range( 0,1,0,1,0.0001), $RSliderStyle
label      bounds(  0,195,1120, 13), text("Manual"), fontcolour("white")

filebutton bounds(  5,210,  80, 25), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5,240,  95, 20), channel("PlayStop"), text("Play/Stop"), fontcolour("white")
label      bounds(  5,263, 145, 12), text("[or right-click and drag]"), fontcolour("white"), align("left")

label       bounds( 90,215, 75, 13), text("Ptr.Mode"), fontcolour("white")
combobox    bounds( 90,230, 75, 18), channel("PhsMode"), items("Manual", "Speed"), value(2),fontcolour("white")

rslider     bounds(170,215, 60, 60), channel("port"),     range( 0, 30.00, 0.01,0.5,0.01), text("Port."), identchannel("portID"), visible(0), $RSliderStyle

rslider     bounds(170,215, 60, 60), channel("spd"),     range( -2.00, 2.00, 1), text("Speed"), identchannel("spdID"), visible(0), $RSliderStyle
button      bounds(230,230, 60, 18), channel("freeze"),  colour:0(  0,  0,  0), colour:1(50,55,150), text("Freeze","Freeze"), fontcolour:0(50,50,50), fontcolour:1(200,200,255), identchannel("freezeID"), visible(0)
rslider     bounds(290,215, 60, 60), channel("range"),   range(0.01,  1,  1),              text("Range"),  identchannel("rangeID"), visible(0), $RSliderStyle
label       bounds(350,215, 60, 13), text("Shape"), fontcolour("white"), identchannel("shapelabelID")
combobox    bounds(350,230, 60, 18), channel("shape"), items("phasor","tri.","sine"), value(1),fontcolour("white"), identchannel("shapeID"), visible(0)

rslider     bounds(410,215, 60, 60), channel("dens"),    range(  1,500,   30, 0.5),  text("Density"), $RSliderStyle
rslider     bounds(470,215, 60, 60), channel("OctDiv"),  range(  0,  8,    0, 0.5),  text("Oct.Div."), $RSliderStyle
rslider     bounds(530,215, 60, 60), channel("pch"),     range(-2,2,1,1,0.001),              text("Transpose"), $RSliderStyle
label       bounds(595,210,120, 13), text("Transposition Mode"), fontcolour("white")
combobox    bounds(595,225,120, 18), channel("TransMode"), items("Grain by Grain","Continuous"), value(1),fontcolour("white")

image       bounds(730,202,260,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("GrainEnv"), { 
label       bounds(  0,  3,260, 8), text("G  R  A  I  N     E  N  V  E  L  O  P  E"), fontcolour("white")
rslider     bounds( 10, 13, 60, 60), channel("dur"),     range(0.01, 2,    0.1, 0.5,0.0001),                    text("Duration"),  $RSliderStyle
rslider     bounds( 70, 13, 60, 60), channel("ris"),     range(0.001,0.2,  0.01,0.5,0.0001),  text("Rise"),      $RSliderStyle
rslider     bounds(130, 13, 60, 60), channel("dec"),     range(0.001,0.2,  0.01,0.5,0.0001),                    text("Decay"),     $RSliderStyle
rslider     bounds(190, 13, 60, 60), channel("band"),    range(0,    100,  10,  0.5,0.0001),                    text("Bandwidth"), $RSliderStyle
}

image      bounds(995,202,130,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("envelope"), { 
label      bounds(  0,  3,130, 8), text("E   N   V   E   L   O   P   E"), fontcolour("white")
rslider    bounds(  5, 13, 60, 60), channel("AttTim"),    range(0, 5, 0, 0.5, 0.001),       text("Attack"), $RSliderStyle
rslider    bounds( 65, 13, 60, 60), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), text("Release"), $RSliderStyle
}

image       bounds(  5,282,250,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("randomise"), { 
label       bounds(  0,  3,250, 8), text("R  A  N  D  O  M  I  S  E"), fontcolour("white")
rslider     bounds(  5, 13, 60, 60), channel("fmd"),     range(    0, 1,    0), text("Trans.Mod."), $RSliderStyle
rslider     bounds( 65, 13, 60, 60), channel("pmd"),     range(    0, 1,    0.0055,0.25,0.00001),  text("Ptr.Mod."), $RSliderStyle
rslider     bounds(125, 13, 60, 60), channel("DensRnd"), range(    0, 2,    0), text("Dens.Mod."), $RSliderStyle
rslider     bounds(185, 13, 60, 60), channel("AmpRnd"), range(    0, 1,    0), text("Amp.Mod."), $RSliderStyle
}

image      bounds(260,282,190,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("LFO"), { 
label      bounds(  0,  3,190, 8), text("L  F  O"), fontcolour("white")
rslider    bounds(  5, 13, 60, 60), channel("DensLFODep"), range(-2, 2, 0, 1, 0.001),       text("Density"), $RSliderStyle
rslider    bounds( 65, 13, 60, 60), channel("AmpLFODep"),  range(-1, 1, 0, 1, 0.001),  text("Amplitude"),  $RSliderStyle
rslider    bounds(125, 13, 60, 60), channel("LFORte"),     range(0.01, 8, 0.1, 0.5, 0.001),  text("Rate"),  $RSliderStyle
}
                              
image      bounds(455,282,485,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("dual"), { 
label      bounds(  0,  3,485, 8), text("V  O  I  C  E     2"), fontcolour("white")
checkbox   bounds( 10, 10, 70, 15), channel("DualOnOff"), text("On/Off"), fontcolour("white")
rslider    bounds( 60, 13, 60, 60), channel("DensRatio"),   range(0.5,2,1,0.64,0.00001), text("Dens.Ratio"), $RSliderStyle
nslider  bounds(120, 25, 60, 20), channel("DensRatio"),   range(0.5,2,1,0.64,0.00001),  textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(180, 13, 60, 60), channel("PtrDiff"),   range(-1,1,0,1,0.00001), text("Ptr.Diff."), $RSliderStyle
nslider  bounds(240, 25, 60, 20), channel("PtrDiff"),   range(-1,1,0,1,0.00001), textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(300, 13, 60, 60), channel("TransDiff"),   range(-2,2,0,1,0.00001), text("Trans.Diff."), $RSliderStyle
nslider  bounds(360, 25, 60, 20), channel("TransDiff"),   range(-2,2,0,1,0.00001), textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(420, 13, 60, 60), channel("Delay"),       range(0,1,0,1,0.00001), text("Delay"), $RSliderStyle
}

image      bounds(945,282,130,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("control"), { 
label      bounds(  0,  3,130, 8), text("C   O   N   T   R   O   L"), fontcolour("white")
rslider    bounds(  5, 13, 60, 60), channel("MidiRef"),   range(0,127,60, 1, 1),   text("MIDI Ref."), $RSliderStyle
rslider    bounds( 65, 13, 60, 60), channel("level"),     range(  0,  3.00, 0.7, 0.5, 0.001), text("Level"), $RSliderStyle
}

keyboard bounds(5,365,1120, 75)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0 -dm0
</CsOptions>
                         
<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

massign	0,3
gichans		init	0
giReady		init	0
gSfilepath	init	""

giTriangle	ftgen	0, 0, 4097,  20, 3

; CURVE USED TO FORM ATTACK AND DECAY PORTIONS OF EACH GRAIN
;              NUM | INIT_TIME | SIZE | GEN_ROUTINE |  PARTIAL_NUMBER_1 | STRENGTH_1 | PHASE_1 | DC_OFFSET_1
giattdec ftgen  0,        0,     524288,     19,             0.5,             0.5,        270,         0.5	; I.E. A RISING SIGMOID

opcode	NextPowerOf2i,i,i
 iInVal	xin
 icount	=	1
 LOOP:
 if 2^icount>iInVal then
  goto DONE
 else
  icount	=	icount + 1
  goto LOOP
 endif
 DONE:
 	xout	2^icount
endop

opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin				; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:					; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:				; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1		; Create a new string of just the file name
	xout	Sname			; Send it back to the caller instrument
endop

instr	1
 kRampUp	linseg	0,0.001,1
 gkport		chnget	"port"
 gkloop		chnget	"loop"
 gkPlayStop	chnget	"PlayStop"
 gkPhsMode	chnget	"PhsMode"
 gkPhsMode	init	1
 gklevel	chnget	"level"
 gklevel	port	gklevel,0.05
 gkpch		chnget	"pch" 
 gkspd		chnget	"spd"
 gkfreeze	chnget	"freeze"
 gkrange	chnget	"range"
 gkshape	chnget	"shape"
 gkTransMode	chnget	"TransMode"
 gkTransMode	init	1
 gkOctDiv	chnget	"OctDiv"
 gkband		chnget	"band"
 gkris		chnget	"ris"
 gkdec		chnget	"dec"
 gkdur		chnget	"dur"   
 gkfmd		chnget	"fmd"
 gkpmd		chnget	"pmd"
 gkDensRnd	chnget	"DensRnd"
 gkAmpRnd	chnget	"AmpRnd"
 gkDensLFODep	chnget	"DensLFODep"
 gkAmpLFODep	chnget	"AmpLFODep"
 gkLFORte	chnget	"LFORte"
 gkDualOnOff	chnget	"DualOnOff"
 gkDensRatio	chnget	"DensRatio"
 gkPtrDiff	chnget	"PtrDiff"
 gkPtrDiff	port	gkPtrDiff,0.1
 gkTransDiff	chnget	"TransDiff"
 gkDelay	chnget	"Delay"
 gkDelay	port	gkDelay,0.1
      
 if changed(gkPhsMode)==1 then
  if gkPhsMode==1 then
   	chnset	"visible(0)", "spdID"
   	chnset	"visible(0)", "freezeID"
   	chnset	"visible(0)", "rangeID"
   	chnset	"visible(0)", "shapeID"
   	chnset	"visible(0)", "shapelabelID"
   	chnset	"visible(1)", "portID"
  elseif gkPhsMode==2 then
   	chnset	"visible(1)", "spdID"
   	chnset	"visible(1)", "freezeID"
   	chnset	"visible(1)", "rangeID"
   	chnset	"visible(1)", "shapeID"
   	chnset	"visible(1)", "shapelabelID"
   	chnset	"visible(0)", "portID"
  endif
 endif
          
 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath	; if a new file is loaded generate a trigger
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0					; call instrument to update sample storage function table 
 endif  

 /* START/STOP SOUNDING INSTRUMENT */
 ktrig	trigger	gkPlayStop,0.5,0
 schedkwhen	ktrig,0,0,2,0,-1

 /* MOUSE SCRUBBING */
 gkMOUSE_DOWN_RIGHT	chnget	"MOUSE_DOWN_RIGHT"	; Read in mouse left click status
 kStartScrub		trigger	gkMOUSE_DOWN_RIGHT,0.5,0
 if gkMOUSE_DOWN_RIGHT==1 then
  if kStartScrub==1 then 
   reinit RAMP_FUNC
  endif
  RAMP_FUNC:
  krampup	linseg	0,0.001,1
  rireturn
  kMOUSE_X	chnget	"MOUSE_X"
  kMOUSE_X	portk	kMOUSE_X,gkport*kRampUp
  kMOUSE_Y	chnget	"MOUSE_Y"
  kMOUSE_X	=	(kMOUSE_X - 5) / 1120
  kMOUSE_Y	portk	1 - ((kMOUSE_Y - 5) / 175), krampup*0.05		; SOME SMOOTHING OF DENSITY CHANGES VIA THE MOUSE ENHANCES PERFORMANCE RESULTS. MAKE ANY ADJUSTMENTS WITH ADDITIONAL CONSIDERATION OF guirefresh VALUE 
  gkphs		limit	kMOUSE_X,0,1
  gkdens	limit	((kMOUSE_Y^3) * 502) - 2, 0, 500
  schedkwhen	kStartScrub,0,0,2,0,-1
 else
  gkphs		chnget	"phs"
  gkphs		portk	gkphs,gkport*kRampUp
  gkdens	chnget	"dens"
 endif
 
endin

instr	99	; load sound file
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 iFtlen		NextPowerOf2i	filelen:i(gSfilepath)*sr
 gitableL	ftgen	1,0,iFtlen,1,gSfilepath,0,0,1
 if gichans==2 then
  gitableR	ftgen	2,0,iFtlen,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero
 Smessage sprintfk "file(%s)", gSfilepath			; print sound file to viewer
 chnset Smessage, "filer1"

 /* WRITE FILE NAME TO GUI */
 Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
 Smessage sprintfk "text(%s)",Sname
 chnset Smessage, "stringbox"

endin

instr	2	; triggered by 'play/stop' button
 if gkPlayStop==0&&gkMOUSE_DOWN_RIGHT==0 then
  turnoff
 endif
 if giReady = 1 then						; i.e. if a file has been loaded
  
  /* ENVELOPE */
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else            
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope

  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)

  kSwitch		changed	gkTransMode
  if	kSwitch==1	then		;IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
  	reinit	START			;BEGIN A REINITIALISATION PASS FROM LABEL 'START'
  endif
  START:

  kPmdRnd	unirand	gkpmd
  
  if gkPhsMode==1||gkMOUSE_DOWN_RIGHT==1 then
   kptr		portk	gkphs+kPmdRnd, kporttime	; PORTAMENTO IS APPLIED TO SMOOTH VALUE CHANGES VIA THE FLTK SLIDERS
   kptr		mirror	kptr,0,1
   kptr		=	kptr * (nsamp(1)/ftlen(1))
   aptr		interp	kptr				; A NEW A-RATE VARIABLE (aptr) IS CREATED BASE ON kptr
  else
   if gkshape==1 then
    kptr		phasor	(gkspd * sr * (1-gkfreeze))/(nsamp(1) * gkrange)
   elseif gkshape==2 then
    kptr		oscili	1,(gkspd * sr * (1-gkfreeze))/(nsamp(1) * gkrange),giTriangle
   elseif gkshape==3 then
    kptr		oscili	0.5,(gkspd * sr * (1-gkfreeze))/(nsamp(1) * gkrange)
    kptr		+=		0.5
   endif
   kptr	=	kptr * (nsamp(1)/ftlen(1)) * gkrange
   kptr	+=	(gkphs+kPmdRnd) * (nsamp(1)/ftlen(1))
   kptr	mirror	kptr,0,nsamp(1)/ftlen(1)
  endif
  aptr		interp	kptr
  
  iNumOverLaps	=	2000
  itotdur		=	3600
  
  kPchRnd	bexprnd	gkfmd					; random pitch
  kpch		=	gkpch * octave(kPchRnd)

  kRndTrig	init	1
  ;kdens		init	30					; set to initial widget value
  kDensRnd	bexprnd	gkDensRnd	;randomh	-gkDensRnd, gkDensRnd, kdens
  kdens	=	gkdens * octave(kDensRnd)
  kRndTrig	metro	kdens

  /* amplitude random modulation */
  kAmpRnd	random	0,gkAmpRnd
  klevel	=		gklevel-sqrt(kAmpRnd)

  /* LFO */
  kDensLFO	poscil	gkDensLFODep,gkLFORte
  kdens	=		kdens * octave(kDensLFO)
  kAmpLFO	poscil	gkAmpLFODep*0.5,gkLFORte
  klevel	*=		1-((kAmpLFO+(abs(gkAmpLFODep)*0.5))^2)

  if gichans==1 then						; if mono...
  a1	fog	klevel, kdens, kpch, aptr, gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 1, giattdec, itotdur, 0, i(gkTransMode)-1, 1
   if gkDualOnOff==1 then
    a1b	fog	klevel, kdens*gkDensRatio, kpch*octave(gkTransDiff), aptr+(gkPtrDiff*nsamp(1)/ftlen(1)), gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 1, giattdec, itotdur, 0, i(gkTransMode)-1, 1
    if gkDelay>0 then
     a1b	vdelay	a1b,(gkDelay*1000)/gkdens,1000
    endif
    a1	+=	a1b
   endif
 	outs	a1*aenv,a1*aenv				; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	fog	klevel, kdens, kpch, aptr, gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 1, giattdec, itotdur, 0, i(gkTransMode)-1, 1
   a2	fog	klevel, kdens, kpch, aptr, gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 2, giattdec, itotdur, 0, i(gkTransMode)-1, 1
   if gkDualOnOff==1 then
    a1b	fog	klevel, kdens*gkDensRatio, kpch*octave(gkTransDiff), aptr+(gkPtrDiff*nsamp(1)/ftlen(1)), gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 1, giattdec, itotdur, 0, i(gkTransMode)-1, 1
    a2b	fog	klevel, kdens*gkDensRatio, kpch*octave(gkTransDiff), aptr+(gkPtrDiff*nsamp(1)/ftlen(1)), gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 2, giattdec, itotdur, 0, i(gkTransMode)-1, 1
    if gkDelay>0 then
     a1b	vdelay	a1b,(gkDelay*1000)/gkdens,1000
     a2b	vdelay	a2b,(gkDelay*1000)/gkdens,1000
    endif
    a1	+=	a1b
    a2	+=	a2b
   endif
 	outs	a1*aenv,a2*aenv				; send stereo signal to outputs
  endif
  rireturn

 endif
endin

instr	3
 icps	cpsmidi							; read in midi note data as cycles per second
 iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
 iAttTim	chnget	"AttTim"				; read in widgets
 iRelTim	chnget	"RelTim"
 iMidiRef	chnget	"MidiRef"
 iFrqRatio		=	icps/cpsmidinn(iMidiRef)	; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)

 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else            
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope

  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)

  kSwitch		changed	gkTransMode
  if	kSwitch==1	then		;IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
  	reinit	START			;BEGIN A REINITIALISATION PASS FROM LABEL 'START'
  endif
  START:

  kPmdRnd	unirand	gkpmd
  
  if gkPhsMode==1 then
   kptr		portk	gkphs+kPmdRnd, kporttime	; PORTAMENTO IS APPLIED TO SMOOTH VALUE CHANGES VIA THE FLTK SLIDERS
   kptr		mirror	kptr,0,1
   kptr		=	kptr * (nsamp(1)/ftlen(1))
   aptr		interp	kptr				; A NEW A-RATE VARIABLE (aptr) IS CREATED BASE ON kptr
  else
   if gkshape==1 then
    kptr		phasor	(gkspd * sr * (1-gkfreeze))/(nsamp(1) * gkrange)
   elseif gkshape==2 then
    kptr		oscili	1,(gkspd * sr * (1-gkfreeze))/(nsamp(1) * gkrange),giTriangle
   elseif gkshape==3 then
    kptr		oscili	0.5,(gkspd * sr * (1-gkfreeze))/(nsamp(1) * gkrange)
    kptr		+=		0.5
   endif
   kptr	=	kptr * (nsamp(1)/ftlen(1)) * gkrange
   kptr	+=	(gkphs+kPmdRnd) * (nsamp(1)/ftlen(1))
   kptr	mirror	kptr,0,nsamp(1)/ftlen(1)
  endif
  aptr		interp	kptr
  
  iNumOverLaps	=	2000
  itotdur		=	3600
  
  kPchRnd	bexprnd	gkfmd					; random pitch
  kpch		=	iFrqRatio * octave(kPchRnd)
  gklevel	*=	iamp
  
  kRndTrig	init	1
  kDensRnd	bexprnd	gkDensRnd
  kdens	=	gkdens * octave(kDensRnd)
  kRndTrig	metro	kdens

  /* amplitude random modulation */
  kAmpRnd	random	0,gkAmpRnd
  klevel	=		gklevel-sqrt(kAmpRnd)

  /* LFO */
  kDensLFO	poscil	gkDensLFODep,gkLFORte
  kdens	=		gkdens * octave(kDensLFO)
  kAmpLFO	poscil	gkAmpLFODep*0.5,gkLFORte
  klevel	*=		1-((kAmpLFO+(abs(gkAmpLFODep)*0.5))^2)
    
  if gichans==1 then						; if mono...
  a1	fog	klevel, kdens, kpch, aptr, gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 1, giattdec, itotdur, 0, i(gkTransMode)-1, 1
   if gkDualOnOff==1 then
    a1b	fog	klevel, kdens*gkDensRatio, kpch*octave(gkTransDiff), aptr+(gkPtrDiff*nsamp(1)/ftlen(1)), gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 1, giattdec, itotdur, 0, i(gkTransMode)-1, 1
    if gkDelay>0 then
     a1b	vdelay	a1b,(gkDelay*1000)/gkdens,1000
    endif
    a1	+=	a1b
   endif
 	outs	a1*aenv,a1*aenv				; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	fog	klevel, kdens, kpch, aptr, gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 1, giattdec, itotdur, 0, i(gkTransMode)-1, 1
   a2	fog	klevel, kdens, kpch, aptr, gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 2, giattdec, itotdur, 0, i(gkTransMode)-1, 1
   if gkDualOnOff==1 then
    a1b	fog	klevel, kdens*gkDensRatio, kpch*octave(gkTransDiff), aptr+(gkPtrDiff*nsamp(1)/ftlen(1)), gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 1, giattdec, itotdur, 0, i(gkTransMode)-1, 1
    a2b	fog	klevel, kdens*gkDensRatio, kpch*octave(gkTransDiff), aptr+(gkPtrDiff*nsamp(1)/ftlen(1)), gkOctDiv, gkband, gkris, gkdur, gkdec, iNumOverLaps, 2, giattdec, itotdur, 0, i(gkTransMode)-1, 1
    if gkDelay>0 then
     a1b	vdelay	a1b,(gkDelay*1000)/gkdens,1000
     a2b	vdelay	a2b,(gkDelay*1000)/gkdens,1000
    endif
    a1	+=	a1b
    a2	+=	a2b
   endif
 	outs	a1*aenv,a2*aenv				; send stereo signal to outputs
  endif
  rireturn


 endif

endin

</CsInstruments>  

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>
; Grain3FilePlayer.csd
; Written by Iain McCurdy, 2015

; File player based around the granualr synthesis opcode, 'grain3'.
; A second voice can be activated (basically another parallel granular synthesiser) with parameter variations of density, transposition, pointer location (Phs) and delay.
; Two modes of playback are available: manual pointer and speed
; The pointer and grain density can also be modulated by clicking and dragging on the waveform view.
;  * This will also start and stop the grain producing instrument.
;  * In click-and-drag mode mouse X position equates to pointer position and mouse Y position equates to grain density. 
; If played from the MIDI keyboard, note number translates to 'Transposition' and key velocity translates to amplitude for the grain stream for that note.

; In 'Pointer' mode pointer position is controlled by the long 'Manual' slider with an optional amount of randomisation determined ny the 'Phs.Mod' slider.  

; Selecting 'Speed' pointer mode bring up some additional controls:
; Speed		-	speed ratio
; Freeze	-	freezes the pointer at its present locations 
; Range		-	ratio of the full sound file duration that will be played back. 1=the_entire_file, 0.5=half_the_file, etc. 
; Shape		-	shape of playback function: 	'Phasor' looping in a single direction
;							'Tri' back and forth looping
; The 'Manual' control functions as an pointer offset when using 'Speed' pointer mode

; Size		-	size of the grains
; Density	-	grains per second
; Transpose	-	transposition in semitones
; Window	-	window shape that envelopes each individual grain

; --Randomisation--
; Trans.Mod.	-	randomisation of transposition (in octaves)
; Ptr.Mod.	-	randomisation of pointer position
; Dens Mod.	-	randomisation of grain density
; Size Mod.	-	randomisation of grain size

; --Density LFO--
; Density	-	depth of LFO modulation of grain density
; Amplitude	-	depth of LFO modulation of grain amplitude
; Size		-	depth of LFO modulation of grain size
; Rate		-	rate of LFO modulation of grain density

; --Voice 2--
; Dens.Ratio	-	ratio of grain density of voice 2 with respect to the main voice (also adjustable using the adjacent number box for precise value input)
; Ptr.Diff.	-	pointer position offset of voice 2 with respect to the main voice (also adjustable using the adjacent number box for precise value input)
; Trans.Diff.	-	transposition offset of voice 2 with respect to the main voice (also adjustable using the adjacent number box for precise value input)
; Delay		-	a delay applied to voice 2 which is defined as a ratio of the gap between grains (therefore delay time will be inversely proportional to garin density)
;			 This is a little like a phase offset for voice 2 with respect to that of the main voice.
;			 When using this control 'Dens.Ratio' should be '1' otherwise continuous temporally shifting between the grains of voice 2 and the main voice will be occurring anyway.

; --Envelope--
; Attack	-	amplitude envelope attack time for the envelope applied to complete notes
; Release	-	amplitude envelope release time for the envelope applied to complete notes

; --Control--
; MIDI Ref.	-	MIDI note that represent unison (no transposition) for when using the MIDI keyboard
; Level	-	output amplitude control


<Cabbage>
form caption("grain3 File Player") size(1040,440), colour(0,0,0), pluginid("G3FP"), guirefresh(16)	; guirefresh value adjusts how often the cabbage valuators are read. This can affect the usability of parameters used in realtime gesturing. style("legacy")

#define RSliderStyle # trackercolour(170,135,130), textcolour("white"), outlinecolour( 50, 15, 10), colour( 90, 45, 50)#

image       bounds(  0,  0,1040,440), colour( 70, 35, 30), outlinecolour("White"), shape("sharp"), line(3)	; main panel colouration    
soundfiler  bounds(  5,  5,1030,175), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 
label bounds(7, 5, 560, 14), text(""), align(left), colour(0,0,0,0), fontcolour(200,200,200), identchannel("stringbox")

hslider    bounds(  0,180,1030, 15), channel("phs"),   range( 0,1,0,1,0.0001), $RSliderStyle
label      bounds(  0,195,1030, 13), text("Manual"), fontcolour("white")

filebutton bounds(  5,210,  80, 25), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5,240,  95, 20), channel("PlayStop"), text("Play/Stop"), fontcolour("white")
label      bounds(  5,263, 145, 12), text("[or right-click and drag]"), fontcolour("white"), align("left")

label       bounds( 90,215, 75, 13), text("Ptr.Mode"), fontcolour("white")
combobox    bounds( 90,230, 75, 18), channel("PhsMode"), items("Manual", "Speed"), value(2),fontcolour("white")

rslider     bounds(170,215, 60, 60), channel("spd"),     range( -2.00, 2.00, 1), text("Speed"), identchannel("spdID"), visible(0), $RSliderStyle
button      bounds(230,230, 60, 18), channel("freeze"),  colour(  0,  0,  0), text("Freeze","Freeze"), fontcolour:0(70,70,70), fontcolour:1(255,255,255), identchannel("freezeID"), visible(0)
rslider     bounds(290,215, 60, 60), channel("range"),   range(0.01,  1,  1),              text("Range"),  identchannel("rangeID"), visible(0), $RSliderStyle
label       bounds(350,215, 60, 13), text("Shape"), fontcolour("white"), identchannel("shapelabelID")
combobox    bounds(350,230, 60, 18), channel("shape"), items("phasor", "tri."), value(1),fontcolour("white"), identchannel("shapeID"), visible(0)

rslider     bounds(410,215, 60, 60), channel("dur"),     range(0.01,5.00,0.05,0.5,0.001), text("Size"), $RSliderStyle
rslider     bounds(470,215, 60, 60), channel("dens"),    range( 0.2, 500,  20, 0.5),     text("Density"), $RSliderStyle
rslider     bounds(530,215, 60, 60), channel("pch"),     range(-2,2,1,1,0.001),              text("Transpose"), $RSliderStyle
label       bounds(595,210, 75, 13), text("Window"), fontcolour("white")
combobox    bounds(595,225, 75, 18), channel("wfn"), items("Hanning","Perc. 1","Perc. 2","Perc. 3","Gate","Rev Perc. 1","Rev.Perc 2","Rev.Perc 3"), value(1),fontcolour("white")

image       bounds(680,202,260,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("randomise"), { 
label       bounds(  0,  3,260, 8), text("R  A  N  D  O  M  I  S  E"), fontcolour("white")
rslider     bounds( 10, 13, 60, 60), channel("fmd"),     range(    0, 8,    0), text("Trans.Mod."), $RSliderStyle
rslider     bounds( 70, 13, 60, 60), channel("pmd"),     range(    0, 1,    0,0.25,0.00001),  text("Ptr.Mod."), $RSliderStyle
rslider     bounds(130, 13, 60, 60), channel("DensRnd"), range(    0, 2,    0), text("Dens.Mod."), $RSliderStyle
rslider     bounds(190, 13, 60, 60), channel("SizeRnd"), range(    0, 8,    0), text("Size.Mod."), $RSliderStyle
}

image      bounds(  5,282,505,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("dual"), { 
label      bounds(  0,  3,505, 8), text("V  O  I  C  E     2"), fontcolour("white")
checkbox   bounds( 10, 30, 70, 20), channel("DualOnOff"), text("On/Off"), fontcolour("white")
rslider    bounds( 80, 13, 60, 60), channel("DensRatio"),   range(0.5,2,1,0.64,0.00001), text("Dens.Ratio"), $RSliderStyle
nslider  bounds(140, 25, 60, 20), channel("DensRatio"),   range(0.5,2,1,0.64,0.00001),  textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(200, 13, 60, 60), channel("PtrDiff"),   range(-1,1,0,1,0.00001), text("Ptr.Diff."), $RSliderStyle
nslider  bounds(260, 25, 60, 20), channel("PtrDiff"),   range(-1,1,0,1,0.00001), textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(320, 13, 60, 60), channel("TransDiff"),   range(-2,2,0,1,0.00001), text("Trans.Diff."), $RSliderStyle
nslider  bounds(380, 25, 60, 20), channel("TransDiff"),   range(-2,2,0,1,0.00001), textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(440, 13, 60, 60), channel("Delay"),       range(0,1,0,1,0.00001), text("Delay"), $RSliderStyle
}

image      bounds(515,282,250,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("LFO"), { 
label      bounds(  0,  3,250, 8), text("L  F  O"), fontcolour("white")
rslider    bounds(  5, 13, 60, 60), channel("DensLFODep"), range(-4, 4, 0, 1, 0.001),       text("Density"),   $RSliderStyle
rslider    bounds( 65, 13, 60, 60), channel("AmpLFODep"),  range(-1, 1, 0, 1, 0.001),       text("Amplitude"), $RSliderStyle
rslider    bounds(125, 13, 60, 60), channel("SizeLFODep"), range(-2, 2, 0, 1, 0.001),       text("Size"),      $RSliderStyle
rslider    bounds(185, 13, 60, 60), channel("LFORte"),     range(0.01, 8, 0.1, 0.5, 0.001), text("Rate"),      $RSliderStyle
}

image      bounds(770,282,130,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("envelope"), { 
label      bounds(  0,  3,140, 8), text("E   N   V   E   L   O   P   E"), fontcolour("white")
rslider    bounds(  5, 13, 60, 60), channel("AttTim"),    range(0, 5, 0, 0.5, 0.001),       text("Attack"), $RSliderStyle
rslider    bounds( 65, 13, 60, 60), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), text("Release"), $RSliderStyle
}

image      bounds(905,282,130,75), colour(0,0,0,0), outlinecolour("grey"), outlinethickness(1), shape("sharp"), plant("control"), { 
label      bounds(  0,  3,140, 8), text("C   O   N   T   R   O   L"), fontcolour("white")
rslider    bounds(  5, 13, 60, 60), channel("MidiRef"),   range(0,127,60, 1, 1),   text("MIDI Ref."), $RSliderStyle
rslider    bounds( 65, 13, 60, 60), channel("level"),     range(  0,  3.00, 0.7, 0.5, 0.001), text("Level"), $RSliderStyle
}
                                  
keyboard bounds(5,360,1030, 75)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0 -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

massign	0,3
gichans		init	0
giReady		init	0
gSfilepath	init	""

; WINDOWING FUNCTIONS USED TO DYNAMICALLY SHAPE THE GRAINS
; NUM | INIT_TIME | SIZE | GEN_ROUTINE | PARTIAL_NUM | STRENGTH | PHASE
; GRAIN ENVELOPE WINDOW FUNCTION TABLES:
giwfn1	ftgen	0,  0, 131072,  20,   2, 1 									; HANNING
iTime	=	15000
giwfn2	ftgen	0,  0, 131072,  7,    0, iTime, 1, 131072-iTime, 0			; PERCUSSIVE - GEN08
giwfn3	ftgen	0,  0, 131072,  7,    0, 3072,   1, 128000,    0			; PERCUSSIVE - STRAIGHT SEGMENTS
giwfn4	ftgen	0,  0, 131072,  5,0.001, 3072,   1, 128000,0.001			; PERCUSSIVE - EXPONENTIAL SEGMENTS
giwfn5	ftgen	0,  0, 131072,  7,    0, 1536,   1, 128000,    1, 1536, 0	; GATE - WITH DE-CLICKING RAMP UP AND RAMP DOWN SEGMENTS
giwfn6	ftgen	0,  0, 131072,  7,    0, 131072-iTime, 1, iTime, 0			; REVERSE PERCUSSIVE - GEN08
giwfn7	ftgen	0,  0, 131072,  7,    0, 128000, 1, 3072,      0			; REVERSE PERCUSSIVE - STRAIGHT SEGMENTS
giwfn8	ftgen	0,  0, 131072,  5,0.001, 128000, 1, 3072,  0.001			; REVERSE PERCUSSIVE - EXPONENTIAL SEGMENTS

giTriangle	ftgen	0, 0, 4097,  20, 3


opcode	Grain3b,a,kkkkkkkkkkiiikkiiikk
	kpch, kphs, kspd, kfreeze, krange, kshape, kfmd, kpmd, kdur, kdens, imaxovr, isfn, iwfn, kfrpow, kprpow , iseed, imode, iPhsMode, kDensRnd, kSizeRnd	xin

	if iPhsMode==1 then
	 kptr 		= 	kphs * (nsamp(isfn)/ftlen(isfn))	;MATHEMATICALLY REINTERPRET USER INPUTTED PHASE VALUE INTO A FORMAT THAT IS USABLE AS AN INPUT ARGUMENT  BY THE grain3 OPCODE

	elseif iPhsMode==2 then
	 kspd	*=	1-kfreeze
	 if kshape==1 then
	  kptr		phasor	(kspd*sr)/(nsamp(isfn)*krange)
	  kpch		=	kpch-kspd
	 elseif kshape==2 then
	  kptr		oscili	1,(kspd*sr)/(nsamp(isfn)*krange*2),giTriangle
	  kptrPrev	init	0
	  kpch		=	kptr>kptrPrev?kpch-kspd:kpch+kspd
	  kptrPrev	=	kptr
	 endif
	 kptr		*=	krange	 
	 kptr		mirror	kptr+kphs,0,1

	 kptr 		= 	kptr*(nsamp(isfn)/ftlen(isfn))	;MATHEMATICALLY REINTERPRET USER INPUTTED PHASE VALUE INTO A FORMAT THAT IS USABLE AS AN INPUT ARGUMENT  BY THE grain3 OPCODE

	endif

	kpch 		= 	(sr*kpch)/(ftlen(isfn))		;MATHEMATICALLY REINTERPRET USER INPUTTED PITCH RATIO VALUE INTO A FORMAT THAT IS USABLE AS AN INPUT ARGUMENT BY THE grain3 OPCODE - ftlen(x) FUNCTION RETURNS THE LENGTH OF A FUNCTION TABLE (no. x), REFER TO MANUAL FOR MORE INFO.	
	kfmd		=	(sr*(kfmd*kpch))/ftlen(isfn)

	ktrig		metro	kdens				;TRIGGERS IN SYNC WITH GRAIN GENERATION
	
	kDensRnd 	trandom ktrig,-kDensRnd,kDensRnd	;CREATE A RANDOM OFFSET FACTOR THAT WILL BE APPLIED TO FOR DENSITY
	kdens		*=	octave(kDensRnd)

	kSizeRnd 	trandom ktrig,-kSizeRnd,kSizeRnd	;CREATE A RANDOM OFFSET FACTOR THAT WILL BE APPLIED TO FOR DENSITY
	kdur		*=	octave(kSizeRnd)
	
	asig	grain3	kpch, kptr, kfmd, kpmd, kdur, kdens, imaxovr, isfn, iwfn, kfrpow, kprpow , iseed, imode
	xout	asig

endop

opcode	NextPowerOf2i,i,i
 iInVal	xin
 icount	=	1
 LOOP:
 if 2^icount>iInVal then
  goto DONE
 else
  icount	=	icount + 1
  goto LOOP
 endif
 DONE:
 	xout	2^icount
endop

opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin				; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:					; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:				; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1		; Create a new string of just the file name
	xout	Sname			; Send it back to the caller instrument
endop

instr	1
 gkloop		chnget	"loop"
 gkPlayStop	chnget	"PlayStop"

 gkPhsMode	chnget	"PhsMode"
 gkPhsMode	init	1
 gklevel	chnget	"level"
 gklevel	port	gklevel,0.05
 gkdur		chnget	"dur"
 gkpch		chnget	"pch"
 
 gkwfn		chnget	"wfn"
 gkwfn		init	1
 gkspd		chnget	"spd"
 gkfreeze	chnget	"freeze"
 gkrange	chnget	"range"
 gkshape	chnget	"shape"
 gkfmd		chnget	"fmd"
 gkpmd		chnget	"pmd"
 gkDensRnd	chnget	"DensRnd"
 gkSizeRnd	chnget	"SizeRnd"
 gkDensLFODep	chnget	"DensLFODep"
 gkAmpLFODep	chnget	"AmpLFODep"
 gkSizeLFODep	chnget	"SizeLFODep"
 gkLFORte	chnget	"LFORte"
 gkDualOnOff	chnget	"DualOnOff"
 gkDensRatio	chnget	"DensRatio"
 gkPtrDiff	chnget	"PtrDiff"
 gkTransDiff	chnget	"TransDiff"
 gkDelay	chnget	"Delay"
 gkDelay	port	gkDelay,0.1
 
 if changed(gkPhsMode)==1 then
  if gkPhsMode==1 then
   	chnset	"visible(0)", "spdID"
   	chnset	"visible(0)", "freezeID"
   	chnset	"visible(0)", "rangeID"
   	chnset	"visible(0)", "shapeID"
   	chnset	"visible(0)", "shapelabelID"
  elseif gkPhsMode==2 then
   	chnset	"visible(1)", "spdID"
   	chnset	"visible(1)", "freezeID"
   	chnset	"visible(1)", "rangeID"
   	chnset	"visible(1)", "shapeID"
   	chnset	"visible(1)", "shapelabelID"
  endif
 endif
 
 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0				; call instrument to update sample storage function table 
 endif  

 /* START/STOP SOUNDING INSTRUMENT */
 ktrig	trigger	gkPlayStop,0.5,0
 schedkwhen	ktrig,0,0,2,0,-1

 /* MOUSE SCRUBBING */
 gkMOUSE_DOWN_RIGHT	chnget	"MOUSE_DOWN_RIGHT"	; Read in mouse left click status
 kStartScrub		trigger	gkMOUSE_DOWN_RIGHT,0.5,0
 if gkMOUSE_DOWN_RIGHT==1 then
  if kStartScrub==1 then 
   reinit RAMP_FUNC
  endif
  RAMP_FUNC:
  krampup	linseg	0,0.001,1
  rireturn
  kMOUSE_X	chnget	"MOUSE_X"
  kMOUSE_Y	chnget	"MOUSE_Y"
  kMOUSE_X	=	(kMOUSE_X - 5) / 930
  kMOUSE_Y	portk	1 - ((kMOUSE_Y - 5) / 170), krampup*0.05		; SOME SMOOTHING OF DENSITY CHANGES VIA THE MOUSE ENHANCES PERFORMANCE RESULTS. MAKE ANY ADJUSTMENTS WITH ADDITIONAL CONSIDERATION OF guirefresh VALUE 
  gkphs		limit	kMOUSE_X,0,1
  gkdens	limit	((kMOUSE_Y^3) * 499) + 1, 1, 500
  schedkwhen	kStartScrub,0,0,2,0,-1
 else
  gkphs		chnget	"phs"
  gkdens	chnget	"dens"
 endif
 
endin

instr	99	; load sound file
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 iFtlen		NextPowerOf2i	filelen:i(gSfilepath)*sr
 gitableL	ftgen	1,0,iFtlen,1,gSfilepath,0,0,1
 if gichans==2 then
  gitableR	ftgen	2,0,iFtlen,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero
 Smessage sprintfk "file(%s)", gSfilepath			; print sound file to viewer
 chnset Smessage, "filer1"

 /* WRITE FILE NAME TO GUI */
 Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
 Smessage sprintfk "text(%s)",Sname
 chnset Smessage, "stringbox"

endin

instr	2	; triggered by 'play/stop' button
 if gkPlayStop==0&&gkMOUSE_DOWN_RIGHT==0 then
  turnoff
 endif
 if giReady = 1 then						; i.e. if a file has been loaded
  
  /* ENVELOPE */
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then							; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0		; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else            
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope

  kporttime	linseg	0,0.001,0.05			; portamento time function. (Rises quickly from zero to a held value.)

  kSwitch		changed	gkPhsMode, gkwfn
  if	kSwitch==1	then					; IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
  	reinit	START							; BEGIN A REINITIALISATION PASS FROM LABEL 'START'
  endif
  START:
  iwfn		=	giwfn1 + i(gkwfn) - 1
  
  /* LFO */
  kDensLFO	poscil	gkDensLFODep,gkLFORte
  kdens	=		gkdens * octave(kDensLFO)
  kAmpLFO	poscil	gkAmpLFODep*0.5,gkLFORte
  klevel	=		gklevel*(1-((kAmpLFO+(abs(gkAmpLFODep)*0.5))^2))
  kSizeLFO	poscil	gkSizeLFODep,gkLFORte
  kdur	=		gkdur * octave(kSizeLFO)
  
  iPhsMode	=	i(gkMOUSE_DOWN_RIGHT)==1?1:i(gkPhsMode)
  
  if gichans==1 then						; if mono...
   a1	Grain3b		gkpch, gkphs, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens, 600, 1, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
   if gkDualOnOff==1 then
    a1b	Grain3b		gkpch+gkTransDiff, gkphs+gkPtrDiff, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens*gkDensRatio, 600, 1, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
    if gkDelay>0 then
     a1b	vdelay	a1b,(gkDelay*1000)/kdens,5000
    endif
    a1	+=	a1b
   endif
 	outs	a1*aenv*klevel,a1*aenv*klevel		; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	Grain3b		gkpch, gkphs, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens, 600, 1, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
   a2	Grain3b		gkpch, gkphs, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens, 600, 2, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
   if gkDualOnOff==1 then
    a1b	Grain3b		gkpch+gkTransDiff, gkphs+gkPtrDiff, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens*gkDensRatio, 600, 1, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
    a2b	Grain3b		gkpch+gkTransDiff, gkphs+gkPtrDiff, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens*gkDensRatio, 600, 2, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
    if gkDelay>0 then
     a1b	vdelay	a1b,(gkDelay*1000)/kdens,5000
     a2b	vdelay	a2b,(gkDelay*1000)/kdens,5000
    endif
    a1	+=	a1b
    a2	+=	a2b
   endif
 	outs	a1*aenv*klevel,a2*aenv*klevel		; send stereo signal to outputs
  endif
  rireturn

 endif
endin

instr	3
 icps	cpsmidi									; read in midi note data as cycles per second
 iamp	ampmidi	1								; read in midi velocity (as a value within the range 0 - 1)
 iAttTim	chnget	"AttTim"					; read in widgets
 iRelTim	chnget	"RelTim"
 iMidiRef	chnget	"MidiRef"
 iFrqRatio		=	icps/cpsmidinn(iMidiRef)	; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)

 if giReady = 1 then							; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"					; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then								; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0			; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else            
   kenv	linsegr	1,iRelTim,0						; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8						; remap amplitude value with a more natural curve
  aenv	interp		kenv						; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)

  kSwitch		changed	gkPhsMode, gkwfn
  if	kSwitch==1	then						; IF I-RATE VARIABLE CHANGE TRIGGER IS '1'...
  	reinit	START								; BEGIN A REINITIALISATION PASS FROM LABEL 'START'
  endif
  START:
  iwfn		=	giwfn1 + i(gkwfn) - 1

  /* LFO */
  kDensLFO	poscil	gkDensLFODep,gkLFORte
  kdens	=		gkdens * octave(kDensLFO)
  kAmpLFO	poscil	gkAmpLFODep*0.5,gkLFORte
  klevel	=		gklevel*(1-((kAmpLFO+(abs(gkAmpLFODep)*0.5))^2))
  kSizeLFO	poscil	gkSizeLFODep,gkLFORte
  kdur	=		gkdur * octave(kSizeLFO)

  iPhsMode	=	i(gkMOUSE_DOWN_RIGHT)==1?1:i(gkPhsMode)

  if gichans==1 then							; if mono...
   a1	Grain3b		iFrqRatio, gkphs, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens, 600, 1, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
   if gkDualOnOff==1 then
    a1b	Grain3b		iFrqRatio+gkTransDiff, gkphs+gkPtrDiff, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens*gkDensRatio, 600, 1, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
    if gkDelay>0 then
     a1b	vdelay	a1b,(gkDelay*1000)/kdens,5000
    endif
    a1	+=	a1b
   endif
 	outs	a1*aenv*klevel,a1*aenv*klevel		; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	Grain3b		iFrqRatio, gkphs, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens, 600, 1, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
   a2	Grain3b		iFrqRatio, gkphs, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens, 600, 2, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
   if gkDualOnOff==1 then
    a1b	Grain3b		iFrqRatio+gkTransDiff, gkphs+gkPtrDiff, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens*gkDensRatio, 600, 1, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
    a2b	Grain3b		iFrqRatio+gkTransDiff, gkphs+gkPtrDiff, gkspd, gkfreeze, gkrange, gkshape, gkfmd, gkpmd, kdur, kdens*gkDensRatio, 600, 2, iwfn, -2, -2 , rnd(1000), 8, iPhsMode, gkDensRnd, gkSizeRnd
    if gkDelay>0 then
     a1b	vdelay	a1b,(gkDelay*1000)/kdens,5000
     a2b	vdelay	a2b,(gkDelay*1000)/kdens,5000
    endif
    a1	+=	a1b
    a2	+=	a2b
   endif
 	outs	a1*aenv*klevel,a2*aenv*klevel		; send stereo signal to outputs
  endif
  rireturn

 endif

endin

</CsInstruments>  

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>
; LoscilFilePlayer.csd
; Written by Iain McCurdy, 2014
; 
; Load a user selected sound file into a GEN 01 function table and plays it back using loscil3. 
; This file player is best suited for polyphonic playback and is less well suited for the playback of very long sound files .
; 
; The sound file can be played back using the Play/Stop button (and the 'Transpose' / 'Speed' buttons to implement pitch/speed change)
;  or it can be played back using the MIDI keyboard.
; 
; The loop points can be set either by using the loop 'Start' and 'End' sliders or by clicking and dragging on the waveform view -
;  - loscil will take the values from the last control input moved.

<Cabbage>
form caption("Loscil File Player") size(685,340), colour(0,0,0) pluginid("Losc") style("legacy")
image                    bounds(  0,  0,685,340), colour(30, 70, 30), outlinecolour("White"), line(3), shape("sharp")	; main panel colouration    

soundfiler bounds(  5,  5,675,175), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 

image    bounds(  0,180,685,160), colour(0,0,0,0), outlinecolour("white"), line(2), shape("sharp"), plant("controls"){
filebutton bounds(  5, 10, 80, 25), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5, 40, 95, 25), channel("PlayStop"), text("Play/Stop"), colour("yellow"), fontcolour("white")

label      bounds(110, 12, 80, 12), text("Looping Mode"), fontcolour("white")
combobox   bounds(110, 25, 80, 20), channel("loop"), items("None", "Forward", "Fwd./Bwd."), value(1), fontcolour("white")

label      bounds(241,  4, 43, 8), text("L   O   O   P"), fontcolour("white")
rslider    bounds(205, 15, 60, 60), channel("LoopStart"), range(0, 1, 0),                   colour( 50, 90, 50), text("Start"),     textcolour("white")
rslider    bounds(260, 15, 60, 60), channel("LoopEnd"),   range(0, 1, 1),                   colour( 50, 90, 50), text("End"),       textcolour("white")
line       bounds(320, 10,  2, 65), colour("Grey")

label      bounds(357,  4, 53, 8), text("S   P   E   E   D"), fontcolour("white")
rslider    bounds(325, 15, 60, 60), channel("transpose"), range(-24, 24, 0,1,1),            colour( 50, 90, 50), text("Transpose"), textcolour("white")
rslider    bounds(380, 15, 60, 60), channel("speed"),     range( 0, 4.00, 1, 0.5),          colour( 50, 90, 50), text("Speed"),     textcolour("white")
line       bounds(440, 10,  2, 65), colour("Grey")

label      bounds(456,  4, 90, 8), text("E   N   V   E   L   O   P   E"), fontcolour("white")
rslider    bounds(445, 15, 60, 60), channel("AttTim"),    range(0, 5, 0, 0.5, 0.001),       colour( 50, 90, 50), text("Att.Tim"),   textcolour("white")
rslider    bounds(500, 15, 60, 60), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), colour( 50, 90, 50), text("Rel.Tim"),   textcolour("white")
line       bounds(560, 10,  2, 65), colour("Grey")

label      bounds(580,  4, 80, 8), text("C   O   N   T   R   O   L"), fontcolour("white")
rslider    bounds(565, 15, 60, 60), channel("MidiRef"),   range(0,127,60, 1, 1),            colour( 50, 90, 50), text("MIDI Ref."), textcolour("white")
rslider    bounds(620, 15, 60, 60), channel("level"),     range(  0,  3.00, 1, 0.5),        colour( 50, 90, 50), text("Level"),     textcolour("white")

keyboard bounds(5, 80, 675, 75)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0 -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs = 1

		massign	0,3
gichans		init	0
giReady		init	0
gSfilepath	init	""
gkTabLen	init	2

instr	1
 gkloop		chnget	"loop"
 kLoopStart	chnget	"LoopStart"
 kLoopEnd	chnget	"LoopEnd"
 kLoopEnd	limit	kLoopEnd,kLoopStart+0.01,1	; limit loop end to prevent crashes
 kbeg		chnget	"beg"				; click and drag
 klen		chnget	"len"				;  "

 ; loop points defined by sliders or click and drag...
 kTrigSlid	changed	kLoopStart,kLoopEnd	
 kTrigCAD	changed	kbeg,klen
 if kTrigSlid==1 then
  gkLoopStart	=	kLoopStart
  gkLoopEnd	=	kLoopEnd
 elseif kTrigCAD==1 then
  gkLoopStart	=	kbeg/gkTabLen
  gkLoopEnd	=	(kbeg+klen)/gkTabLen
 endif


 gkPlayStop	chnget	"PlayStop"
 gktranspose	chnget	"transpose"
 gkspeed	chnget	"speed"
 gklevel	chnget	"level"

 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0				; call instrument to update sample storage function table 
 endif  
 
 ktrig	trigger	gkPlayStop,0.5,0		; if play button changes to 'play', generate a trigger
 schedkwhen	ktrig,0,0,2,0,-1		; start instr 2 playing a held note

 ktrig1	changed	gktranspose			; if 'transpose' button is changed generate a '1' trigger
 ktrig2	changed	gkspeed				; if 'speed' button is changed generate a '1' trigger
 
 if ktrig1==1 then				; if transpose control has been changed...
  chnset	semitone(gktranspose),"speed"	; set speed according to transpose value
 elseif ktrig2==1 then		; if speed control has been changed...
  chnset	log2(gkspeed)*12,"transpose"	; set transpose control according to speed value
 endif

endin

instr	99	; load sound file
 gitable	ftgen	1,0,0,1,gSfilepath,0,0,0		; load sound file into a GEN 01 function table 
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 giReady 	=	1					; if no string has yet been loaded giReady will be zero
 gkTabLen	init		ftlen(gitable)/gichans		; table length in sample frames
 Smessage sprintfk "file(%s)", gSfilepath			; print sound file to viewer
 chnset Smessage, "filer1"	
endin

instr	2	; sample triggered by 'play/stop' button
 if gkPlayStop==0 then
  turnoff
 endif
 ktrig changed	gkloop,gkLoopStart,gkLoopEnd
 if ktrig==1 then
  reinit RESTART
 endif
 RESTART:
 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)
  kspeed	portk	gkspeed,kporttime			; apply portamento smoothing to changes in speed
  klevel	portk	gklevel,kporttime			; apply portamento smoothing to changes in level
  if gichans==1 then						; if mono...
   a1	loscil3	klevel,kspeed,gitable,1,i(gkloop)-1,nsamp(gitable)*i(gkLoopStart),nsamp(gitable)*i(gkLoopEnd)	; use a mono loscil3
 	outs	a1*aenv,a1*aenv					; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1,a2	loscil3	klevel,kspeed,gitable,1,i(gkloop)-1,nsamp(gitable)*i(gkLoopStart),nsamp(gitable)*i(gkLoopEnd)	; use stereo loscil3
 	outs	a1*aenv,a2*aenv					; send stereo signal to outputs
  endif               
 endif
endin

instr	3	; sample triggered by midi note
 icps	cpsmidi							; read in midi note data as cycles per second
 iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
 iMidiRef	chnget	"MidiRef"

 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)
  ispeed	=	icps/cpsmidinn(iMidiRef)	; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)
  klevel	portk	gklevel,kporttime		; apply portamento smoothing to changes in level
  if gichans==1 then						; if mono...
   a1	loscil3	klevel*aenv*iamp,ispeed,gitable,1,i(gkloop)-1,nsamp(gitable)*i(gkLoopStart),nsamp(gitable)*i(gkLoopEnd)	; use a mono loscil3
 	outs	a1,a1						; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1,a2	loscil3	klevel*aenv*iamp,ispeed,gitable,1,i(gkloop)-1,nsamp(gitable)*i(gkLoopStart),nsamp(gitable)*i(gkLoopEnd)	; use stereo loscil3
 	outs	a1,a2						; send stereo signal to outputs
  endif
 endif
endin
 
</CsInstruments>  

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>
; MincerFilePlayer.csd
; Written by Iain McCurdy, 2014

; Three modes of playback are offered:
; 1. Manual Pointer
;     Pointer position is determined by the long horizontal slider 'Manual Pointer'.
; 2. Mouse Scrubber
;     Pointer position is determined by the mouse's X position over the waveform view. Playback is also started and stopped using right-click.
; 3. Loop Region
;     A region that has been highlighted using left-click and drag is looped using a method and speed chosen in the 'LOOP REGION' GUI area.
;     Speed can be random-modulated by increasing Mod.Range. The nature of the modulation is changed using 'Rate 1' and 'Rate 2'. The random function generator is jspline.

; Transpose can be expressed either in semitones or a simple ratio. Select mode 'Semitones' or 'Ratio'

; MOD. POINTER section contains controls which modulate the pointer position using a 'sample-and-hold' type random function
; 
 
; All three of the above methods are playable from a MIDI keyboard (first activate the 'MIDI' checkbox).
;  Transposition for MIDI activated notes is governed bu both the MIDI key played and the setting for 'Transpose'


<Cabbage>
form caption("Mincer File Player") size(1055,370), colour(  0,  0,  0) pluginid("Minc"), guirefresh(10) style("legacy")
image                    bounds(  0,  0,1055,370), colour( 50,100,100), outlinecolour("White"), line(3), shape("sharp")

soundfiler bounds(  5,  5,1045,150), channel("beg","len"), channel("pos1","end1"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 
label bounds(6, 4, 560, 14), text(""), align(left), colour(0,0,0,0), fontcolour(200,200,200), identchannel("stringbox")

hslider    bounds(  0,150,1055, 30), channel("pointer"), range( 0,  1.00, 0.1), colour( 40, 80, 80),  trackercolour("white"), fontcolour("white")
label      bounds(  0,172,1055, 12), text("Manual Pointer"), fontcolour("white")

filebutton bounds(  5,185, 80, 22), text("Open File","Open File"), fontcolour("white"), channel("filename"), shape("ellipse")

checkbox bounds(  5,218,120, 12), text("Manual Pointer"), channel("r1"), fontcolour("white"), colour(yellow), radiogroup(1)
checkbox bounds(  5,232,120, 12), text("Mouse Scrubber"), channel("r2"), fontcolour("white"), colour(yellow), radiogroup(1), value(1) 
label    bounds( 19,246,100, 10), text("[right click and drag]"), fontcolour("white"), align("left")
checkbox bounds(  5,256,120, 12), text("Loop Region"),    channel("r3"), fontcolour("white"), colour(yellow), radiogroup(1) 
label    bounds( 19,270,100, 10), text("[left click and drag]"), fontcolour("white"), align("left")

checkbox   bounds(125,223, 60, 12), channel("lock"), text("Lock"), colour("yellow"), fontcolour("white"), value(1)
checkbox   bounds(125,243, 60, 12), channel("MIDI"), text("MIDI"), colour("yellow"), fontcolour("white")

label      bounds(105,183, 48, 12), text("FFT Size"), fontcolour("white")
combobox   bounds( 95,195, 70, 20), channel("FFTSize"), text("32768", "16384", "8192", "4096", "2048", "1024", "512", "256", "128", "64", "32", "16", "8", "4"), value(5), fontcolour("white")

combobox   bounds(170,175, 80, 20), text("Semitone","Ratio"), channel("IntervalMode"),       value(1)

image      bounds(175,200, 70, 70), colour(0,0,0,0), plant("Semitones"), identchannel("SemitonesPlant_ident"), visible(1) {
rslider    bounds(  0,  0, 70, 70), channel("Semitones"), range(-48, 48, 0,1,1), colour( 40, 80, 80), trackercolour("white"), text("Semitones"), textcolour("white")
}

image      bounds(175,200, 70, 70), colour(0,0,0,0), plant("Ratio"), identchannel("RatioPlant_ident"), visible(0) {
nslider bounds( 20,  0, 25, 18), channel("Numerator"),        range(1,99,3,1,1)
image     bounds( 15, 26, 35,  1), shape("sharp") 
nslider bounds( 20, 35, 25, 18), channel("Denominator"),      range(1,99,2,1,1)
}


rslider    bounds(240,200, 70, 70), channel("portamento"),range(0, 20,0.05,0.5,0.01), colour( 40, 80, 80), trackercolour("white"), text("Port.Time"), textcolour("white")

image      bounds(320,188, 305,90), colour(0,0,0,0), outlinecolour("silver"), outlinethickness(1), shape("sharp"), plant("LoopRegion") {
label      bounds(  0,  2, 305,10), text("L   O   O   P       R   E   G   I   O   N"), fontcolour("white")
label      bounds( 10, 24, 85, 12), text("Shape"), fontcolour("white")
combobox   bounds( 10, 37, 85, 20), channel("LoopMode"), text("Forward","Backward","Triangle","Sine"), value(1), fontcolour("white")
rslider    bounds(100, 17, 70, 70), channel("Speed"), range(-2, 2, 1,1,0.001),            colour( 40, 80, 80)), trackercolour("white"), text("Speed"), textcolour("white")
nslider  bounds(170, 35, 60, 30), channel("ModRange"), range(0,2,0,1,0.001),  colour(  0,  0,  0), text("Mod.Range"), textcolour("white")
nslider  bounds(235, 20, 60, 30), channel("Rate1"),    range(0,30,1,1,0.001), colour(  0,  0,  0), text("Rate 1"),    textcolour("white")
nslider  bounds(235, 50, 60, 30), channel("Rate2"),    range(0,30,2,1,0.001), colour(  0,  0,  0), text("Rate 2"),    textcolour("white")
}

image      bounds(630,188, 145,90), colour(0,0,0,0), outlinecolour("silver"), outlinethickness(1), shape("sharp"), plant("ModPtr") {
label      bounds(  0,  2, 135,10), text("M  O  D.     P  O  I  N  T  E  R"), fontcolour("white")
nslider  bounds( 10, 35, 60, 30), channel("PtrModRange"), range(0,1,0,1,0.001),  colour(  0,  0,  0), text("Mod.Range"), textcolour("white")
nslider  bounds( 75, 20, 60, 30), channel("PtrRate1"),    range(0,500,1,1,0.001), colour(  0,  0,  0), text("Rate 1"),    textcolour("white")
nslider  bounds( 75, 50, 60, 30), channel("PtrRate2"),    range(0,500,2,1,0.001), colour(  0,  0,  0), text("Rate 2"),    textcolour("white")
}

image      bounds(785,200,265, 70), colour(0,0,0,0), plant("output") {
rslider    bounds(  0,  0, 70, 70), channel("AttTim"),    range(0, 5, 0, 0.5, 0.001),       colour( 40, 80, 80),  trackercolour("white"), text("Att.Tim"),   textcolour("white")
rslider    bounds( 65,  0, 70, 70), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), colour( 40, 80, 80),  trackercolour("white"), text("Rel.Tim"),   textcolour("white")
rslider    bounds(130,  0, 70, 70), channel("MidiRef"),   range(0,127,60, 1, 1),            colour( 40, 80, 80),  trackercolour("white"), text("MIDI Ref."), textcolour("white")
rslider    bounds(195,  0, 70, 70), channel("level"),     range(  0,  1.00, 1, 0.5),        colour( 40, 80, 80),  trackercolour("white"), text("Level"),     textcolour("white")
}

keyboard bounds(  5,290,1045, 75)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0 -d
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

massign	0,3

gichans		init	0		; 
giReady		init	0		; flag to indicate function table readiness

giFFTSizes[]	array	32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4	; an array is used to store FFT window sizes
giTriangle		ftgen	0,0,4097,7,0,2048,1,2048,0
giRectSine		ftgen	0,0,4097,19,1,0.5,0,1
gSfilepath	init	""
gkFileLen	init	0

opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin				; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:					; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:				; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1		; Create a new string of just the file name
	xout	Sname			; Send it back to the caller instrument
endop

instr	1
 /* PORTAMENTO TIME FUNCTION */
 kporttimeW	chnget	"portamento"
 krampup	linseg	0,0.001,1
 kporttime	=	krampup * kporttimeW	

 /* SHOW HIDE INTERVAL MODE (SEMITONES OR RATIO) WIDGETS */
 kIntervalMode	chnget	"IntervalMode"
 if changed(kIntervalMode)==1 then				; semitones mode
  if kIntervalMode==1 then
  	chnset	"visible(0)","RatioPlant_ident"
  	chnset	"visible(1)","SemitonesPlant_ident"
  else								; ratio mode
  	chnset	"visible(1)","RatioPlant_ident"
  	chnset	"visible(0)","SemitonesPlant_ident"
  endif
 endif
 /* DEFINE TRANSPOSITION RATIO BASED ON INTERVAL MODE CHOICE */
 if kIntervalMode==1 then					; semitones mode
 	kSemitones	chnget	"Semitones"
 	;kSnap		chnget	"Snap"
 	;if kSnap==1 then
 	; if frac(kSemitones)!=0 then
 	;  kSemitones	=	round(kSemitones)
 	;  		chnset	kSemitones,"Semitones"
 	; endif
 	;endif
  	kSemitones	portk	kSemitones,kporttime
  	gktranspose	=	semitone(kSemitones)	
 else								; ratio mode
 	kNumerator	chnget	"Numerator"
 	kDenominator	chnget	"Denominator"
 	gkRatio		=	kNumerator/kDenominator
 	gktranspose	portk	gkRatio,kporttime	
 endif

 gkr1		chnget	"r1"	; pointer/note mode select (radio buttons):	manual
 gkr2		chnget	"r2"	; 						mouse
 gkr3		chnget	"r3"	; 						loop
 gkmode		=	(gkr1) + (gkr2*2) + (gkr3*3)
 gkloop		chnget	"loop"
 gkMIDI		chnget	"MIDI"
 gklock		chnget	"lock"
 gkfreeze	chnget	"freeze"
 gkfreeze	=	1-gkfreeze
 gklevel	chnget	"level"
 gkFFTSize	chnget	"FFTSize"
 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 gkLoopStart	chnget	"beg"			; Click-and-drag region beginning in sample frames
 gkLoopLen	chnget	"len"			; Click-and-drag region length in sample frames
 gkLoopLen	limit	gkLoopLen,1,gkFileLen	
 gkLoopMode	chnget	"LoopMode"
 gkSpeed	chnget	"Speed"
 gkModRange	chnget	"ModRange"
 if gkModRange>0 then
  gkRate1	chnget	"Rate1"
  gkRate2	chnget	"Rate2"
  kMod		jspline	gkModRange,gkRate1,gkRate2
  kSpeed2	=	gkSpeed + kMod
  gkSpeed	=	kSpeed2
 endif
 gkPtrModRange	chnget	"PtrModRange"
 gkPtrRate1	chnget	"PtrRate1"
 gkPtrRate2	chnget	"PtrRate2"

 gkMOUSE_DOWN_RIGHT	chnget	"MOUSE_DOWN_RIGHT"		; Read in mouse right click status
 kStartScrub		trigger	gkMOUSE_DOWN_RIGHT,0.5,0	; generate a momentary trigger whenver right mouse button is clicked
 
 if gkMOUSE_DOWN_RIGHT==1 && gkmode==2 then
  kMOUSE_X	chnget	"MOUSE_X"
  kMOUSE_Y	chnget	"MOUSE_Y"
  if kStartScrub==1 then 					; prevent initial portamento when a new note is started using right click
   reinit RAMP_FUNC
  endif
  RAMP_FUNC:
  krampup	linseg	0,0.001,1
  rireturn
  kMOUSE_X	portk	(kMOUSE_X - 5) / 1045, kporttime			; Mouse X to pointer position
  kMOUSE_Y	limit	1 - ((kMOUSE_Y - 5) / 150), 0, 1		; Mouse Y transposition
  gapointer	interp	kMOUSE_X
  kSemitones	chnget	"Semitones"
  gktranspose	portk	((kMOUSE_Y*2)-1)*kSemitones,kporttime		; Transposition is scaled using transposition value derived either from 'Semitone' slider or 'Ratio' nslideres
  gktranspose	=	semitone(gktranspose)
  gklevel	portk	kMOUSE_Y*gklevel + (1-gklevel), kporttime*krampup
  schedkwhen	kStartScrub,0,0,2,0,-1
 else
  kpointer	chnget	"pointer"
  kpointer	portk	kpointer,kporttime
  gapointer	interp	kpointer
 endif
                                
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0				; call instrument to update sample storage function table 
 endif  
 
 if changed(gkmode+gkMIDI)==1 then
  if gkmode==1||gkmode==3&&gkMIDI==0 then
   event	"i",2,0,-1
  endif
 endif
endin

instr	99	; load sound file
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 gitableL	ftgen	1,0,0,1,gSfilepath,0,0,1
 if gichans==2 then
  gitableR	ftgen	2,0,0,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero
 gkFileLen	init	ftlen(1)
 
 Smessage sprintfk "file(%s)", gSfilepath			; print sound file image to fileplayer
 chnset Smessage, "filer1"
 
 /* WRITE FILE NAME TO GUI */
 Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
 Smessage sprintfk "text(%s)",Sname
 chnset Smessage, "stringbox"

endin

instr	2	; non-midi
 if gkmode!=1 && gkmode!=3 && gkMOUSE_DOWN_RIGHT!=1 || gkMIDI==1 then
  turnoff
 endif
 if giReady = 1 then				; i.e. if a file has been loaded
  aenv	linsegr	0,0.01,1,0.01,0			; simple de-click envelope
    
  iFileLen	=	ftlen(gitableL)/sr
  
  if i(gkmode)==3 then
   if gkLoopMode==1 then
    apointer	phasor	(sr*gkSpeed)/gkLoopLen
   elseif gkLoopMode==2 then
    apointer	phasor	-(sr*gkSpeed)/gkLoopLen
   elseif gkLoopMode==3 then
    apointer	poscil	1,(sr*gkSpeed*0.5)/gkLoopLen,giTriangle
   elseif gkLoopMode==4 then
    apointer	poscil	1,(sr*gkSpeed*0.5)/gkLoopLen,giRectSine
   endif
   apointer	=		(apointer * (gkLoopLen/sr)) + (gkLoopStart/sr)
  else
   apointer	=	gapointer*iFileLen
  endif

  /* RANDOM POINTER MODULATION */
  if gkPtrModRange>0 then
   kRndPtrRate	init	random(i(gkPtrRate1),i(gkPtrRate2))
   kRndPtrTrig	metro	kRndPtrRate
   kRndPtrRate	trandom	kRndPtrTrig,gkPtrRate1,gkPtrRate2
   kRndPtrPos	trandom	kRndPtrTrig,-gkPtrModRange*iFileLen,gkPtrModRange*iFileLen
   apointer	+=	interp(kRndPtrPos)
  endif
  
  ktrig	changed		gkFFTSize
  if ktrig==1 then
   reinit RESTART
  endif
  RESTART:
  if gichans=1 then
   a1	mincer		apointer, gklevel, gktranspose, gitableL, gklock, giFFTSizes[i(gkFFTSize)-1]
  	outs	a1*aenv,a1*aenv                                                                                                                                          
  elseif gichans=2 then
   a1	mincer		apointer, gklevel, gktranspose, gitableL, gklock, giFFTSizes[i(gkFFTSize)-1]
   a2	mincer		apointer, gklevel, gktranspose, gitableR, gklock, giFFTSizes[i(gkFFTSize)-1]
  	outs	a1*aenv,a2*aenv
 endif
endif
endin

instr	3	; midi triggered instrument
 if giReady = 1 then						; i.e. if a file has been loaded
  icps	cpsmidi							; read in midi note data as cycles per second
  iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
  iMidiRef	chnget	"MidiRef"				; MIDI unison reference note
  iFrqRatio		=	icps/cpsmidinn(iMidiRef)	; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)                                          
 
  iAttTim	chnget	"AttTim"		; read in amplitude envelope attack time widget
  iRelTim	chnget	"RelTim"		; read in amplitude envelope attack time widget                                                                                                                                   
  if iAttTim>0 then				;                                       
   kenv	linsegr	0,iAttTim,1,iRelTim,0
  else								
   kenv	linsegr	1,iRelTim,0			; attack time is zero so ignore this segment of the envelope (a segment of duration zero is not permitted
  endif
  kenv	expcurve	kenv,8			; remap amplitude value with a more natural curve
  aenv	interp		kenv			; interpolate and create a-rate envelope

  iFileLen	=	ftlen(gitableL)/sr

  if i(gkmode)==3 then
   if gkLoopMode==1 then
    apointer	phasor	(sr*gkSpeed)/gkLoopLen
   elseif gkLoopMode==2 then
    apointer	phasor	-(sr*gkSpeed)/gkLoopLen
   elseif gkLoopMode==3 then
    apointer	poscil	1,(sr*gkSpeed*0.5)/gkLoopLen,giTriangle
   elseif gkLoopMode==4 then
    apointer	poscil	1,(sr*gkSpeed*0.5)/gkLoopLen,giRectSine
   endif
   apointer	=		(apointer * (gkLoopLen/sr)) + (gkLoopStart/sr)
  else                                                
   apointer	=	gapointer*iFileLen
  endif

  /* RANDOM POINTER MODULATION */
  if gkPtrModRange>0 then
   kRndPtrRate	init	random(i(gkPtrRate1),i(gkPtrRate2))
   kRndPtrTrig	metro	kRndPtrRate
   kRndPtrRate	trandom	kRndPtrTrig,gkPtrRate1,gkPtrRate2
   kRndPtrPos	trandom	kRndPtrTrig,-gkPtrModRange*iFileLen,gkPtrModRange*iFileLen
   apointer	+=	interp(kRndPtrPos)
  endif
                                                                        
  ktrig	changed		gkFFTSize
  if ktrig==1 then
   reinit RESTART
  endif
  RESTART:
  if gichans=1 then
   a1	mincer		apointer, gklevel*iamp, iFrqRatio*gktranspose, gitableL, gklock, giFFTSizes[i(gkFFTSize)-1]
  	outs	a1*aenv,a1*aenv
  elseif gichans=2 then
   a1	mincer		apointer, gklevel*iamp, iFrqRatio*gktranspose, gitableL, gklock, giFFTSizes[i(gkFFTSize)-1]
   a2	mincer		apointer, gklevel*iamp, iFrqRatio*gktranspose, gitableR, gklock, giFFTSizes[i(gkFFTSize)-1]
  	outs	a1*aenv,a2*aenv
  endif
 endif
endin

</CsInstruments>  

<CsScore>
i 1 0 10000
</CsScore>

</CsoundSynthesizer>
; SoundwarpFilePlayer.csd
; Written by Iain McCurdy, 2014

; Player can also be activated by using right-click and drag upon the waveform display panel.
;  In this mode, X position equates to pointer position and Y position equates to amplitude (level) and transposition.
;   (Transposition range when using mouse clicking-and-dragging is controlled using the 'Transposition' knob. Therefore if 'Transposition' = zero, no transposition occurs.)

<Cabbage>
form caption("Soundwarp File Player") size(835,340), colour(0,0,0) pluginid("SWPl"), guirefresh(32) style("legacy")
image                       bounds(  0,  0,835,340), colour( 30, 90, 60), outlinecolour("White"), line(3), shape("sharp")	; main panel colouration    

soundfiler bounds(  5,  5,825,175), channel("beg","len"), channel("pos1","end1"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 

filebutton bounds(  5,185, 80, 22), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5,210, 95, 17), channel("PlayStop"), text("Play/Stop"), fontcolour("white")
label      bounds(  5,228,115, 10), text("[or right-click-and-drag]"), fontcolour("white")
checkbox   bounds(  5,240,100, 17), channel("freeze"), text("Freeze"), colour("LightBlue"), fontcolour("white")

label      bounds(245,184,180, 8), text("G   R   A   I   N   S"), fontcolour("white")
rslider    bounds(120,195, 60, 60), channel("overlap"),     range( 1, 100, 20, 1,1),            colour( 50,110, 80), text("Overlaps"),     textcolour("white"), trackercolour(150,210,180)
rslider    bounds(175,195, 60, 60), channel("grsize"),      range( 1, 40000, 800, 0.5,1),       colour( 50,110, 80), text("Size"),         textcolour("white"), trackercolour(150,210,180)
rslider    bounds(230,195, 60, 60), channel("grsizeOS"),    range( 0, 2.00,   0.5,  0.5),       colour( 50,110, 80), text("Size OS"),      textcolour("white"), trackercolour(150,210,180)
rslider    bounds(285,195, 60, 60), channel("transpose"),   range(-48, 48, 0,1,0.001),          colour( 50,110, 80), text("Transpose"),    textcolour("white"), trackercolour(150,210,180)

label      bounds(367,198, 35, 10), text("M o d e"), fontcolour("white")
combobox   bounds(348,208, 74, 17), channel("mode"), items("Speed", "Pointer", "Region"), value(1), fontcolour("white")
label      bounds(364,227, 40, 10), text("S h a p e"), fontcolour("white")
combobox   bounds(348,237, 74, 17), channel("shape"), items("Hanning", "Perc.1", "Perc.2", "Gate", "Rev.Perc.1", "Rev.Perc.2"), value(1), fontcolour("white")

rslider    bounds(425,195, 60, 60), channel("speed"),       range( 0.00, 5.00, 1,0.5,0.001),           colour( 50,110, 80), text("Speed"),   textcolour("white"), trackercolour(150,210,180), visible(1), identchannel("SpeedID")
rslider    bounds(425,195, 60, 60), channel("ptr"),         range(     0,1.00, 0.5,1,0.001),           colour( 50,110, 80), text("Pointer"), textcolour("white"), trackercolour(150,210,180), visible(0), identchannel("PtrID")
rslider    bounds(480,195, 60, 60), channel("ptrOS"),       range(     0, 1.000, 0, 0.5, 0.001),       colour( 50,110, 80), text("Ptr.OS"),  textcolour("white"), trackercolour(150,210,180), visible(0), identchannel("PtrOSID")
rslider    bounds(535,195, 60, 60), channel("port"),        range(     0,30.000,0.01, 0.5,0.001),      colour( 50,110, 80), text("Port."),   textcolour("white"), trackercolour(150,210,180), visible(0), identchannel("PortID")
rslider    bounds(535,195, 60, 60), channel("inskip"),      range(     0, 1.00, 0),                    colour( 50,110, 80), text("inskip"),  textcolour("white"), trackercolour(150,210,180), visible(1), identchannel("inskipID")

line       bounds(595,190,  2, 65), colour("Grey")

label      bounds(595,184,120, 8), text("E   N   V   E   L   O   P   E"), fontcolour("white")
rslider    bounds(598,195, 60, 60), channel("AttTim"),    range(0, 5.00, 0.01, 0.5, 0.001),  colour( 50,110, 80), text("Att.Tim"), textcolour("white"), trackercolour(150,210,180)
rslider    bounds(650,195, 60, 60), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001),  colour( 50,110, 80), text("Rel.Tim"), textcolour("white"), trackercolour(150,210,180)

line       bounds(711,190,  2, 65), colour("Grey")

label      bounds(732,184, 80, 8), text("C   O   N   T   R   O   L"), fontcolour("white")
rslider    bounds(715,195, 60, 60), channel("MidiRef"),   range(0,127,60, 1, 1),            colour( 50,110, 80), text("MIDI Ref."), textcolour("white"), trackercolour(150,210,180)
rslider    bounds(770,195, 60, 60), channel("level"),     range(  0,  1.00, 0.4, 0.5),      colour( 50,110, 80), text("Level"),     textcolour("white"), trackercolour(150,210,180)

keyboard   bounds(5,260,825, 75)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0 -dm0
</CsOptions>

<CsInstruments>

sr = 48000
ksmps = 64
nchnls = 2
0dbfs=1

massign	0,3
gichans		init	0
giFileLen	init	0
giReady		init	0
gSfilepath	init	""

; WINDOWING FUNCTIONS USED TO DYNAMICALLY SHAPE THE GRAINS
; NUM | INIT_TIME | SIZE | GEN_ROUTINE | PARTIAL_NUM | STRENGTH | PHASE
; GRAIN ENVELOPE WINDOW FUNCTION TABLES:
;giwfn1	ftgen	0,  0, 131072,  20,   1, 1 					; HANNING
giwfn1	ftgen	0,  0, 131072,  9,    0.5, 1,0 					; HALF SINE
giwfn2	ftgen	0,  0, 131072,  7,    0, 3072,   1, 128000,    0		; PERCUSSIVE - STRAIGHT SEGMENTS
giwfn3	ftgen	0,  0, 131072,  5, .001, 3072,   1, 128000, .001		; PERCUSSIVE - EXPONENTIAL SEGMENTS
giwfn4	ftgen	0,  0, 131072,  7,    0, 1536,   1, 128000,    1, 1536, 0	; GATE - WITH DE-CLICKING RAMP UP AND RAMP DOWN SEGMENTS
giwfn5	ftgen	0,  0, 131072,  7,    0, 128000, 1, 3072,      0		; REVERSE PERCUSSIVE - STRAIGHT SEGMENTS
giwfn6	ftgen	0,  0, 131072,  5, .001, 128000, 1, 3072,   .001		; REVERSE PERCUSSIVE - EXPONENTIAL SEGMENTS

instr	1
 gkloop		chnget	"loop"
 gkPlayStop	chnget	"PlayStop"
 gkfreeze	chnget	"freeze"
 gkfreeze	=	1-gkfreeze
 gktranspose	chnget	"transpose"
 gkoverlap	chnget	"overlap"
 gkgrsize	chnget	"grsize"
 gkgrsizeOS	chnget	"grsizeOS"
 gkshape	chnget	"shape"
 gkmode		chnget	"mode"
 gkmode		init	1
 gkspeed	chnget	"speed"
 gkptrOS	chnget	"ptrOS"
 gkport		chnget	"port"
 kporttime	linseg	0,0.001,1
 gkinskip	chnget	"inskip"
 gklevel	chnget	"level"
 gkLoopStart	chnget	"beg"		;from soundfiler
 gkLoopEnd	chnget	"len"			;from soundfiler
 
 
 ; SHOW OR HIDE WIDGETS -------------------------------------
 kchange	changed	gkmode
 if(kchange==1) then
	if gkmode==1 then
	 chnset "visible(1)", "SpeedID"
	 chnset "visible(0)", "PtrOSID"
	 chnset "visible(0)", "PtrID"
	 chnset "visible(0)", "PortID"
	 chnset "visible(1)", "inskipID"
	endif
	if gkmode==2 then
	 chnset "visible(0)", "SpeedID"
	 chnset "visible(1)", "PtrOSID"
	 chnset "visible(1)", "PtrID"
	 chnset "visible(1)", "PortID"
	 chnset "visible(0)", "inskipID"
	endif
	if gkmode==3 then
	 chnset "visible(0)", "SpeedID"
	 chnset "visible(0)", "PtrOSID"
	 chnset "visible(0)", "PtrID"
	 chnset "visible(0)", "PortID"
	 chnset "visible(0)", "inskipID"
	endif
endif
; -----------------------------------------------------------

 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0				; call instrument to update sample storage function table 
 endif  

 ktrig	trigger	gkPlayStop,0.5,0
 schedkwhen	ktrig,0,0,2,0,-1

 /* MOUSE SCRUBBING */
 gkMOUSE_DOWN_RIGHT	chnget	"MOUSE_DOWN_RIGHT"	; Read in mouse left click status
 kStartScrub		trigger	gkMOUSE_DOWN_RIGHT,0.5,0
 if gkMOUSE_DOWN_RIGHT==1 then
  gkmode	=	2
  if kStartScrub==1 then 
   reinit RAMP_FUNC
  endif
  RAMP_FUNC:
  krampup	linseg	0,0.001,1
  rireturn
  kMOUSE_X	chnget	"MOUSE_X"
  kMOUSE_Y	chnget	"MOUSE_Y"
  kMOUSE_X	=	(kMOUSE_X - 5) / 825
  kMOUSE_Y	portk	1 - ((kMOUSE_Y - 5) / 175), krampup*0.05		; SOME SMOOTHING OF DENSITY CHANGES VIA THE MOUSE ENHANCES PERFORMANCE RESULTS. MAKE ANY ADJUSTMENTS WITH ADDITIONAL CONSIDERATION OF guirefresh VALUE 
  gkptr		limit	kMOUSE_X,0,1
  gklevel	limit	kMOUSE_Y^2, 0, 1
  gktranspose	=	((kMOUSE_Y*2)-1)*gktranspose	;, -gktranspose, gktranspose
  schedkwhen	kStartScrub,0,0,2,0,-1
 else
  kptr		chnget	"ptr"
  gkptr		portk	kptr,gkport*kporttime
  gklevel	chnget	"level"
 endif 
 
endin



instr	99	; load sound file
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 giFileLen	filelen		gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 gitableL	ftgen	1,0,0,1,gSfilepath,0,0,1
 if gichans==2 then
  gitableR	ftgen	2,0,0,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero

 Smessage sprintfk "file(%s)", gSfilepath
 chnset Smessage, "filer1"	

endin



instr	2	; triggered by 'play/stop' button
 if gkPlayStop==0&&gkMOUSE_DOWN_RIGHT==0 then
  turnoff
 endif
 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else            
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope

  kporttime	linseg	0,0.001,0.02				; portamento time function. (Rises quickly from zero to a held value.)

  kspeed	portk	gkspeed, kporttime
  kptr		portk	gkptr, kporttime
  
  ktranspose	portk	gktranspose,kporttime*3			; 
  
  ktrig	changed	gkshape,gkoverlap,gkgrsize,gkgrsizeOS,gkmode,gkinskip
  if ktrig==1 then
   reinit	UPDATE
  endif
  UPDATE:
  
  iwfn		=	i(gkshape) + giwfn1 - 1
  imode		=	i(gkmode) - 1

  if imode==0 then						; timestretch mode
   kwarp	=	1/(kspeed*gkfreeze)
   ibeg		=	i(gkinskip) * giFileLen
   kscrubber	init	ibeg*sr
   kscrubber	+=	kspeed*ksmps*gkfreeze
  elseif imode==1 then						; pointer mode
   kwarp	=	giFileLen * kptr
   ibeg		=	0
   kptrOS	random	0, (giFileLen - kwarp) * gkptrOS
   kwarp	=	kwarp + kptrOS
   kscrubber	=	(kwarp + kptrOS) * sr
  else								; region mode
   imode	=	1					; sndwarp mode used in region mode will be pointer mode
   kwarp	random	gkLoopStart/sr,(gkLoopStart+gkLoopEnd)/sr
   ibeg		=	0
   kscrubber	=	kwarp * sr
  endif

  apch		interp	semitone(ktranspose)
  klevel	portk	gklevel/(i(gkoverlap)^0.25), kporttime		; apply portamento smoothing to changes in level
  
  if gichans==1 then						; if mono...   
   a1	sndwarp		klevel, kwarp, apch, gitableL, ibeg, i(gkgrsize), i(gkgrsize) * i(gkgrsizeOS), i(gkoverlap), iwfn, imode
 	outs	a1*aenv,a1*aenv					; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	sndwarp		klevel, kwarp, apch, gitableL, ibeg, i(gkgrsize), i(gkgrsize) * i(gkgrsizeOS), i(gkoverlap), iwfn, imode
   a2	sndwarp		klevel, kwarp, apch, gitableR, ibeg, i(gkgrsize), i(gkgrsize) * i(gkgrsizeOS), i(gkoverlap), iwfn, imode
 	outs	a1*aenv,a2*aenv					; send stereo signal to outputs
  endif
  rireturn
 endif

 ; print scrubber
 if(metro(10)==1) then
  Smessage sprintfk "scrubberposition(%d)", kscrubber
  chnset Smessage, "filer1"
 endif

endin

instr	3
 icps	cpsmidi							; read in midi note data as cycles per second
 iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
 iAttTim	chnget	"AttTim"				; read in widgets
 iRelTim	chnget	"RelTim"
 iMidiRef	chnget	"MidiRef"
 iFrqRatio		=	icps/cpsmidinn(iMidiRef)	; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)

 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else            
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope

  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)

  kspeed	portk	gkspeed,kporttime
  kptr		portk	gkptr, kporttime
  
  ktranspose	portk	gktranspose,kporttime			; 
  
  ktrig	changed	gkshape,gkoverlap,gkgrsize,gkgrsizeOS,gkmode,gkinskip
  if ktrig==1 then
   reinit	UPDATE
  endif
  UPDATE:
  
  iwfn		=	i(gkshape) + giwfn1 - 1
  imode		=	i(gkmode) - 1
  
  if imode==0 then						; timestretch mode
   kwarp	=	1/(kspeed*gkfreeze)
   ibeg		=	i(gkinskip) * giFileLen
   kscrubber	init	ibeg*sr
   kscrubber	+=	kspeed*ksmps*gkfreeze
  elseif imode==1 then						; pointer mode
   kwarp	=	giFileLen * kptr
   kptrOS	random	0, (giFileLen - kwarp) * gkptrOS
   kwarp	=	kwarp + kptrOS
   ibeg		=	0
   kscrubber	=	(kwarp + kptrOS) * sr
  else								; region mode
   imode	=	1					; sndwarp mode used in region mode will be pointer mode
   kwarp	random	gkLoopStart/sr,(gkLoopStart+gkLoopEnd)/sr
   ibeg		=	0
   kscrubber	=	kwarp * sr
  endif


  apch		interp	semitone(ktranspose)
  klevel	portk	gklevel/(i(gkoverlap)^0.25), kporttime		; apply portamento smoothing to changes in level

  if gichans==1 then						; if mono...
   a1	sndwarp		klevel*iamp, kwarp, iFrqRatio, gitableL, ibeg, i(gkgrsize), i(gkgrsize) * i(gkgrsizeOS), i(gkoverlap), iwfn, imode
 	outs	a1*aenv,a1*aenv					; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	sndwarp		klevel*iamp, kwarp, iFrqRatio, gitableL, ibeg, i(gkgrsize), i(gkgrsize) * i(gkgrsizeOS), i(gkoverlap), iwfn, imode
   a2	sndwarp		klevel*iamp, kwarp, iFrqRatio, gitableR, ibeg, i(gkgrsize), i(gkgrsize) * i(gkgrsizeOS), i(gkoverlap), iwfn, imode
 	outs	a1*aenv,a2*aenv					; send stereo signal to outputs
  endif
  rireturn
 endif


 iactive	active	p1
 if iactive==1 then 
  if imode==0 then						; timestretch mode
   kscrubber	init	0
   kscrubber	+=	kspeed*ksmps*gkfreeze
  else								; pointer mode
   kptrOS	random	0, (giFileLen - kwarp) * gkptrOS
   kwarp	=	kwarp + kptrOS
   kscrubber	=	(kwarp + kptrOS) * sr
  endif
 
  ; print scrubber
 if(metro(10)==1) then
  Smessage sprintfk "scrubberposition(%d)", kscrubber
  chnset Smessage, "filer1"
 endif

 endif
endin

/*
event_i	"i",999,0,3600
instr	999
 aL,aR	monitor
 		fout	"SndWarpOut.wav",4,aL,aR
endin
*/

</CsInstruments>  

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>
; SyncgrainFilePlayer.csd
; Written by Iain McCurdy, 2014
; 
; The internal pointer used by syncgrain to track progress through the sound file is affected by grain size and density as well as speed 
;  so on accaount of this complication a scrubber line in the waveform view is not yet implemented.

<Cabbage>
form caption("Syncgrain File Player") size(800,340), colour(0,0,0) pluginid("SGFP") style("legacy")
image                       bounds(  0,  0,800,340), colour( 90, 60, 30), outlinecolour("White"), shape("sharp"), line(3)	; main panel colouration    
soundfiler                  bounds(  5,  5,790,175), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 

image    bounds(  0,180,800,160), colour(0,0,0,0), outlinecolour("white"), line(0), shape("sharp"), plant("controls"){
filebutton bounds(  5, 10, 80, 25), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5, 40, 95, 25), channel("PlayStop"), text("Play/Stop"), fontcolour("white")
label      bounds(225,  4, 65, 8), text("G   R   A   I   N   S"), fontcolour("white")
rslider    bounds( 90, 15, 60, 60), channel("density"),   range( 0.5,400.00,20, 0.5),          colour( 70, 40, 10), text("Density"),     textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(145, 15, 60, 60), channel("DensOS"),     range( 0, 5.00, 0),                 colour( 70, 40, 10), text("Dens.OS"),     textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(200, 15, 60, 60), channel("grsize"),   range( 0.001,1.00, 0.04, 0.5),        colour( 70, 40, 10), text("Size"),        textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(255, 15, 60, 60), channel("SizeOS"),   range( 0, 5.00, 0, 0.5),              colour( 70, 40, 10), text("Size OS"),     textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(310, 15, 60, 60), channel("transpose"), range(-24, 24, 0,1,1),               colour( 70, 40, 10), text("Transpose"),   textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(365, 15, 60, 60), channel("TransposeOS"), range(0, 12.00, 0),                colour( 70, 40, 10), text("Trans.OS"),    textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(420, 15, 60, 60), channel("speed"),     range( -2.00, 2.00, 1),              colour( 70, 40, 10), text("Speed"),       textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
label      bounds(495, 12, 40, 10), text("S h a p e"), fontcolour("white")
combobox   bounds(478, 22, 74, 18), channel("shape"), items("Hanning", "Perc.1", "Perc.2", "Gate", "Rev.Perc.1", "Rev.Perc.2"), value(1),fontcolour("white")
checkbox   bounds(478, 45,100, 18), channel("freeze"), text("Freeze"), colour("LightBlue"), fontcolour("white")

line       bounds(559, 10,  2, 65), colour("Grey")

label      bounds(578,  4, 86, 8), text("E   N   V   E   L   O   P   E"), fontcolour("white")
rslider    bounds(565, 15, 60, 60), channel("AttTim"),    range(0, 5, 0, 0.5, 0.001),       colour( 70, 40, 10), text("Att.Tim"),   textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(620, 15, 60, 60), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), colour( 70, 40, 10), text("Rel.Tim"),   textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)

line       bounds(684, 10,  2, 65), colour("Grey")

label      bounds(702,  4, 76, 8), text("C   O   N   T   R   O   L"), fontcolour("white")
rslider    bounds(685, 15, 60, 60), channel("MidiRef"),   range(0,127,60, 1, 1),            colour( 70, 40, 10), text("MIDI Ref."), textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)
rslider    bounds(740, 15, 60, 60), channel("level"),     range(  0,  3.00, 1, 0.5),        colour( 70, 40, 10), text("Level"),     textcolour("white"), trackercolour(190,170,130), outlinecolour(100,100,100)

keyboard bounds(5, 80,790, 75)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0 -dm0
</CsOptions>

<CsInstruments>

sr = 48000
ksmps = 64
nchnls = 2
0dbfs=1

massign	0,3
gichans		init	0
giReady		init	0
gSfilepath	init	""

; WINDOWING FUNCTIONS USED TO DYNAMICALLY SHAPE THE GRAINS
; NUM | INIT_TIME | SIZE | GEN_ROUTINE | PARTIAL_NUM | STRENGTH | PHASE
; GRAIN ENVELOPE WINDOW FUNCTION TABLES:
giwfn1	ftgen	0,  0, 131072,  20,   2, 1 					; HANNING
giwfn2	ftgen	0,  0, 131072,  7,    0, 3072,   1, 128000,    0		; PERCUSSIVE - STRAIGHT SEGMENTS
giwfn3	ftgen	0,  0, 131072,  5, .001, 3072,   1, 128000, .001		; PERCUSSIVE - EXPONENTIAL SEGMENTS
giwfn4	ftgen	0,  0, 131072,  7,    0, 1536,   1, 128000,    1, 1536, 0	; GATE - WITH DE-CLICKING RAMP UP AND RAMP DOWN SEGMENTS
giwfn5	ftgen	0,  0, 131072,  7,    0, 128000, 1, 3072,      0		; REVERSE PERCUSSIVE - STRAIGHT SEGMENTS
giwfn6	ftgen	0,  0, 131072,  5, .001, 128000, 1, 3072,   .001		; REVERSE PERCUSSIVE - EXPONENTIAL SEGMENTS

instr	1
 gkloop		chnget	"loop"
 gkPlayStop	chnget	"PlayStop"
 gktranspose	chnget	"transpose"
 gkTransposeOS	chnget	"TransposeOS"
 gkdensity	chnget	"density"
 gkDensOS	chnget	"DensOS"
 gkgrsize	chnget	"grsize"
 gkSizeOS	chnget	"SizeOS"
 gkshape	chnget	"shape"
 gkspeed	chnget	"speed"
 gklevel	chnget	"level"
 gkfreeze	chnget	"freeze"
 gkfreeze	=	1-gkfreeze
        
 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0				; call instrument to update sample storage function table 
 endif  

 ktrig	trigger	gkPlayStop,0.5,0
 schedkwhen	ktrig,0,0,2,0,-1
endin

instr	99	; load sound file
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 gitableL	ftgen	1,0,0,1,gSfilepath,0,0,1
 if gichans==2 then
  gitableR	ftgen	2,0,0,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero
 Smessage sprintfk "file(%s)", gSfilepath			; print sound file to viewer
 chnset Smessage, "filer1"
endin

instr	2	; triggered by 'play/stop' button
 if gkPlayStop==0 then
  turnoff
 endif
 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else            
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)
  kdensity	portk	gkdensity,kporttime			; apply portamento smoothing to changes in speed
  kprate	portk	gkspeed,kporttime
  klevel	portk	gklevel,kporttime			; apply portamento smoothing to changes in level

  kDensOS	gauss	gkDensOS
  kDensMlt	=	octave(kDensOS)
  kdensity	=	kdensity * kDensMlt
  
  ktranspose	portk	gktranspose,kporttime			; 
  kTransposeOS	gauss	gkTransposeOS
  ktranspose	=	ktranspose + kTransposeOS
  
  kSizeOS	rand	gkSizeOS
  kgrsize	=	gkgrsize * octave(kSizeOS)
  
  giolaps	=	5000
  
  ktrig	changed	gkshape
  if ktrig==1 then
   reinit	UPDATE
  endif
  UPDATE:
  
  iwfn		=	i(gkshape) + giwfn1 - 1
  if gichans==1 then						; if mono...
   a1	syncgrain	klevel, kdensity, semitone(ktranspose), kgrsize, kprate*gkfreeze, gitableL, iwfn, giolaps
 	outs	a1*aenv,a1*aenv					; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	syncgrain	klevel, kdensity, semitone(ktranspose), kgrsize, kprate*gkfreeze, gitableL, iwfn, giolaps
   a2	syncgrain	klevel, kdensity, semitone(ktranspose), kgrsize, kprate*gkfreeze, gitableR, iwfn, giolaps
 	outs	a1*aenv,a2*aenv					; send stereo signal to outputs
  endif
  rireturn
 endif
endin

instr	3
 icps	cpsmidi							; read in midi note data as cycles per second
 iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
 iAttTim	chnget	"AttTim"				; read in widgets
 iRelTim	chnget	"RelTim"
 iMidiRef	chnget	"MidiRef"
 iFrqRatio		=	icps/cpsmidinn(iMidiRef)	; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)

 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else            
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)
  kdensity	portk	gkdensity,kporttime			; apply portamento smoothing to changes in speed
  kprate	portk	gkspeed,kporttime
  klevel	portk	gklevel,kporttime			; apply portamento smoothing to changes in level

  kDensOS	gauss	gkDensOS
  kDensMlt	=	octave(kDensOS)
  kdensity	=	kdensity * kDensMlt
    
  kSizeOS	rand	gkSizeOS
  kgrsize	=	gkgrsize * octave(kSizeOS)

  giolaps	=	5000
  
  ktrig	changed	gkshape
  if ktrig==1 then
   reinit	UPDATE
  endif
  UPDATE:
  
  iwfn		=	i(gkshape) + giwfn1 - 1
  if gichans==1 then						; if mono...
   a1	syncgrain	klevel*iamp, kdensity, iFrqRatio, kgrsize, kprate*gkfreeze, gitableL, iwfn, giolaps
 	outs	a1*aenv,a1*aenv					; send mono audio to both outputs 
  elseif gichans==2 then						; otherwise, if stereo...
   a1	syncgrain	klevel*iamp, kdensity, iFrqRatio, kgrsize, kprate*gkfreeze, gitableL, iwfn, giolaps
   a2	syncgrain	klevel*iamp, kdensity, iFrqRatio, kgrsize, kprate*gkfreeze, gitableR, iwfn, giolaps
 	outs	a1*aenv,a2*aenv					; send stereo signal to outputs
  endif
  rireturn
 endif

endin

</CsInstruments>  

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>
; Table3FilePlayer.csd
; Written by Iain McCurdy, 2014

; Load a user selected sound file into a GEN 01 function table and plays it back using loscil3. 
; This file player is suited for polyphonic playback and is less well suited for the playback of very long sound files .
;                                 
; Loop points can be edited by using either the sliders 'Start' and 'End' or by clicking and dragging on the waveform view.
;  Edit mode is selected automatically according to the last method used.
; 
; 
; Things still to do:
;  Add loop direction function when using sliders to edit loop points
;  Portamento control for loop points when using sliders to edit loop points
;  Add instructions in viewer panel.
;  MIDI note loop play in click-and-drag mode not working properly
 
 
<Cabbage>
form caption("Table3 File Player") size(740,340), colour(0,0,0) pluginid("T3Pl"), guirefresh(64) style("legacy")
image                    bounds(  0,  0,740,340), colour(30, 30, 70), outlinecolour("White"), line(3), shape("sharp")	; main panel colouration    
soundfiler               bounds(  5,  5,730,175), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 
label bounds(6, 4, 560, 14), text(""), align(left), colour(0,0,0,0), fontcolour(200,200,200), identchannel("stringbox")

filebutton bounds(  5,190, 80, 25), text("Open File","Open File"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5,220, 95, 25), channel("PlayStop"), text("Play/Stop"), colour("yellow"), fontcolour("white")

label      bounds(178,184, 45, 8), text("L   O   O   P"), fontcolour("white")

groupbox   bounds(100,200,100, 50), plant("looping"), text("Looping Mode"), fontcolour("white"){
combobox   bounds( 10, 25, 80, 20), channel("mode"), items("Forward", "Backward", "Fwd./Bwd."), value(1), fontcolour("white")
}
rslider    bounds(205,195, 60, 60), channel("LoopStart"), range(0, 1, 0),                   colour(60, 60,100), text("Start"),     textcolour("white"), trackercolour(210,210,250)
rslider    bounds(260,195, 60, 60), channel("LoopEnd"),   range(0, 1, 1),                   colour(60, 60,100), text("End"),       textcolour("white"), trackercolour(210,210,250)
rslider    bounds(315,195, 60, 60), channel("Portamento"),   range(0,0.1,0.01),                   colour(60, 60,100), text("Portamento"),       textcolour("white"), trackercolour(210,210,250)

line       bounds(375,190,  2, 65), colour("Grey")

label      bounds(409,184, 55, 8), text("S   P   E   E   D"), fontcolour("white")
rslider    bounds(380,195, 60, 60), channel("transpose"), range(-24, 24, 0,1,1),            colour(60, 60,100), text("Transpose"), textcolour("white"), trackercolour(210,210,250)
rslider    bounds(435,195, 60, 60), channel("speed"),     range(0, 4.00, 1, 0.5, 0.001),    colour(60, 60,100), text("Speed"),     textcolour("white"), trackercolour(210,210,250)

line       bounds(495,190,  2, 65), colour("Grey")

label      bounds(511,184, 90, 8), text("E   N   V   E   L   O   P   E"), fontcolour("white")
rslider    bounds(500,195, 60, 60), channel("AttTim"),    range(0, 5, 0.01, 0.5, 0.001),    colour(60, 60,100), text("Att.Tim"),   textcolour("white"), trackercolour(210,210,250)
rslider    bounds(555,195, 60, 60), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), colour(60, 60,100), text("Rel.Tim"),   textcolour("white"), trackercolour(210,210,250)
line       bounds(615,190,  2, 65), colour("Grey")

label      bounds(636,184, 80, 8), text("C   O   N   T   R   O   L"), fontcolour("white")
rslider    bounds(620,195, 60, 60), channel("MidiRef"),   range(0,127,60, 1, 1),            colour(60, 60,100), text("MIDI Ref."), textcolour("white"), trackercolour(210,210,250)
rslider    bounds(675,195, 60, 60), channel("level"),     range(  0,  3.00, 1, 0.5),        colour(60, 60,100), text("Level"),     textcolour("white"), trackercolour(210,210,250)

keyboard bounds(5,260, 730, 75)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0 -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

		massign	0,3
gichans		init	0
giFileLen	init	0
giReady		init	0
gSfilepath	init	""
gkTabLen	init	2
gitri		ftgen	0,0,131072,7,0,131072/2,1,131072/2,0
gkEditMode	init	2	; 1 = CAD 2 = sliders

opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin				; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:					; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:				; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1		; Create a new string of just the file name
	xout	Sname			; Send it back to the caller instrument
endop

instr	1	; Read in widgets
 gkMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"

 gkloop		chnget	"loop"

 gkLoopStart	chnget	"beg"		; Click-and-drag
 gkLoopLen	chnget	"len"
 
 gkLoopStart2	chnget	"LoopStart"	; Sliders
 gkLoopEnd2	chnget	"LoopEnd"
 gkPortamento	chnget	"Portamento"

 gkMOUSE_DOWN_RIGHT	chnget	"MOUSE_DOWN_RIGHT"			; Read in mouse left click status

 if changed(gkLoopStart,gkLoopLen)==1 then
  gkEditMode	=	1	; Click-and-drag
 elseif  changed(gkLoopStart2,gkLoopEnd2)==1||gkMOUSE_DOWN_RIGHT==1 then
  gkEditMode	=	2	; sliders
 endif
 
 gkPlayStop	chnget	"PlayStop"
 gktranspose	chnget	"transpose"
 gkspeed	chnget	"speed"
 gklevel	chnget	"level"
 gkmode		chnget	"mode"
 
 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 if kNewFileTrg==1 then					; if a new file has been loaded...
  event	"i",99,0,0						; call instrument to update sample storage function table 
 endif  
 
 ktrig	trigger	gkPlayStop,0.5,0		; if play button changes to 'play', generate a trigger
 schedkwhen	ktrig,0,0,2,0,-1			; start instr 2 playing a held note

 ktrig1	changed	gktranspose				; if 'transpose' button is changed generate a '1' trigger
 ktrig2	changed	gkspeed					; if 'speed' button is changed generate a '1' trigger
 
 if ktrig1==1 then								; if transpose control has been changed...
  chnset	semitone(gktranspose),"speed"		; set speed according to transpose value
 elseif ktrig2==1 then							; if speed control has been changed...
  chnset	log2(abs(gkspeed))*12,"transpose"	; set transpose control according to speed value
 endif

  /* MOUSE SCRUBBING */
 kStartScrub		trigger	gkMOUSE_DOWN_RIGHT,0.5,0
 if gkMOUSE_DOWN_RIGHT==1 then
  if kStartScrub==1 then 
   reinit RAMP_FUNC
  endif
  RAMP_FUNC:
  krampup	linseg	0,0.001,1
  rireturn
  kMOUSE_X	chnget	"MOUSE_X"
  kMOUSE_Y	chnget	"MOUSE_Y"
  kMOUSE_X	=	(kMOUSE_X - 5) / 730
  kMOUSE_Y	portk	1 - ((kMOUSE_Y - 5) / 175), krampup*0.05		; SOME SMOOTHING OF DENSITY CHANGES VIA THE MOUSE ENHANCES PERFORMANCE RESULTS. MAKE ANY ADJUSTMENTS WITH ADDITIONAL CONSIDERATION OF guirefresh VALUE 
  gkLoopStart2		limit	kMOUSE_X,0,1
  gkLoopEnd2		limit	((kMOUSE_Y^2) * (1-kMOUSE_X)) + kMOUSE_X, 0, 1
  gktranspose	=	((kMOUSE_Y*2)-1)*gktranspose	;, -gktranspose, gktranspose
  schedkwhen	kStartScrub,0,0,2,0,-1
 else
  gkptr		chnget	"ptr"
  gklevel	chnget	"level"
 endif 

endin

instr	99	; load sound file
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 gitableL	ftgen	1,0,0,1,gSfilepath,0,0,1
 giFileSamps	=		nsamp(gitableL)			; derive the file duration in samples
 giFileLen	filelen		gSfilepath			; derive the file duration in seconds
 gkTabLen	init		ftlen(gitableL)			; table length in sample frames
 if gichans==2 then
  gitableR	ftgen	2,0,0,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero
 Smessage sprintfk "file(%s)", gSfilepath			; print file to viewer
 chnset Smessage, "filer1"	

 /* WRITE FILE NAME TO GUI */
 Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
 Smessage sprintfk "text(%s)",Sname
 chnset Smessage, "stringbox"

endin




instr	2	; Sample triggered by 'play/stop' button
 if gkPlayStop==0&&gkMOUSE_DOWN_RIGHT==0 then
  turnoff
 endif

 if giReady = 1 then						; i.e. if a file has been loaded

  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,1				; portamento time function. (Rises quickly from zero to a held value.)
  kspeed	portk	gkspeed,kporttime*gkPortamento			; apply portamento smoothing to changes in speed
  klevel	portk	gklevel,kporttime*0.1			; apply portamento smoothing to changes

  if gkEditMode==1 then						; click and drag edit mode
   gkLoopLen	limit	gkLoopLen,1,giFileSamps			; prevent loop lengths of zero
   
   krate		=	(kspeed * sr) / gkLoopLen
   arate		interp	krate
   
   if gkmode==1 then
    aphasor	phasor	arate
   elseif gkmode==2 then
    aphasor	phasor	-arate
   else
    aphasor	poscil	1,-arate*0.5,gitri
   endif
   rireturn
   
   aLoopStart	interp	gkLoopStart
   aLoopEnd	interp	gkLoopLen
   aphasor	=	(aphasor*aLoopEnd)+aLoopStart
   
   if gichans==1 then						; if mono...
    a1	table3	aphasor, gitableL
 	 outs	a1*aenv*klevel, a1*aenv*klevel			; send mono audio to both outputs 
   elseif gichans==2 then					; otherwise, if stereo...
    a1	table3	aphasor, gitableL
    a2	table3	aphasor, gitableR
 	 outs	a1*aenv*klevel, a2*aenv*klevel			; send stereo signal to outputs
   endif               
  
  elseif gkEditMode==2 then		; sliders edit mode
  
   kLoopStart	portk	gkLoopStart2,kporttime*gkPortamento
   kLoopEnd	portk	gkLoopEnd2,kporttime*gkPortamento
   kLoopEnd	=	(kLoopEnd=kLoopStart?kLoopEnd+0.001:kLoopEnd)
   
   kLoopLen	=	abs(kLoopEnd-kLoopStart)
   kdir		=	(kLoopEnd>kLoopStart?1:-1)
   
   krate		divz	kspeed, kLoopLen*giFileLen, 1
   arate		interp	krate
   aphasor	phasor	arate*kdir
   kLoopStart	min	kLoopStart,kLoopEnd
   aLoopStart	interp	kLoopStart
   aLoopLen	interp	kLoopLen
   aphasor	=	(aphasor*aLoopLen)+aLoopStart
   
   if gichans==1 then						; if mono...
    a1	table3	aphasor, gitableL, 1
 	 outs	a1*aenv*klevel, a1*aenv*klevel			; send mono audio to both outputs 
   elseif gichans==2 then					; otherwise, if stereo...
    a1	table3	aphasor, gitableL, 1
    a2	table3	aphasor, gitableR, 1
 	 outs	a1*aenv*klevel, a2*aenv*klevel			; send stereo signal to outputs
   endif               
   
   
  endif
  
 endif

 ; print scrubber
 if(metro(20)==1) then
  kscrubber	downsamp	aphasor
  Smessage sprintfk "scrubberposition(%d)", kscrubber
  chnset Smessage, "filer1"
 endif

endin




instr	3	; sample triggered by midi note
 icps	cpsmidi							; read in midi note data as cycles per second
 iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
 iMidiRef	chnget	"MidiRef"

 if giReady = 1 then						; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"				; read in widgets
  iRelTim	chnget	"RelTim"
  if iAttTim>0 then						; is amplitude envelope attack time is greater than zero...
   kenv	linsegr	0,iAttTim,1,iRelTim,0				; create an amplitude envelope with an attack, a sustain and a release segment (senses realtime release)
  else
   kenv	linsegr	1,iRelTim,0					; create an amplitude envelope with a sustain and a release segment (senses realtime release)
  endif
  kenv	expcurve	kenv,8					; remap amplitude value with a more natural curve
  aenv	interp		kenv					; interpolate and create a-rate envelope
  kporttime	linseg	0,0.001,0.05				; portamento time function. (Rises quickly from zero to a held value.)
  ispeed	=	icps/cpsmidinn(iMidiRef)		; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)
  klevel	portk	gklevel,kporttime			; apply portamento smoothing to changes in level
    

  if gkEditMode==1 then						; click and drag edit mode

   gkLoopLen	limit	gkLoopLen,1,giFileSamps			; prevent loop lengths of zero
 
   krate		=	ispeed * sr / gkLoopLen
   arate		interp	krate
 
   if gkmode==1 then
    aphasor	phasor	arate
   elseif gkmode==2 then
    aphasor	phasor	-arate
   else
    aphasor	poscil	1,-arate*0.5,gitri
   endif
   
   aLoopStart	interp	gkLoopStart
   aLoopEnd	interp	gkLoopLen
   aphasor	=	(aphasor*aLoopEnd)+aLoopStart
 
   if gichans==1 then						; if mono...
    a1	table3	aphasor, gitableL
  	outs	a1*aenv*klevel*iamp*(1-gkMOUSE_DOWN_LEFT), a1*aenv*klevel*iamp*(1-gkMOUSE_DOWN_LEFT)	; send mono audio to both outputs 
   elseif gichans==2 then					; otherwise, if stereo...
    a1	table3	aphasor, gitableL
    a2	table3	aphasor, gitableR
  	outs	a1*aenv*klevel*iamp*(1-gkMOUSE_DOWN_LEFT), a2*aenv*klevel*iamp*(1-gkMOUSE_DOWN_LEFT)	; send stereo signal to outputs
   endif

  elseif gkEditMode==2 then		; sliders edit mode

   kLoopStart	portk	gkLoopStart2,kporttime
   kLoopEnd	portk	gkLoopEnd2,kporttime
   kLoopEnd	=	(kLoopEnd=kLoopStart?kLoopEnd+0.001:kLoopEnd)
   
   kLoopLen	=	abs(kLoopEnd-kLoopStart)
   kdir		=	(kLoopEnd>kLoopStart?1:-1)
   
   krate		divz	ispeed, kLoopLen*giFileLen, 1
   arate		interp	krate
   aphasor	phasor	arate*kdir
   kLoopStart	min	kLoopStart,kLoopEnd
   aLoopStart	interp	kLoopStart
   aLoopLen	interp	kLoopLen
   aphasor	=	(aphasor*aLoopLen)+aLoopStart
   
   if gichans==1 then						; if mono...
    a1	table3	aphasor, gitableL, 1
 	 outs	a1*aenv*klevel*iamp, a1*aenv*klevel*iamp	; send mono audio to both outputs 
   elseif gichans==2 then					; otherwise, if stereo...
    a1	table3	aphasor, gitableL, 1
    a2	table3	aphasor, gitableR, 1
 	 outs	a1*aenv*klevel*iamp, a2*aenv*klevel*iamp	; send stereo signal to outputs
   endif               




  endif

 endif

 if active(p1)==1 then						; only print scrubber for first note
  if(metro(20)==1) then
   kscrubber	downsamp	aphasor
   Smessage sprintfk "scrubberposition(%d)", kscrubber
   chnset Smessage, "filer1"
  endif
 endif
endin
 
</CsInstruments>  

<CsScore>
i 1 0 [60*60*24*7]
</CsScore>

</CsoundSynthesizer>TemposcalFilePlayer.csd
Written by Iain McCurdy, 2014.

Load a user selected sound file into a GEN 01 function table and plays it back using temposcal.

The sound file can be played back using the Play/Stop button (and the 'Transpose' and 'Speed' buttons to implement pitch abd speed changes independently.
Playing back using the MIDI keyboard will implement pitch changes based on key played.

<Cabbage>
form caption("Temposcal File Player") size(570,340), colour(0,0,0) pluginid("TScl") style("legacy")
image                       bounds(  0,  0,570,340), colour( 30, 70, 70), outlinecolour("White"), shape("sharp"), line(3)

soundfiler bounds(  5,  5,560,175), channel("beg","len"), identchannel("filer1"),  colour(0, 255, 255, 255), fontcolour(160, 160, 160, 255), 
label bounds(6, 4, 560, 14), text(""), align(left), colour(0,0,0,0), fontcolour(200,200,200), identchannel("stringbox")

image    bounds(  0,180,570,160), colour(0,0,0,0), outlinecolour("white"), line(2), shape("sharp"), plant("controls"){
filebutton bounds(  5, 10, 80, 25), text("Open","Open"), fontcolour("white") channel("filename"), shape("ellipse")
checkbox   bounds(  5, 40, 95, 25), channel("PlayStop"), text("Play/Stop"), fontcolour("white")

checkbox   bounds( 95, 43,100, 15), channel("lock"), text("Phase Lock"), colour("red"), fontcolour("white")
checkbox   bounds( 95, 60,100, 15), channel("freeze"), text("Freeze"), colour("LightBlue"), fontcolour("white")

label      bounds(105,  8, 48, 12), text("FFT Size"), fontcolour("white")
combobox   bounds( 95, 20, 70, 20), channel("FFTSize"), items("32768", "16384", "8192", "4096", "2048", "1024", "512", "256", "128", "64", "32", "16", "8", "4"), value(5), fontcolour("white")

rslider    bounds(175,  5, 70, 70), channel("transpose"), range(-48, 48, 0,1,1),            colour( 50, 90, 90)), trackercolour("silver"), text("Transpose"), textcolour("white")
rslider    bounds(240,  5, 70, 70), channel("speed"),     range( -2,  2.00, 1),             colour( 50, 90, 90),  trackercolour("silver"), text("Speed"),     textcolour("white")
rslider    bounds(305,  5, 70, 70), channel("AttTim"),    range(0, 5, 0, 0.5, 0.001),       colour( 50, 90, 90),  trackercolour("silver"), text("Att.Tim"),   textcolour("white")
rslider    bounds(370,  5, 70, 70), channel("RelTim"),    range(0.01, 5, 0.05, 0.5, 0.001), colour( 50, 90, 90),  trackercolour("silver"), text("Rel.Tim"),   textcolour("white")
rslider    bounds(435,  5, 70, 70), channel("MidiRef"),   range(0,127,60, 1, 1),            colour( 50, 90, 90), trackercolour("silver"),  text("MIDI Ref."), textcolour("white")
rslider    bounds(500,  5, 70, 70), channel("level"),     range(  0,  3.00, 1, 0.5),        colour( 50, 90, 90),  trackercolour("silver"), text("Level"),     textcolour("white")

keyboard bounds( 5, 80, 560, 75)
}
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=NULL -M0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

massign	0,3

gichans		init	0		; 
giReady		init	0		; flag to indicate function table readiness

giFFTSizes[]	array	32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4	; an array is used to store FFT window sizes

gSfilepath	init	""

opcode FileNameFromPath,S,S		; Extract a file name (as a string) from a full path (also as a string)
 Ssrc	xin				; Read in the file path string
 icnt	strlen	Ssrc			; Get the length of the file path string
 LOOP:					; Loop back to here when checking for a backslash
 iasc	strchar Ssrc, icnt		; Read ascii value of current letter for checking
 if iasc==92 igoto ESCAPE		; If it is a backslash, escape from loop
 loop_gt	icnt,1,0,LOOP		; Loop back and decrement counter which is also used as an index into the string
 ESCAPE:				; Escape point once the backslash has been found
 Sname	strsub Ssrc, icnt+1, -1		; Create a new string of just the file name
	xout	Sname			; Send it back to the caller instrument
endop

instr	1
gkPlayStop	chnget	"PlayStop"
gkloop		chnget	"loop"
gktranspose	chnget	"transpose"
gklevel		chnget	"level"
gkspeed		chnget	"speed"
gklock		chnget	"lock"
gkfreeze	chnget	"freeze"
gkfreeze	=	1-gkfreeze
gkFFTSize	chnget	"FFTSize"
 gSfilepath	chnget	"filename"
 kNewFileTrg	changed	gSfilepath		; if a new file is loaded generate a trigger
 if kNewFileTrg==1 then				; if a new file has been loaded...
  event	"i",99,0,0				; call instrument to update sample storage function table 
 endif  

ktrig	trigger	gkPlayStop,0.5,0
schedkwhen	ktrig,0,0,2,0,-1
endin

instr	99	; load sound file
 gichans	filenchnls	gSfilepath			; derive the number of channels (mono=1,stereo=2) in the sound file
 gitableL	ftgen	1,0,0,1,gSfilepath,0,0,1
 if gichans==2 then
  gitableR	ftgen	2,0,0,1,gSfilepath,0,0,2
 endif
 giReady 	=	1					; if no string has yet been loaded giReady will be zero
 Smessage sprintfk "file(%s)", gSfilepath			; print sound file to viewer
 chnset Smessage, "filer1"

 /* WRITE FILE NAME TO GUI */
 Sname FileNameFromPath	gSfilepath				; Call UDO to extract file name from the full path
 Smessage sprintfk "text(%s)",Sname
 chnset Smessage, "stringbox"

endin

instr	2
 if gkPlayStop==0 then
  turnoff
 endif
 if giReady = 1 then				; i.e. if a file has been loaded
  iAttTim	chnget	"AttTim"		; read in amplitude envelope attack time widget
  iRelTim	chnget	"RelTim"		; read in amplitude envelope attack time widget
  if iAttTim>0 then				; 
   kenv	linsegr	0,iAttTim,1,iRelTim,0
  else								
   kenv	linsegr	1,iRelTim,0			; attack time is zero so ignore this segment of the envelope (a segment of duration zero is not permitted
  endif
  kenv	expcurve	kenv,8			; remap amplitude value with a more natural curve
  aenv	interp		kenv			; interpolate and create a-rate envelope

  kporttime	linseg	0,0.001,0.05
  ktranspose	portk	gktranspose,kporttime
  
  ktrig	changed		gkFFTSize
  if ktrig==1 then
   reinit RESTART
  endif
  RESTART:
  if gichans=1 then
   a1	temposcal	gkspeed*gkfreeze, gklevel, semitone(ktranspose), gitableL, gklock, giFFTSizes[i(gkFFTSize)-1]
  	outs	a1*aenv,a1*aenv
  elseif gichans=2 then
   a1	temposcal	gkspeed*gkfreeze, gklevel, semitone(ktranspose), gitableL, gklock, giFFTSizes[i(gkFFTSize)-1]
   a2	temposcal	gkspeed*gkfreeze, gklevel, semitone(ktranspose), gitableR, gklock, giFFTSizes[i(gkFFTSize)-1]
  	outs	a1*aenv,a2*aenv
 endif
endif

 ; print scrubber
 kscrubber	phasor	(gkspeed*gkfreeze*sr)/ftlen(gitableL)
 if(metro(20)==1) then
  Smessage sprintfk "scrubberposition(%d)", kscrubber*ftlen(gitableL)
  chnset Smessage, "filer1"
 endif

endin




instr	3	; midi triggered instrument
 if giReady = 1 then						; i.e. if a file has been loaded
  icps	cpsmidi							; read in midi note data as cycles per second
  iamp	ampmidi	1						; read in midi velocity (as a value within the range 0 - 1)
  iMidiRef	chnget	"MidiRef"				; MIDI unison reference note
  iFrqRatio		=	icps/cpsmidinn(iMidiRef)	; derive playback speed from note played in relation to a reference note (MIDI note 60 / middle C)
 
  iAttTim	chnget	"AttTim"		; read in amplitude envelope attack time widget
  iRelTim	chnget	"RelTim"		; read in amplitude envelope attack time widget
  if iAttTim>0 then				; 
   kenv	linsegr	0,iAttTim,1,iRelTim,0
  else								
   kenv	linsegr	1,iRelTim,0			; attack time is zero so ignore this segment of the envelope (a segment of duration zero is not permitted
  endif
  kenv	expcurve	kenv,8			; remap amplitude value with a more natural curve
  aenv	interp		kenv			; interpolate and create a-rate envelope
  
  ktrig	changed		gkFFTSize
  if ktrig==1 then
   reinit RESTART
  endif
  RESTART:
  if gichans=1 then
   a1	temposcal	gkspeed*gkfreeze, gklevel*iamp, iFrqRatio, gitableL, gklock, giFFTSizes[i(gkFFTSize)-1]
  	outs	a1*aenv,a1*aenv
  elseif gichans=2 then
   a1	temposcal	gkspeed*gkfreeze, gklevel*iamp, iFrqRatio, gitableL, gklock, giFFTSizes[i(gkFFTSize)-1]
   a2	temposcal	gkspeed*gkfreeze, gklevel*iamp, iFrqRatio, gitableR, gklock, giFFTSizes[i(gkFFTSize)-1]
  	outs	a1*aenv,a2*aenv
  endif
 endif
endin

</CsInstruments>  

<CsScore>
i 1 0 10000
</CsScore>

</CsoundSynthesizer>
; Bubbles.csd
; Written by Iain McCurdy, 2014

; A simple game that is intended to demonstrate moving Cabbage widgets in this case 'image' and interacting with those moving widgets using the mouse.

; The user bursts rising bubbles by clicking on them (a 'burst' is rewraded with a pizzicato-type sound).
; The higher up the panel a bubble is burst, the higher the note it produces.
; Horizontal position across the panel corresponds to panning location of the sound produced.
; The size of the bubble corresponds to the loudness of the burst sound it produces: The larger the bubble, the louder the sound.
; The number of bubbles in circulation gradually increases from 1 to 10 
  

<Cabbage>
form caption("Bubbles"), scrollbars(0), size(1000, 540), pluginid("Bubl"),colour(170,170,255), guirefresh(32)				; guirefresh might have some bearing on the smoothness of movement of the balloons (traded against CPU efficiency) style("legacy")
label bounds(  0,250,1000, 30), text("Burst the Bubbles..."), align(centre), fontcolour(0,0,0,0), identchannel("instructions")		; Instructions

image bounds(  0,  0,  0, 0), colour(0,0,0), shape("ellipse"), widgetarray("bubble",10)		; The bubbles
image bounds(  0,  0,  0, 0), colour(0,0,0), shape("ellipse"), widgetarray("specular",10)	; Specular highlights

label    bounds(  5,  2, 45, 15), text("Burst:"), align(left), fontcolour(0,0,0,100)					; Burst label
label    bounds( 50,  2, 40, 15), text("0"), align(left), fontcolour(0,0,0,150), identchannel("burstID")			; Burst value
label    bounds( 90,  2, 55, 15), text("Missed:"), align(left), fontcolour(0,0,0,100)					; Missed label
label    bounds(145,  2, 40, 15), text("0"), align(left), fontcolour(0,0,0,150), identchannel("missedID")			; Missed value

label    bounds(  1,530,100, 10), text("Iain McCurdy 2014"), align(left), fontcolour(0,0,0,150)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1
seed	0

gaSendL,gaSendR	init	0				; Global audio send variables used to send audio to the reverb effect.
gisine	ftgen	0,0,131072,10,1
giImp	ftgen	0,0,4097,9,0.5,1,0			; Shape for the impulse.
gipanel_width	=	1000				; Panel width (should correspond with the value given in the Cabbage GUI code)
gipanel_height	=	540				; Panel height (should correspond with the value given in the Cabbage GUI code)
giNBalloons	=	10				; Number of balloons.
giBurstScore	=	0				; Number of bubbles burst
giMissedScore	=	0				; Number of bubbles missed
gkactive	init	0
giPolyLimit	=	3
giWobbleShape	ftgen	0,0,4096,10,1,0.3

;				yellow	violet	red	green	d.blue	l.blue	orange	pink	purple	white	black
giR	ftgen	0,0,-11,-2,	255,	255,	255,	0,	0,	100,	255,	255,	100,	255,	20
giG	ftgen	0,0,-11,-2,	255,	0,	0,	255,	0,	100,	100,	75,	0,	255,	20
giB	ftgen	0,0,-11,-2,	255,	255,	0,	0,	255,	255,	9,	255,	100,	255,	20
giColourIndex	init	0

opcode	Oscil1a,a,iii					; an oscillator that plays a single cycle of an audio waveform at a-rate
 iamp,ifrq,ifn	xin
 aptr	line	0,1/ifrq,1
 asig	tablei	aptr,ifn,1
 aenv	linseg	1,1/ifrq,1,0.001,0
	xout	asig*iamp*aenv
endop

opcode	scale_i,i,iii					; UDO for an i-rate version of the 'scale' opcode
 ival,imax,imin	xin
 ival	=	(ival * (imax-imin)) + imin
	xout	ival
endop


instr	1	; Always on
 ; Attributes change over time. I.e. game gets harder.
 gkSizeMin	linseg	60	,30,	60	,180,	30		; Minimum possible size for a bubble
 gkSizeMax	linseg	250	,30,	250	,180,	150		; Maximum possible size for a bubble
 gkMinTime	linseg	9	,30,	9	,180,	3		; Minimum possible time it might take a bubble to rise to the top of the panel
 gkMaxTime	linseg	16	,30,	16	,180,	4		; Maximum possible time it might take a bubble to rise to the top of the panel

 gkSizeMin	init	60
 gkSizeMax	init	250
 gkMinTime	init	9
 gkMaxTime	init	16

 gkMOUSE_X		chnget	"MOUSE_X"		; Read in mouse X position (in pixels across the panel)
 gkMOUSE_Y		chnget	"MOUSE_Y"		; Read in mouse Y position (in pixels across the panel)
 gkMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"	; Read in mouse left click status

 gkRefreshTrig	metro	ksmps/2				; Rate of GUI refresh
 
 icount	=	1
 LOOP:
  event_i	"i",icount+1,20*(icount-1),rnd(i(gkMaxTime)-i(gkMinTime))+i(gkMinTime)		; Start balloons
 loop_le	icount,1,giNBalloons,LOOP
 
 gkbreeze	rspline	-0.02,0.02,0.2,0.4	; A bit of breeze pushing all bubbles off course simultaneously.
endin

#define	BUBBLE(INSTR'N)
#
instr	$INSTR
 isize_norm	=	rnd(1)^2				; Normalised size for this bubble (i.e. range 0 - 1).
 isize_x	scale_i	isize_norm,i(gkSizeMax),i(gkSizeMin)	; Actual size (in pixels).
 isize_y	=	isize_x					; Vertical size.
 ix		random	gipanel_width*0.1,gipanel_width*0.9	; Starting horizontal position for this bubble.
 ky		line	625,p3,-isize_y-5			; Vertical position for this bubble.
 
 if trigger(ky,-isize_y,1)==1 then		; If bubble reaches the top...
  event	"i",101,0,0				; increment and print to 'missed' counter
 endif 
 
 giColourIndex	wrap	giColourIndex + 1 + int(rnd(4)), 0, 11
 iR		table	giColourIndex,giR			; Colours randomised each time bubble is relaunched.
 iG		table	giColourIndex,giG
 iB		table	giColourIndex,giB
 iAlpha		random	150,225
 kWobFreq	randomi	2,6,0.5,1				; Size wobble
 ksize_x	oscil	0.02,kWobFreq,giWobbleShape,0
 ksize_x	=	(1 + ksize_x) * isize_x
 ksize_y	oscil	0.02,kWobFreq,giWobbleShape,0.5
 ksize_y	=	(1 + ksize_y) * isize_y
 
 krel		release				; Sense note ending (either by bursting or by exiting the panel).
 if krel==1 then
  event	"i",100,0,0.01,p1			; Call instrument that will restart this instrument (after some delay).
 endif

 
 kx$N		init	ix
 iSizeRat$N	=	isize_x / (i(gkSizeMax)-i(gkSizeMin))							; Size ratio (0 = smallest possible, 1 = largest possible)
 kx$N		limit	kx$N + (gkbreeze*(1+(iSizeRat$N*2))), -isize_x*1.1, gipanel_width + (isize_x*0.1)	; Blown by the breeze. Limit the bubbles from leaving the panel completely. Larger bubbles are affected more than small ones.
 
 if gkRefreshTrig==1 then											; If a trigger has been generated...
  Sbubble	sprintfk "bubble_ident%d",$N
  Smessage sprintfk "bounds(%d,%d,%d,%d),colour(%d,%d,%d,%d), outlinethickness(0)", kx$N, ky, ksize_x, ksize_y,iR,iG,iB,int(iAlpha)	; Create a string with updated attributes that will be sent to the widget.
  chnset Smessage, Sbubble												; Send updated attributes to the bubble widget.

  Sspecular	sprintfk "specular_ident%d",$N
  Smessage sprintfk "bounds(%d,%d,%d,%d),colour(255,255,255,%d)", kx$N+(ksize_x*0.6), ky+(ksize_y*0.22), ksize_x*0.2, ksize_y*0.2,40	; Create a string with updated attributes that will be sent to the widget.
  chnset Smessage, Sspecular														; Send updated attributes to the widget.

 endif
 
 ktrig	trigger	gkMOUSE_DOWN_LEFT,0.5,0
 if ktrig==1 then

  kx_centre	=	kx$N + (isize_x*0.5)		; x centre of bubble
  ky_centre	=	ky + (isize_y*0.5)  		; y centre of bubble
  kx_dist	=	abs(gkMOUSE_X - kx_centre)	; x distance from centre of this bubble of mouse click
  ky_dist	=	abs(gkMOUSE_Y - ky_centre)	; y distance from centre of this bubble of mouse click
  kdist		=	(kx_dist^2 + ky_dist^2) ^ 0.5	; apply pythagoras to discern distance of mouse click from the centre of this bubble
  
  if kdist<=(isize_x*0.5) then	; if distance of mouse click is less than or equal to radius of the bubble...
   event	"i",200,0,0.4,(gkMOUSE_X-kx$N)/isize_x, 1-(ky/gipanel_height), isize_norm, kx$N/gipanel_width	; Create a 'burst' sound and send current mouse x and y locations and size (normalised)
   chnset "outlinethickness(1), colour(0,0,0,0),outlinecolour(240,240,240)", Sbubble						; Send updated attributes to the widget, i.e. 'burst' bubble.
    chnset "bounds(0,0,0,0)", Sspecular										; Send updated attributes to the widget, i.e.render specular highligh invisiblee.
   ;chnset "bounds(0,0,0,0)", Sbubble										; Send updated attributes to the widget, i.e. 'burst' bubble.
   turnoff
  endif
 endif 
endin
#

;Expand macro for the number of bubbles required
;        INSTR COUNTER
$BUBBLE(2'1)
$BUBBLE(3'2)
$BUBBLE(4'3)
$BUBBLE(5'4)
$BUBBLE(6'5)
$BUBBLE(7'6)
$BUBBLE(8'7)
$BUBBLE(9'8)
$BUBBLE(10'9)
$BUBBLE(11'10)


instr	100	; Trigger the start of a new bubble
  p3	=	0.1
  event_i "i",p4,p3,rnd(i(gkMaxTime)-i(gkMinTime))+i(gkMinTime)
endin

instr	101	; Missed bubble
 ; Update score
 giMissedScore	+=	1
 S1	sprintf	"text(%d)",giMissedScore
 chnset	S1,"missedID"
endin

instr	200	; Burst sound
 /* POLYPHONY CONTROL */
 gkactive init i(gkactive) + 1	;INCREMENT NOTE COUNTER
 if gkactive>giPolyLimit then		;IF POLYPHONY IS EXCEEDED (THROUGH THE ADDITION OF NEW NOTE)
  turnoff				;REMOVE THIS NOTE
 endif
 krel release				;IF NOTE HELD = 0, IF NOTE RELEASED = 1
 ktrig trigger krel,0.5,0		;WHEN RELEASE FLAG CROSSES 0.5 UPWARDS, I.E. NOTE HAS BEEN RELEASED...	
 if ktrig==1 then		
  gkactive = gkactive - 1		;...DECREMENT ACTIVE NOTES COUNTER
 endif

 ; Update score
 giBurstScore	+=	1
 S1	sprintf	"text(%d)",giBurstScore
 chnset	S1,"burstID"


 iX_Burst_Loc	=	p4	; Where within the width of the bubble it was burst. Normalised 0 - 1. (not currently used for anything).
 iY		=	p5	; Where within the height of the panel the bubble was burst.  Normalised 0 - 1.
 iSize		=	p6	; Bubble size (normalised 0 - 1).
 iX		=	p7	; Location across the panel this bubble was travelling in (normalised 0 - 1).
 
 icps	=	cpsmidinn(int(iY*72)+12)

 ; Impulse signal
 iAmpVel	=	(((iSize)*0.5)+0.5)^3
 ifrq	limit	icps,200,600							; Freq. of impulse
 aImpls	Oscil1a	iAmpVel*2,ifrq,giImp						; Single cycle half sine impulse (UDO)
 aImpls	buthp	aImpls,300							; Remove some low freq. energy

 ; Waveguide impulse processer
 aWg1	wguide1	aImpls,icps, icps*4, 0.999995					; Pizz note
 aWg2	wguide1	aImpls,icps*cent(rnd(50)), limit(icps*4,20,3000), 0.999995	; Pizz note unison detuned
 aWg3	wguide1	aImpls,icps*2, limit(icps*8,20,3000), 0.999995			; Pizz note up an octave
 aWg4	wguide1	aImpls,icps*2*cent(rnd(50)), limit(icps*8,20,3000), 0.999995	; Pizz note up an octave detuned
 aWg2	delay	aWg2,rnd(0.02)+0.0001						; 2nd note delayed
 aWg3	delay	aWg3,rnd(0.05)+0.0001						; 3rd note delayed
 aWg4	delay	aWg4,rnd(0.05)+0.0001						; 4th note delayed
 aMix	sum	aWg1, aWg2, aWg3, aWg4						; Mix all 4 notes
 aEnv	linsegr	1,p3,0,0.05,0
 aMix	=	aMix*aEnv
 aL,aR	pan2	aMix,iX								; Create panned stereo signal, location based on x-location of balloon
	outs	aL,aR
	
 gaSendL	=	gaSendL + (aL*0.3)	; Send some to the reverb instrument
 gaSendR	=	gaSendR + (aR*0.3)
endin





instr	1000	; Reverb
 aL,aR	reverbsc	gaSendL,gaSendR,0.9,5000
 	outs		aL,aR
 	clear		gaSendL,gaSendR
endin





instr	2000	; Print initial text instructions then fading away.
 kAlpha	transeg	0,0.75,4,255, p3-1.5,0,255, 0.75,-4,-1 ; Colour alpha decreases as event progresses, i.e. transparency increases

 ktrig	metro	ksmps*0.5					; Create a metronome which will define the rate of graphical update of the text
 
 if ktrig==1 then						; If a trigger has been generated...
   Smess1 sprintfk "fontcolour(0,0,50,%d)",kAlpha		; Create a string with updated attributes that will be sent to the instructions widget.
   chnset Smess1, "instructions"														; Send updated attributes to the widget.
 endif

 event_i	"i",1,p3-2,3600					; Start bubbles once instructions have vanished.
endin

</CsInstruments>

<CsScore>
i 1000 0 [3600*24*7]	; Reverb
i 2000 0 3		; Instructions fade up then down (currently not working)
</CsScore>

</CsoundSynthesizer>
; Electricity.csd
; Written by Iain McCurdy, 2015

; click and drag to generate sparks

; This example makes use of Cabbage's ability to rotate widgets and to make them visible and invisible
; to create the sparking effect.
; It also demonstrates how rate-of-change of mouse position (position delta) is used as a control input (spark density).
; The tonal variation of the sparks is implemented using 2 comb filters,
;   the loop times of which are linked to the mouse x and y positions.

<Cabbage>
form size(1000,540), text("Electricity"), guirefresh(32), colour(0,0,0), pluginid("Elec")
image bound(0,0,0,0), shape("sharp"), visible(0), widgetarray("spark",10)	; widget array (10 image widgets with a single line of code)
label bounds(0,530,100,10), text("Iain McCurdy |2015|")
label bounds(  0,230,1000,70), text("Click and Drag..."), fontcolour(255,255,255), identchannel("instructions")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
seed 0

giPanelWidth	=	1000	; panel width in pixel (declared here to be used later in the code)
giPanelHeight	=	540 	; panel height in pixel (declared here to be used later in the code)

; i-rate version of scale opcode
opcode	scale_i,i,iii
 ival,imax,imin	xin
 ival	=	(ival * (imax-imin)) + imin
	xout	ival
endop

opcode TriggerToGatek,k,kki
 ktrig,kdur,imax xin
 kdlytrig  vdelayk	ktrig,kdur,imax
 kgate	   samphold	ktrig,ktrig + kdlytrig
           xout         kgate
endop

instr 1
 gkMOUSE_X		chnget	"MOUSE_X"		; read in mouse x position in pixels
 gkMOUSE_Y		chnget	"MOUSE_Y"       	; read in mouse y position in pixels
 kx_ratio	=	gkMOUSE_X/giPanelWidth		; mouse x position as a ratio of the entire panel (0-1)
 ky_ratio	=	gkMOUSE_Y/giPanelHeight		; mouse y position as a ratio of the entire panel (0-1)
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"	; mouse left click status (0 or 1)
 if trigger(kMOUSE_DOWN_LEFT,0.5,0)==1 then		; if mouse button is pressed...
  koldx	random	gkMOUSE_X-10,gkMOUSE_X+10		; reset 'previous' x position value
  koldy	random	gkMOUSE_Y-10,gkMOUSE_Y+10		; reset 'previous' y position value
 endif
 if kMOUSE_DOWN_LEFT==1 then				; if mouse left button is held...
  koldx,koldy	init	0				; previous mouse positions initialised
  kdeltax	=	abs(gkMOUSE_X-koldx)		; mouse x position change (in pixels)
  kdeltay	=	abs(gkMOUSE_Y-koldy)		; mouse y position change (in pixels)
  kdelta	=	kdeltax + kdeltay		; sum of mouse position changes
  koldx		=	gkMOUSE_X			; set 'previous' mouse positions for next iteration
  koldy		=	gkMOUSE_Y
  kdens		init	300
  ktrig	metro	kdens * kdelta				; generate a trigger
  if ktrig==1 then
   kdens	=	exprand:k(300) + 50
  endif
  schedkwhen	ktrig,0,0,2,0,0.01,kx_ratio,ky_ratio	; spark sound
  schedkwhen	ktrig,0,0,11,        0,0,1,kdelta	; visual sparks...
  schedkwhen	ktrig,0,0,11,rnd(0.01)*3,0,2,kdelta
  schedkwhen	ktrig,0,0,11,rnd(0.02)*3,0,3,kdelta
  if kdelta<1 kgoto SKIP
  schedkwhen	ktrig,0,0,11,rnd(0.03)*3,0,4,kdelta
  schedkwhen	ktrig,0,0,11,rnd(0.04)*3,0,5,kdelta
  if kdelta<5 kgoto SKIP
  schedkwhen	ktrig,0,0,11,rnd(0.05)*3,0,6,kdelta
  schedkwhen	ktrig,0,0,11,rnd(0.06)*3,0,7,kdelta
  if kdelta<10 kgoto SKIP
  schedkwhen	ktrig,0,0,11,rnd(0.07)*3,0,8,kdelta
  schedkwhen	ktrig,0,0,11,rnd(0.08)*3,0,9,kdelta
  schedkwhen	ktrig,0,0,11,rnd(0.09)*3,0,10,kdelta
  SKIP:
 endif

 ; 50 Hz mains hum
 aamp	interp	(1-(ktrig*0.5)) * (0.005 + (kMOUSE_DOWN_LEFT*0.03))	; amplitude derives from mouse down position and inversely to trigger impulses
 kpw	rspline	0.89-(ky_ratio*0.88),0.99-(ky_ratio*0.98),0.2,0.4	; slight pulse width shift
 kjit	rspline	-10,10,1,5					; frequency jitter
 asq	vco2	1, 50*cent(kjit), 4, kpw, 0, 0.125		; square wave
 asq	*=	aamp						; scale amplitude
 kpan	rspline	kx_ratio*0.5,0.5+(kx_ratio*0.5),0.5,5		; panning function
 aL1,aR1	pan2	asq,kpan				; create stereo output
 ; a second hum signal
 kpw	rspline	0.89-(ky_ratio*0.88),0.99-(ky_ratio*0.98),0.2,0.4	; slight pulse width shift
 kjit	rspline	-10,10,1,5					; frequency jitter
 asq	vco2	1, 50*cent(kjit), 4, kpw, 0, 0.125		; square wave
 asq	*=	aamp                                        	; scale amplitude
 kpan	rspline	kx_ratio*0.5,0.5+(kx_ratio*0.5),0.5,5      	; panning function
 aL2,aR2	pan2	asq,kpan                    		; create stereo output

 	outs	aL1+aL2, aR1+aR2				; mix hum signals and send to output

endin

gasendL,gasendR	init	0					; reverb send variables

instr	2
 iamp	exprand	1						; random amplitude
 asig	mpulse	iamp,0						; a click impulse
 asig	buthp	asig,500					; highpass filter it
 icfoct	random	9,14						; random freq (oct format)
 asig	wguide1	asig,cpsoct(icfoct),sr/4,0.5			; send click through a waveguide filter
 iDT1	scale_i	p4,0.00001,0.005				; delay time for a comb filter derived from mouse x position
 a1	comb	asig,0.01,iDT1					; comb filter (1)
 iDT2	scale_i	p5,0.00001,0.005				; delay time for a comb filter derived from mouse y position
 a2	comb	asig,0.005,iDT2					; comb filter (2)
 asig	sum	a1,a2						; mix the two comb filter outputs
 aL,aR	pan2	asig,rnd(1)					; random pan click
 	outs	aL,aR						; send stereo audio to outputs
 gasendL	+=	aL/(2+rnd(3))				; send some audio to the reverb send channels
 gasendR	+=	aR/(2+rnd(3))
endin

instr	11 ; show spark and move and set colour
 Sident	sprintf	"spark_ident%d",p4			; define indent channel string
 irad	random	0, 2 * $M_PI				; random rotation value (range: 0 to 2*pi)
 ilen	unirand	p5/30					; random length (0-1)
 irnd	random	4,20
 ilen	=	(ilen * 250) + irnd			; random length (in pixels)
 icol	linrand	100					; colour intensity value
 ialpha	random	100,255
 ; create string with changes
 Smsg	sprintf	"bounds(%d,%d,%d,%d), rotate(%f,0,0), colour(255,255,%d,%d), visible(1)",i(gkMOUSE_X),i(gkMOUSE_Y),ilen,rnd(2)+1,irad,255-icol,ialpha
 	chnset	Smsg,Sident				; send string to widget
 event_i "i",12,0.04,0,p4				; call instrument to 'hide' spark after a short delay
endin

instr	12 ; hide spark
 Sident	sprintf	"spark_ident%d",p4			; define indent channel string
 chnset	"visible(0)",Sident				; send string to widget
endin

instr	99	; reverb
 aL,aR	reverbsc	gasendL,gasendR,0.7,7000
 	outs		aL,aR
 	clear		gasendL,gasendR
endin

instr	1000	; flash instructions
 ktrig	init	1			; trigger intially '1' in order to create the first random 'rate' value
 krate	trandom	ktrig,1,10		; metronome rate values: a new random value upon each metronome beat
 ktrig	metro	krate			; create a metronome
 kdur	trandom	ktrig,0.03,0.2		; a new 'flash' duration upon each new beat
 kvis	TriggerToGatek	ktrig, kdur,0.2	; extend the trigger to a pulse of 'kdur' duration (using a UDO - see instr 0 above)
 kcol	randomi	0,255,2,1		; colour opacity changing continuously and randomly
 if changed(kvis)==1 then		; if flash changing from on to off or vice versa
  Smsg	sprintfk	"visible(%d), fontcolour(255,255,255,%d)",kvis,kcol	; create string
  	chnset	Smsg,"instructions"	; send string to widget
 endif

 ; 50 Hz mains hum
 khum	TriggerToGatek	ktrig, kdur, 0.2
 aamp	interp	khum*0.4					; amplitude derives from mouse down position and inversely to trigger impulses
 kpw	rspline	0.01,0.04,2,6					; slight pulse width shift
 kjit	rspline	-10,10,.1,.5					; frequency jitter
 asq	vco2	1, 50*cent(kjit), 4, kpw, 0			; square wave
 asq	*=	aamp						; scale amplitude
 asq	atone	asq,2000
 kpan	rspline	0.3,0.7,1,5					; panning function
 aL1,aR1	pan2	asq,kpan				; create stereo output
 ; a second hum signal
 kpw	rspline	0.01,0.1,0.2,0.6				; slight pulse width shift
 kjit	rspline	-10,10,.1,.5					; frequency jitter
 asq	vco2	1, 50*cent(kjit), 4, kpw, 0			; square wave
 asq	*=	aamp                                        	; scale amplitude
 asq	atone	asq,2000
 kpan	rspline	0.3,0.7,1,5					; panning function
 aL2,aR2	pan2	asq,kpan                    		; create stereo output

 	outs	aL1+aL2, aR1+aR2				; mix hum signals and send to output

 ; turn off this instrument and hide instructions when the mouse is first left-clicked.
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"		; sense mouse left click
 if kMOUSE_DOWN_LEFT==1 then					; if left clicked...
  chnset	"visible(0)","instructions"			; ...hide instructions
  event	"i",1,0,3600						; start the 'sparks and hum' instrument
  turnoff							; turn off this instrument
 endif
endin

</CsInstruments>

<CsScore>
;i 99 0 [3600*24*7]	; reverb
i 1000 0 [3600*24*7]	; instructions
</CsScore>

</CsoundSynthesizer>
; PebblesInAPond .csd
; Written by Iain McCurdy, 2014

; This instrument is a demonstration of Cabbage's ability to modify its widgets' appearance in realtime from within the Csound orchestra. 
; Five circles are drawn at start-up but are initially invisible.
; Upon clicking within the panel this will trigger a circle to become visble and to expand from the point where clicking occured until it again becomes invisible.
; In synchrony with this, a 'plip' sound is produced to continue to imitation of dropping pebbles into a pond.
; Various aspects of the 'plip' sound are dependent upon where within the panel the click that triggered it occured.
; Colours for the circles are simply chosen randomly.
; The reason 5 circles created, and triggering cycles through these, is to allow circles to overlap. It is assumed that the user won't trigger more that five at once.

<Cabbage>
form caption("Pebbles in a Pond"), scrollbars(0), size(900, 520), pluginid("Pond"),colour(0,10,20), guirefresh(64) style("legacy")
image bounds(0,0,0,0), colour(0,0,0), widgetarray("circle",70), shape("ellipse"), outlinecolour("white"), line(0)
label    bounds(  0, 0,0, 0), text("Drop a pebble into the pond..."), align(centre), fontcolour(0,0,0,0), identchannel("instructions")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		=  	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE (higher values will cause quantisation noise in the mode filter)
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1

gisine	ftgen	0,0,131072,10,1
giPanelSizeX	=	900		; Should correspond to the size of the Cabbage panel
giPanelSizeY	=	520		; Should correspond to the size of the Cabbage panel
giCircleNdx	init	1		; Starting value for circle index counter. This mechanism allows multiple circles to overlap.
gaSendL,gaSendR	init	0		; Global audio send variables used to send audio to the reverb effect.
giSizeInit	=	5		; Initial circle diameter (in pixels)
giSizeFinal	=	1000		; Final circle diameter (in pixels)
giCurve		=	2


opcode	scale_i,i,iii				; UDO for an i-rate version of the 'scale' opcode
 ival,imax,imin	xin
 ival	=	(ival * (imax-imin)) + imin
	xout	ival
endop

instr	1	; Sense mouse activity and trigger note events for instr 2
 kMOUSE_X		chnget	"MOUSE_X"		; Read in mouse X position (in pixels across the panel)
 kMOUSE_Y		chnget	"MOUSE_Y"		; Read in mouse Y position (in pixels across the panel)
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"	; Read in mouse left click status
 
 kOffTrig	trigger	kMOUSE_DOWN_LEFT,0.5,0		; Generate a trigger whenever mouse button is clicked (on the way down)
 schedkwhen	kOffTrig,0,0,2,0,4,kMOUSE_X,kMOUSE_Y	; Trigger a note event when mouse is clicked. Send mouse position X/Y as p4 and p5.
endin



instr	2	; Draw an expanding circle and create a 'plip' sound 
 ; Named variables for X and Y position (in pixels) derived from p4 and p5
 iHorPosInit	init	p4
 iVertPosInit	init	p5

 ; Normalised x/y position (range 0 - 1)
 iXNorm	limit	iHorPosInit/giPanelSizeX, 0.001,1
 iYNorm	limit	iVertPosInit/giPanelSizeY, 0.001,1
 
 ; Draw an expanding and fading circle 
 kSize		transeg	giSizeInit,p3-0.1,giCurve,giSizeFinal, 0.1, giCurve, 1, 1,giCurve,1		; Circle diameter increasing as time progress
 kHorPos	transeg	iHorPosInit-(giSizeInit/2),p3,giCurve,iHorPosInit-(giSizeFinal/2)	; Horizontal position needs to compensate for the expanding circle so that the circle center remains fixed.
 kVertPos	transeg	iVertPosInit-(giSizeInit/2),p3,giCurve,iVertPosInit-(giSizeFinal/2)	; Vertical position needs to compensate for the expanding circle so that the circle center remains fixed.
 
 iRed		random	100,255				; Colours are set randomly once per event
 iGreen		random	100,255				; Colours are set randomly once per event
 iBlue		random	100,255				; Colours are set randomly once per event
 kAlpha		transeg	255,0.4,0,100 ,p3-0.5,-6, 0,1,0,0	; Colour alpha decreases as event progresses, i.e. transparency increases
 
 gkRefreshTrig	metro	ksmps				; Create a metronome which will define the rate of graphical update of the expanding circles
 
 if gkRefreshTrig==1 then															; If a trigger has been generated...  
  SCircle	sprintf		"circle_ident%d",giCircleNdx
   Smessage 	sprintfk 	"bounds(%d,%d,%d,%d),colour(%d,%d,%d,%d)", kHorPos, kVertPos, kSize, kSize, iRed, iGreen, iBlue, kAlpha	; Create a string with updated attributes that will be sent to the circle widget.
   chnset	Smessage,SCircle                                         
 endif 

 ; Ripples echoes (comment out event_i's to alleviate performance issues)
 idel	=	0.35	; time gap between ripple echoes
 event_i "i",3,idel,   4-0.3  , p4, p5, iRed, iGreen, iBlue, giCircleNdx+10, idel  , 55
 event_i "i",3,idel*2, 4-0.3*2, p4, p5, iRed, iGreen, iBlue, giCircleNdx+20, idel*2, 44
 event_i "i",3,idel*3, 4-0.3*3, p4, p5, iRed, iGreen, iBlue, giCircleNdx+30, idel*3, 33
 event_i "i",3,idel*4, 4-0.3*4, p4, p5, iRed, iGreen, iBlue, giCircleNdx+40, idel*4, 22
 event_i "i",3,idel*5, 4-0.3*5, p4, p5, iRed, iGreen, iBlue, giCircleNdx+50, idel*5, 11
 event_i "i",3,idel*6, 4-0.3*6, p4, p5, iRed, iGreen, iBlue, giCircleNdx+60, idel*6,  1
 
 giCircleNdx	wrap	giCircleNdx+1,1,11	; Increment circle index counter for next circle. Wrap around whenever last circle in the cycle is reached. This facilitates multiple circles to be drawn.

 ; Produce a sound
 idur		scale_i	iYNorm,2,0.2		; 'Plip' duration varies according to mouse X position.
 iStartOct	scale_i	(iXNorm+(1-iYNorm))*0.5,11,5.5
 iStartCPS	=	cpsoct(iStartOct)
 iEndOct	scale_i	1-iYNorm,13.8,9.6
 iEndCPS	=	cpsoct(iEndOct)
 iCPSCurve	=	5			; Shape of CPS envelope. Higher values will delay its curve upwards.
 kCPS	transeg	iStartCPS,idur,iCPSCurve,iEndCPS,1,0,iEndCPS	; CPS curve used by the mode filter
 aEnv	transeg	1,idur,-6,0,1,0,0		; Amplitude envelope. Used by both the impulse noise and the filtered output. 
 aNse	pinkish	aEnv*0.05			; Some pink noise.
 aNse	buthp	aNse,250			; Highpass filter the noise to remove some of the rumble.
 aImp	mpulse	1,0				; A Click impulse. Used to augment the attack of the sound.
 aNse	=	aNse+aImp			; Mix the pink noise and the click.
 kCPS	limit	kCPS, 20, sr/$M_PI
 aDrop	mode	aNse,kCPS,kCPS/3			; Mode filter the noise and click mixture. Note that Q (p3) will increase as CPS increases - higher frequencies will ring for longer.
 aDrop	=	aDrop * aEnv			; Apply envelope to mode filtered signal.
 aL,aR	pan2	aDrop,iXNorm			; Create stereo panned version of 'plip'
 aL	delay	aL,iXNorm  *0.01		; Some Haas effect delay 
 aR	delay	aR,(1-iXNorm)*0.01		; Some Haas effect delay
 	outs	aL,aR				; Send dry 'plip' signal to speakers.
 gaSendL	=	gaSendL + aL*0.15	; Send some to the reverb instrument
 gaSendR	=	gaSendR + aR*0.15	; "    "    "  "   "      "
endin

instr	3 ; Echo ripple
 ; Named variables for X and Y position (in pixels) derived from p4 and p5
 iHorPosInit	init	p4
 iVertPosInit	init	p5
 iDel		init	p10
 
 ; Normalised x/y position (range 0 - 1)
 iXNorm	=	iHorPosInit/giPanelSizeX
 iYNorm	=	iVertPosInit/giPanelSizeY
 
 ; Draw an expanding and fading circle 
 kSize		transeg	giSizeInit,p3-0.1,giCurve,giSizeFinal, 0.1, giCurve, 1, 1,giCurve,1		; Circle diameter increasing as time progress
 kHorPos	transeg	iHorPosInit-(giSizeInit/2),p3,giCurve,iHorPosInit-(giSizeFinal/2)		; Horizontal position needs to compensate for the expanding circle so that the circle center remains fixed.
 kVertPos	transeg	iVertPosInit-(giSizeInit/2),p3,giCurve,iVertPosInit-(giSizeFinal/2)	; Vertical position needs to compensate for the expanding circle so that the circle center remains fixed.
 
 iRed		=	p6
 iGreen		=	p7
 iBlue		=	p8
 iAlpha		=	p11
 kAlpha	transeg	iAlpha,0.4,0,iAlpha*(100/255) ,p3-0.5,-3, 0,1,0,0	; Colour alpha decreases as event progresses, i.e. transparency increases
 
 iCircleNdx	=	p9

 if gkRefreshTrig==1 then															; If a trigger has been generated...  
  SCircle	sprintf		"circle_ident%d",iCircleNdx+1
   Smessage 	sprintfk 	"bounds(%d,%d,%d,%d),colour(%d,%d,%d,%d)", kHorPos, kVertPos, kSize, kSize, iRed, iGreen, iBlue, kAlpha	; Create a string with updated attributes that will be sent to the circle widget.
   chnset	Smessage,SCircle                                         
 endif 


endin


instr	99	; Delay-Reverb
 aL		delayr		0.7
 aR		delayr		0.973
		delayw		gaSendL*0.8 + aL*0.35 + aR*0.35
		delayw		gaSendR*0.8 + aR*0.35 + aL*0.35
 aL,aR	reverbsc	gaSendL+aL,gaSendR+aR,0.8,3000
 		outs		aL, aR			; Send delay signal to outputs
 		clear		gaSendL, gaSendR	; Clear global audio send variables
endin


instr	1000	; Print initial text instructions, expanding and disappearing.
 iSizeInit	=	14			; Initial size (in pixels)
 iSizeFinal	=	60			; Final size (in pixels)
 kSize		linseg	iSizeInit,p3-0.001,iSizeFinal,0.001,0	; Text Size increasing as time progresses
  
 kAlpha		transeg	0,0.1,4,255,p3-0.1,-4,0,1,0,0		; Colour alpha decreases as event progresses, i.e. transparency increases
 
 ktrig	metro	ksmps				; Create a metronome which will define the rate of graphical update of the text
 
 if ktrig==1 then				; If a trigger has been generated...
  reinit UPDATE
  UPDATE:
  Smessage sprintfk "bounds(-200, 245,%d, %d),fontcolour(255,255,255,%d)", giPanelSizeX+400, i(kSize), i(kAlpha)	; Create a string with updated attributes that will be sent to the instructions widget.
  rireturn
  chnset Smessage, "instructions"														; Send updated attributes to the widget.
 endif

endin
	
</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]	; Instrument to sense mouse activity
i 99 0 [3600*24*7]	; Reverb instrument
i 1000 0 5		; Instructions
</CsScore>


</CsoundSynthesizer>



























; PingClang.csd
; Written by Iain McCurdy, 2014
;
; A musical toy.
;
; Blocks can be moved using left click and drag, and can be resized using right click and drag.
;
; The nature of the sound produced by the blocks is altered by their shape.
; Thin blocks will produce a more harmonic and sustaining sound. Thick blocks will produce inharmonic and less sustained sounds.
;
; Once balls come to rest on the floor they are rethrown from the top.
; New balls can also be launched using the 'New Ball' button.
;
; CONTROLS
; --------
; Damping		-	damping of energy that occurs when the ball hits a surface. e.g. low values = rubber ball, high values = cannon ball
; Friction	-	damping of horizonatal movement that occurs when the ball strikes the floor. e.g. low values = hard surface, high values = thick carpet
; Speed		-	speed of the game
; Size		-	size of the ball. Also has a bearing on the sound produced when the ball rebounds off the walls or the floor.
; Angle		-	range of possible angles (in both directions) in which the ball can be thrown. i.e. when zero, all throws will be straight down.
; Resonance	-	resonating time of the blocks when struck. This will also be affected by the shape of the blocks. Thinner blocks resonate for a longer time.
; Blocks		-	number of blocks used in the game
; Notch		-	turns on a notch filter operating at the fundemental frequency of the 'clang' sounds

<Cabbage>
form caption("Ping Clang") size(610,500), guirefresh(32), pluginid("PinC") style("legacy")
image              bounds(0,  0,610,500), shape("sharp"), colour("black") ;background
image              bounds(0,465,610,35), shape("sharp"), colour(100,100,100) 		; floor
image bounds( 0, 0, 0,0), shape("sharp"), colour(255,255, 50), identchannel("block1")	; blocks: yellow
image bounds( 0, 0, 0,0), shape("sharp"), colour( 75,255, 75), identchannel("block2")	; green
image bounds( 0, 0, 0,0), shape("sharp"), colour( 65, 65,255), identchannel("block3")	; blue
image bounds( 0, 0, 0,0), shape("sharp"), colour(255, 15, 15), identchannel("block4")	; red
image bounds( 0, 0, 0,0), shape("sharp"), colour(255,100, 50), identchannel("block5")	; orange
image bounds( 0, 0, 0,0), shape("sharp"), colour(155, 50,255), identchannel("block6")	; purple
image bounds( 0, 0, 0,0), shape("sharp"), colour(  0,230,255), identchannel("block7")	; turquoise
image bounds( 0, 0, 0,0), shape("sharp"), colour(255,  0,255), identchannel("block8")	; pink
image bounds( 0, 0, 0,0), shape("sharp"), colour(155,155,155), identchannel("block9")	; grey

image bounds(0,0,0,0), shape("ellipse"), colour(255,230,220), identchannel("ball")	; ball

nslider  bounds( 20,465,60,34), channel("damping"),    range(0.00, 0.999, 0.1,1,0.001),     textcolour(white),         text("Damping"),   colour(0,0,0)
nslider  bounds( 90,465,60,34), channel("friction"),   range(0.001, 0.999, 0.03,1,0.001),   textcolour(white),         text("Friction"),  colour(0,0,0)
nslider  bounds(160,465,50,34), channel("speed"),      range(0.01,  20, 1,1,0.01),          textcolour(white),         text("Speed"),     colour(0,0,0)
nslider  bounds(220,465,40,34), channel("size"),       range(2, 80, 15,1,1),                textcolour(white),         text("Size"),      colour(0,0,0)
nslider  bounds(270,465,50,34), channel("angle"),      range(0, 5, 3,1,0.001),              textcolour(white),         text("Angle"),     colour(0,0,0)
nslider  bounds(330,465,70,34), channel("resonance"),  range(0.1, 30, 2,1,0.1),             textcolour(white),         text("Resonance"), colour(0,0,0)
;nslider  bounds(410,415,40,34), channel("NBlocks"),    range(0, 7, 5,1,1),                 textcolour(white),         text("Blocks"),    colour(0,0,0)
button     bounds(460,473,60,21), text("Notch","Notch"), channel("fundemental"), value(0),    fontcolour:0( 50, 50, 50), fontcolour:1(white)
button     bounds(530,473,60,21), text("New Ball"), channel("NewBall"), value(0), latched(0), fontcolour:0(200,200,200), fontcolour:1(white)

label      bounds(410,466,45,14), text("Blocks"), align(centre), fontcolour(white)
button     bounds(410,483,15,14), text("<"), channel("NBlocksDn"), value(0), latched(0)
button     bounds(440,483,15,14), text(">"), channel("NBlocksUp"), value(0), latched(0)
label      bounds(425,483,15,14), text("5"), align(centre), colour(black), fontcolour(white), identchannel("NBlocksID")

label    bounds(  0, 0,  0, 0), text("Use left click and drag to move blocks."), align(centre), fontcolour(white), identchannel("instructions1")		; Instructions
label    bounds(  0, 0,  0, 0), text("Right click and drag to resize blocks."), align(centre), fontcolour(white), identchannel("instructions2")		; Instructions

label    bounds(  1,454,100, 10), text("Iain McCurdy 2014"), align(left), fontcolour(255,255,255,100)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 16
nchnls = 2
0dbfs=1
seed	0

giNumBlocks		=	9
giPanelWidth	=	610
giPanelHeight	=	500
giFloorDepth	=	35
gisine	ftgen	0,0,131072,10,1
gal,gar	init	0
gkactive0,gkactive1,gkactive2,gkactive3,gkactive4,gkactive5,gkactive6,gkactive7,gkactive8,gkactive9	init	0	; used for polyphony control. Add further variables if additional blocks are needed. NB each block has its own polyphony control mechanism.
giGravAccel	=	2*ksmps						; Acceleration due to gravity
giStopThreshold	=	1.2						; Speed threshold below which the current ball will be removed and a new ball will be thrown. Values from 1 to 5 are appropriate. Higher values for ball to be thrown quicker.
giWallFloorAmp	=	0.2						; Amplitude of bounce sound effects off the walls and floor

instr	1	; Track mouse position and clicks and move objects as appropriate
 kMOUSE_X		chnget	"MOUSE_X"
 kMOUSE_Y		chnget	"MOUSE_Y"
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"
 kMOUSE_DOWN_MIDDLE	chnget	"MOUSE_DOWN_MIDDLE"
 kMOUSE_DOWN_RIGHT	chnget	"MOUSE_DOWN_RIGHT"
 kprevX	init	i(kMOUSE_X)	; Mouse position from previous k-pass
 kprevY	init	i(kMOUSE_Y)

 gkNBlocks	init	5				; number of blocks counter
 kNBlocksDn	chnget	"NBlocksDn"			; read in widgets
 kNBlocksUp	chnget	"NBlocksUp"			;
 if trigger(kNBlocksDn,0.5,0)==1 then			; if 'down' button is triggered...
  gkNBlocks	limit	gkNBlocks-1,0,giNumBlocks			; increment counter up one step (within limits)
  Smess		sprintfk	"text(%d)",gkNBlocks	; create message to change value indicator (a text label)
  chnset	Smess,"NBlocksID"			; send message to widget
 elseif trigger(kNBlocksUp,0.5,0)==1 then		; do the same for  the 'up' counter button
  gkNBlocks	limit	gkNBlocks+1,0,giNumBlocks
  Smess		sprintfk	"text(%d)",gkNBlocks
  chnset	Smess,"NBlocksID"
 endif

 gkdamping	chnget	"damping"
 gkfriction	chnget	"friction"
 gkspeed	chnget	"speed"
 gksize		chnget	"size"
 gkangle	chnget	"angle"
 gkresonance	chnget	"resonance"
 ;gkNBlocks	chnget	"NBlocks"
 gkfundemental	chnget	"fundemental"
 gkNewBall	chnget	"NewBall"

 ktrig	metro	kr/(ksmps)
 if ktrig==1 then

 kMOUSE_DOWN_LEFT_trig	trigger	kMOUSE_DOWN_LEFT,0.5,0
 kMOUSE_DOWN_RIGHT_trig	trigger	kMOUSE_DOWN_RIGHT,0.5,0

 gkDeltaX	=	kMOUSE_X - kprevX	; Change in mouse x position
 gkDeltaY	=	kMOUSE_Y - kprevY	; Change in mouse y position

#define BLOCK(N)
 #
 kcount		=	$N
 gkSizeX$N	init	random(1,170)						; Initial x-size of object
 gkSizeY$N	init	random(1,170)						; Initial y=size of object
 gkLocX$N	init	random(0,giPanelWidth-i(gkSizeX$N))			; Initial x-location of object
 gkLocY$N	init	random(150,giPanelHeight-i(gkSizeY$N)-giFloorDepth)	; Initial y-location of object

 kMoveFlag$N	init	0

 kRelL	trigger	kMOUSE_DOWN_LEFT,0.5,1		; If either click button is released, exit click and drag mode.
 kRelR	trigger	kMOUSE_DOWN_RIGHT,0.5,1
 if kRelL==1||kRelR==1 then
  kMoveFlag$N	=	0			; When left or right click are released, exit click and drag mode
 endif

 if ((kMOUSE_DOWN_LEFT_trig==1||kMOUSE_DOWN_RIGHT_trig==1) && kMOUSE_X>=(gkLocX$N-1) && kMOUSE_X<=(gkLocX$N+gkSizeX$N+1) && kMOUSE_Y>=(gkLocY$N-1) && kMOUSE_Y<=(gkLocY$N+gkSizeY$N+1)) || kMoveFlag$N==1 then	; If we are in click and drag mode
  kMoveFlag$N	=	1	; Set click and drag flag to 'on'

  if changed(gkDeltaX,gkDeltaY)==1 then								; if a change in mouse position during click
   if kMOUSE_DOWN_LEFT==1 then									; CHANGE LOCATION
    gkLocX$N	limit	gkLocX$N + gkDeltaX, 0, giPanelWidth - gkSizeX$N			; Set new x location of object with limits
    gkLocY$N	limit	gkLocY$N + gkDeltaY, 0, giPanelHeight - gkSizeY$N - giFloorDepth	; Set new y location of object with limits
   elseif kMOUSE_DOWN_RIGHT==1 then								; CHANGE SIZE
    gkSizeX$N	limit	gkSizeX$N + gkDeltaX, 2,giPanelWidth-gkLocX$N				; Set new x size of object with limits
    gkSizeY$N	limit	gkSizeY$N + gkDeltaY, 2,giPanelHeight-gkLocY$N-giFloorDepth		; Set new x size of object with limits
   endif
   kSizeX$N	=	(kcount>gkNBlocks?0:gkSizeX$N)						; If this block is not needed set size to zero
   kSizeY$N	=	(kcount>gkNBlocks?0:gkSizeY$N)
   Smess	sprintfk	"bounds(%d,%d,%d,%d)",gkLocX$N,gkLocY$N,kSizeX$N,kSizeY$N	; String for new object bounds
   chnset	Smess,"block$N"   								; Send new string to object
  endif

 endif

 if changed(gkNBlocks)==1 then
  kSizeX$N	=	(kcount>gkNBlocks?0:gkSizeX$N)					; If this block is not needed set size to zero
  kSizeY$N	=	(kcount>gkNBlocks?0:gkSizeY$N)
  Smess	sprintfk	"bounds(%d,%d,%d,%d)",gkLocX$N,gkLocY$N,kSizeX$N,kSizeY$N	; String for new object bounds
  chnset	Smess, "block$N"   							; Send new string to object
 endif

 #
 $BLOCK(1)
 $BLOCK(2)
 $BLOCK(3)
 $BLOCK(4)
 $BLOCK(5)
 $BLOCK(6)
 $BLOCK(7)
 $BLOCK(8)
 $BLOCK(9)

 SKIP:

 kprevX	=	kMOUSE_X	; Set 'previous' mouse x and y for next k-pass
 kprevY	=	kMOUSE_Y
endif

endin


instr	2
 isize	=	i(gksize)	;15		; Size of ball
 icps_floor	init	500*(15/isize)		; Floor bounce noise frequency (also dependent upon ball size)
 icps_wall	init	300*(15/isize)		; Wall bounce noise frequency (also dependent upon ball size)
 iBlipDur	=	0.05*(isize/15)		; Duration of wall bounce noise
 Sid	=	"ball"				; Ball ident
 ky	init	-isize				; Initial y location of ball
 kx	init	random(isize,giPanelWidth-isize); Initial x location of ball
 kxIncr	init	random(-i(gkangle)*ksmps,i(gkangle)*ksmps)	; Initial x increment - left/right direction of throw
 kyIncr	init	0				; Initial y increment. Zero means ball is dropped

 irate	=	ksmps*2				; Rate of gui refresh and data checking
 ktrig	metro	irate

 if ktrig==1 then
  ky	limit	ky + (kyIncr*gkspeed), -isize, giPanelHeight-giFloorDepth-isize	; increment x and y locations
  kx 	limit	kx + (kxIncr*gkspeed), 0, giPanelWidth - isize

   if( (abs(kyIncr)+abs(kxIncr))<giStopThreshold && ky>=(giPanelHeight-giFloorDepth-isize-1)) || changed(gkNewBall)==1 then	; if ball has come to rest...
    event	"i",100,0,0	; launch a new ball
    turnoff
   endif

  if ky>=(giPanelHeight-giFloorDepth-isize) then	; hitting floor
   event	"i",20,0,iBlipDur,kyIncr,icps_floor,kx/giPanelWidth
   kyIncr	=	-kyIncr*(1-gkdamping)	; flip direction and absorb some energy in the bounce
   kxIncr	=	kxIncr*(1-gkfriction)	; absorb some horizontal energy in the bounce
  endif

  if kx>=(giPanelWidth-isize) || kx<=0 then	; flip x direction when hitting a wall
   kxIncr	=	-kxIncr*(1-gkdamping)
   event	"i",20,0,iBlipDur,kyIncr,icps_wall,kx/giPanelWidth
  endif



  #define CHECK_OBJECT_STRIKE(N)
  #
  kcount	=	$N
  if kcount>gkNBlocks kgoto SKIP
  if trigger(ky+isize,gkLocY$N,0)==1 && (kx+isize)>=gkLocX$N && kx<=(gkLocX$N+gkSizeX$N) then			; Striking upper edge
   kyIncr	=	(-kyIncr*(1-gkdamping)) - gkDeltaY
   kxIncr	=	kxIncr*(1-gkfriction)	; absorb some horizontal energy in the bounce
   event	"i",90+$N,0,gkresonance,kx,kxIncr,kyIncr
   ky		=	gkLocY$N-isize
  elseif trigger(kx,gkLocX$N+gkSizeX$N,1)==1 && (ky+isize)>=gkLocY$N && ky<=(gkLocY$N+gkSizeY$N) then		; Striking right hand edge
   kxIncr	=	(-kxIncr*(1-gkdamping)) - gkDeltaX
   event	"i",90+$N,0,gkresonance,kx,kxIncr,kyIncr
   kx		=	gkLocX$N+gkSizeX$N
  elseif trigger(kx+isize,gkLocX$N,0)==1 && (ky+isize)>=gkLocY$N && ky<=(gkLocY$N+gkSizeY$N) then		; Striking left hand edge
   kxIncr	=	(-kxIncr*(1-gkdamping)) - gkDeltaX
   event	"i",90+$N,0,gkresonance,kx,kxIncr,kyIncr
   kx		=	gkLocX$N-isize
  elseif trigger(ky,gkLocY$N+gkSizeY$N,1)==1 && (kx+isize)>=gkLocX$N && kx<=(gkLocX$N+gkSizeX$N) then		; Striking lower edge
   kyIncr	=	(-kyIncr*(1-gkdamping)) - gkDeltaY
   event	"i",90+$N,0,gkresonance,kx,kxIncr,kyIncr
   ky		=	gkLocY$N+gkSizeY$N
  endif
  #
  $CHECK_OBJECT_STRIKE(1)
  $CHECK_OBJECT_STRIKE(2)
  $CHECK_OBJECT_STRIKE(3)
  $CHECK_OBJECT_STRIKE(4)
  $CHECK_OBJECT_STRIKE(5)
  $CHECK_OBJECT_STRIKE(6)
  $CHECK_OBJECT_STRIKE(7)
  $CHECK_OBJECT_STRIKE(8)
  $CHECK_OBJECT_STRIKE(9)
  SKIP:				; Escape to here if finished checking for block collisions
  Smess	sprintfk	"bounds(%d,%d,%d,%d)",kx,ky,isize,isize
  chnset	Smess,Sid

  kyIncr	=	kyIncr + (giGravAccel/irate)
 endif

endin



instr	20	; wall ricochet sound effect
 /* POLYPHONY CONTROL */
 gkactive0 init i(gkactive0) + 1	;INCREMENT NOTE COUNTER
 if gkactive0>1 then			;IF POLYPHONY IS EXCEEDED (THROUGH THE ADDITION OF NEW NOTE)
  turnoff				;REMOVE THIS NOTE
 endif
 krel release				;IF NOTE HELD = 0, IF NOTE RELEASED = 1
 ktrig trigger krel,0.5,0		;WHEN RELEASE FLAG CROSSES 0.5 UPWARDS, I.E. NOTE HAS BEEN RELEASED...
 if ktrig==1 then
  gkactive0 = gkactive0 - 1		;...DECREMENT ACTIVE NOTES COUNTER
 endif
 aenv	expon	giWallFloorAmp,p3,giWallFloorAmp*0.001
 asig	poscil	aenv*((p4/50)^2)*gkspeed,p5
 al,ar	pan2	asig,p6
 	outs	al,ar
 	gal	+= al
 	gar	+= ar
endin



; Object ricochet sound effect
#define CLANG_INSTR(I'N)
#
instr	$I	; object bounce
 p3		=	p3 * ((1-(i(gkSizeY$N)/giPanelHeight))^4)	; duration of the sound scaled by the height of the object. Taller objects sustain for shorter time.

 /* POLYPHONY CONTROL */
 gkactive$N init i(gkactive$N) + 1	;INCREMENT NOTE COUNTER
 if gkactive$N>1 then			;IF POLYPHONY IS EXCEEDED (THROUGH THE ADDITION OF NEW NOTE)
  turnoff				;REMOVE THIS NOTE
 endif
 krel release				;IF NOTE HELD = 0, IF NOTE RELEASED = 1
 ktrig trigger krel,0.5,0		;WHEN RELEASE FLAG CROSSES 0.5 UPWARDS, I.E. NOTE HAS BEEN RELEASED...
 if ktrig==1 then
  gkactive$N = gkactive$N - 1		;...DECREMENT ACTIVE NOTES COUNTER
 endif

 iamp	=	(abs(p5) + abs(p6)) * 0.006				; amplitude dependent upon the speed of the ball at the time of the collision.
 aenv	expsegr	iamp,p3,iamp*0.001,0.05,iamp*0.001			; amplitude envelope
 kndx	expsegr	(abs(p5)+abs(p6))*0.01,p3,0.0001,0.05,0.0001		; index of modulation envelope. Overall envelope amplitude (therefore spectral brightness) influenced by the speed of the ball when the object was struck.
 kporttime	linseg	0,0.001,0.05
 kcps		=	cpsoct(((1-(gkSizeX$N/giPanelWidth))*8)+4)	; base frequency defined by width of the object
 kcps	portk	kcps,kporttime
 kmod		=	1 + ((gkSizeY$N-1)/300)				; modulator frequency defined by the height of the object: the taller the object the more inharmonic the spectrum. At minimum thinness ratio = 1.
 kmod	portk	kmod,kporttime
 acar	expseg	0.993,0.04,1,5,1					; carrier ratio envelope. Helps to create a bit of spectral distortion when the objecrt is struck

 kampscale	=	(gkspeed-0.01)/(20-0.01)
 kampscale	scale	kampscale,3,0.1
 asig 	foscil 	aenv*kampscale, kcps, acar, kmod, kndx, gisine, 0

 /* Fundemental notch filtering */
 abr	butbr	asig*3,kcps,kcps*0.1
 asig	ntrpol	asig,abr,gkfundemental

 al,ar	pan2	asig,p4
 gal	+=	al
 gar	+=	ar
 	outs	al,ar
endin
#
$CLANG_INSTR(91'1)
$CLANG_INSTR(92'2)
$CLANG_INSTR(93'3)
$CLANG_INSTR(94'4)
$CLANG_INSTR(95'5)
$CLANG_INSTR(96'6)
$CLANG_INSTR(97'7)
$CLANG_INSTR(98'8)
$CLANG_INSTR(99'9)



instr	100	; Launch a new ball
 event_i	"i",2,0,300
endin


instr	999
	iChoRte		=	1.2
	iChoDep		=	0.01
	kporttime	linseg	0,0.001,1
	kporttime	=	kporttime/iChoRte
	kdlt1	randomi	ksmps/sr,iChoDep,iChoRte,1
	kdlt1	portk	kdlt1,kporttime
	adlt1	interp	kdlt1
	acho1	vdelay	gal,adlt1*1000,1*1000

	kdlt2	randomi	ksmps/sr,iChoDep,iChoRte,1
	kdlt2	portk	kdlt2,kporttime
	adlt2	interp	kdlt2
	acho2	vdelay	gal,adlt2*1000,1*1000

		outs	acho1, acho2
	gal	+=	acho1
	gar	+=	acho2
endin


instr	1000	; Reverb
 al,ar	reverbsc	gal,gar,0.7,5000
 	outs	al*0.3,ar*0.3
 	clear	gal,gar
endin

instr	1001	; Print and then hide instructions
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"	; sense left click
 kEscapeTrig	trigger	kMOUSE_DOWN_LEFT,0.5,0		; trigger of left click is pressed
 krel release						; release flag - normally 0, 1 at note release
 kalpha	transeg	0,0.5,4,255,p3-1,0,255,0.5,-4,-1	; colour alpha channel: fades in, holds, fades out

 if metro(ksmps)==1||krel==1 then			; peg updates or interrupt if mouse has been clicked
  Smess1	sprintfk	"bounds(%d,%d,400,17), fontcolour(255,255,255,%d)", (giPanelWidth*0.5) - 200, (giPanelHeight*0.5) - 50, kalpha*(1-krel)
  Smess2	sprintfk	"bounds(%d,%d,400,17), fontcolour(255,255,255,%d)", (giPanelWidth*0.5) - 200, (giPanelHeight*0.5) - 25, kalpha*(1-krel)
  chnset	Smess1,"instructions1"
  chnset	Smess2,"instructions2"
 endif

 ktime		times					; note elapsed time in seconds
 if trigger(ktime,p3-0.2,0)==1||kEscapeTrig==1 then	; if time is up mouse has been clicked...
  event "i",1,0,3600*24*7	; track mouse, move and resize blocks, and read in widgets
  event "i",2,0.1,3600		; first throw
  turnoff
 endif

endin


</CsInstruments>

<CsScore>
i 1001 0 4		; Instructions fade up then down (currently not working)
i 999  0    [3600*24*7]	; chorus
i 1000 0    [3600*24*7]	; reverb

</CsScore>

</CsoundSynthesizer>
; Rhythmicon.csd
; Written by Iain McCurdy, 2013.

; Recreation of Henry Cowell and Leon Theremin's Rhythmicon instrument (http://en.wikipedia.org/wiki/Rhythmicon)

; CONTROLS
; --------
; BASE	--	note number of the fundemental (lowest note)
; RATE	--	base rate (same as rate for fundemental)
; LEVEL	--	output level

; DESCRIPTION
; -----------
; Each note above the fundemental (C3) divides the base rate increasingly according to the arithmetic progression: 2,3,4,5...
; Therefore if C3 plays crotchets (quarter notes), C#3 plays quavers (eighth notes), D3 triplets and so on.
; The pitches of each note (in cycles per second) follow a simlar progression.
; If C3 plays a 200Hz tone, C#3 plays 400Hz, D 600Hz and so on.

; The 17th note (E4) does not play a note but instead engages a syncopation effect.  
; I have been unable to find a clear technical specification of how this was implemented but have nonetheless made my 'best guess'.

<Cabbage>
form caption("...") size(159, 180), pluginid("basl"), scrollbars(0) style("legacy")

label   bounds(  5,  3, 18, 22), text("R"), fontcolour(red)
label   bounds( 20,  5, 18, 22), text("H"), fontcolour(yellow)
label   bounds( 35,  2, 18, 22), text("Y"), fontcolour(orchid)
label   bounds( 50,  4, 18, 22), text("T"), fontcolour(LightGreen)
label   bounds( 65,  2, 18, 22), text("H"), fontcolour(OrangeRed)
label   bounds( 82,  6, 18, 22), text("M"), fontcolour(orange)
label   bounds( 97,  1, 18, 22), text("I"), fontcolour(SkyBlue)
label   bounds(110,  4, 18, 22), text("C"), fontcolour(Tomato)
label   bounds(125,  1, 18, 22), text("O"), fontcolour(LightGreen)
label   bounds(140,  3, 18, 22), text("N"), fontcolour(violet)

label   bounds( 81, 24,  78, 8), text("Iain McCurdy [2013]"), FontColour("white")

rslider bounds(  3, 45, 55, 55), channel("base"), textBox(1), range(0, 127,36, 1,1),fontcolour("white"),textcolour("white"),colour(orange), trackercolour(orange)
label   bounds( 19, 34, 30, 10), text("BASE"), fontcolour(white)
rslider bounds( 52, 45, 55, 55), channel("rate"), textBox(1), range(0.1, 5.00, 0.5, 0.5, 0.01),fontcolour("white"),textcolour("white"),colour(orange), trackercolour(orange)
label   bounds( 68, 34, 30, 10), text("RATE"), fontcolour(white)
rslider bounds(102, 45, 55, 54), channel("level"), textBox(1), range(0, 1.00, 0.5, 0.5, 0.01),fontcolour("white"),textcolour("white"),colour(orange), trackercolour(orange)
label   bounds(115, 34, 30, 10), text("LEVEL"), fontcolour(white)


checkbox bounds(  0, 101,  9, 10), channel("k1")  value(0) shape(square) colour(yellow)
checkbox bounds(  9, 101, 10, 10), channel("k2")  value(0) shape(square) colour(yellow)
checkbox bounds( 19, 101,  9, 10), channel("k3")  value(0) shape(square) colour(yellow)
checkbox bounds( 28, 101, 10, 10), channel("k4")  value(0) shape(square) colour(yellow)
checkbox bounds( 38, 101, 10, 10), channel("k5")  value(0) shape(square) colour(yellow)
checkbox bounds( 48, 101,  8, 10), channel("k6")  value(0) shape(square) colour(yellow)
checkbox bounds( 56, 101, 10, 10), channel("k7")  value(0) shape(square) colour(yellow)
checkbox bounds( 66, 101,  8, 10), channel("k8")  value(0) shape(square) colour(yellow)
checkbox bounds( 74, 101, 10, 10), channel("k9") value(0) shape(square) colour(yellow)
checkbox bounds( 84, 101,  9, 10), channel("k10") value(0) shape(square) colour(yellow)
checkbox bounds( 93, 101, 10, 10), channel("k11") value(0) shape(square) colour(yellow)
checkbox bounds(103, 101,  9, 10), channel("k12") value(0) shape(square) colour(yellow)
checkbox bounds(112, 101,  9, 10), channel("k13") value(0) shape(square) colour(yellow)
checkbox bounds(121, 101, 10, 10), channel("k14") value(0) shape(square) colour(yellow)
checkbox bounds(131, 101,  9, 10), channel("k15") value(0) shape(square) colour(yellow)
checkbox bounds(140, 101, 10, 10), channel("k16") value(0) shape(square) colour(yellow)
checkbox bounds(150, 101, 10, 10), channel("k17") value(0) shape(square) colour(red)

keyboard bounds(-561, 110,1200, 70)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>
sr 	= 	44100
ksmps 	= 	64
nchnls 	= 	2
0dbfs	=	1
massign	0,1

; Author: Iain McCurdy (2013)

giAmpScl	ftgen	0,0,-20000,-16, 1,100,0,1, 20000-100,-100,0.2

opcode	SwitchPort, k, kkk
	kin,kUpPort,kDnPort	xin
	kold			init	0
	kporttime		=	(kin<kold?kDnPort:kUpPort)
	kout			portk	kin, kporttime
	kold			=	kout
				xout	kout
endop

	instr	1	; Listen for midi note changes. Turn lights on or off. Start the rhymicon of at least 1 note is held.
inum	notnum				; read in midi note number

#define	LightToggle(N)	#		; define a macro to reduce code repetition
if inum=(59+$N) then			; if note number played on the keyboard corresponds to 'this' toggle light... (note that first note will be C3 (59 + 1)
 ik$N	chnget	"k$N"			; read current value for 'this' toggle light (at i-time)
 	chnset	1-ik$N,"k$N"		; write the inverse to it (i.e. toggle it)
endif#
$LightToggle(1)				; expand macro for all 16 layers
$LightToggle(2)
$LightToggle(3)
$LightToggle(4)
$LightToggle(5)
$LightToggle(6)
$LightToggle(7)
$LightToggle(8)
$LightToggle(9)
$LightToggle(10)
$LightToggle(11)
$LightToggle(12)
$LightToggle(13)
$LightToggle(14)
$LightToggle(15)
$LightToggle(16)
$LightToggle(17)

kk1	chnget	"k1"
kk2	chnget	"k2"
kk3	chnget	"k3"
kk4	chnget	"k4"
kk5	chnget	"k5"
kk6	chnget	"k6"
kk7	chnget	"k7"
kk8	chnget	"k8"
kk9	chnget	"k9"
kk10	chnget	"k10"
kk11	chnget	"k11"
kk12	chnget	"k12"
kk13	chnget	"k13"
kk14	chnget	"k14"
kk15	chnget	"k15"
kk16	chnget	"k16"

ksum	=	kk1 + kk2 + kk3 + kk4 + kk5 + kk6 + kk7 + kk8 + kk9 + kk10 + kk11 + kk12 + kk13 + kk14 + kk15 + kk16
if ksum>0 then
 schedkwhen	1,0,1,2,0,-1
else
 turnoff2	2,0,1
endif
	endin

	instr	2
kporttime	linseg	0,0.001,0.05
kbase	chnget	"base"			; base pitch as a note number
krate	chnget	"rate"			; rate of pulsation of fundemental
krate	portk	krate, kporttime
klevel	chnget	"level"			; output amplitude level
ksync	chnget	"k17"			; syncopation mode
kBaseFrq	=	cpsmidinn(kbase)
kBaseFrq	portk	kBaseFrq,kporttime
iamp		=	0.6
amix		=	0

#define	LAYER(N)#					; use a macro to reduce code repetition
kk$N	chnget	"k$N"
kk$N	SwitchPort	kk$N,kporttime*0.01,kporttime*0.5
ktrig	metro	krate * $N
kn	=	$N					; layer number as a variable
if ksync=1&&kn>1 then					; if syncopation is on and this isn't the first layer (syncopation irrelevant for first layer)
 ktrig	vdelayk	ktrig, (1/(krate*$N))/$N    , 1/0.1	; add a syncopation delay for the metronome trigger for this layer
endif
kenv loopseg $N/60, ktrig, 0, 0,0.025, 1,0.84/krate, 0,60, 0 ; retriggering envelope
aenv	interp	kenv*kk$N					; interpolate to a-rate (for better smoothness)
kcps	=	kBaseFrq*$N				; pitch for this layer (in cycles per second)
kscl	table	kcps,giAmpScl				; amp scaling value (to quieten higher sounds)
kamp	=	iamp*kscl				; apply on/off switch for this layer to its amplitude
asig	vco2	kamp,kcps,2,0.1				; generate a tone (pulse wave)
kcf	limit	cpsoct(octcps(kcps*3)*kenv),1,10000	; filter envelope
asig	clfilt	asig,kcf,0,2				; butterworth lowpass filter the sound
asig	=	asig*aenv				; apply amplitude envelope
amix	=	amix + asig#				; add to 'mix' signal with the other layers

$LAYER(1)						; expand macro multiple times. Once for each layer
$LAYER(2)
$LAYER(3)
$LAYER(4)
$LAYER(5)
$LAYER(6)
$LAYER(7)
$LAYER(8)
$LAYER(9)
$LAYER(10)
$LAYER(11)
$LAYER(12)
$LAYER(13)
$LAYER(14)
$LAYER(15)
$LAYER(16)
	xtratim	0.5
	outs	amix*klevel, amix*klevel
	endin	


</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]		;read widgets
;i 2 0 [3600*24*7]		;read widgets
</CsScore>

</CsoundSynthesizer>; SonicLavaLamp.csd
; Written by Iain McCurdy, 2012.

<Cabbage>
form caption("Sonic Lava Lamp") size(510, 450), pluginid("sonl") style("legacy")
image bounds(  5,  0,250, 210), colour(255,255, 50,100),shape("rounded"), oulinecolour("white"), line(0)
image bounds(255,  0,250, 210), colour(  0,  0,255,100),shape("rounded"), oulinecolour("white"), line(0)
image bounds(  5,210,250, 210), colour(  5,255,  0,100),shape("rounded"), oulinecolour("white"), line(0)
image bounds(255,210,250, 210), colour(255,  0,200,100),shape("rounded"), oulinecolour("white"), line(0)

xypad bounds(5, 0, 250, 210), channel("LFOspeed", "LFO_OS"), rangex(0, 1.00, 0.01), rangey(5, 11, 8), text("Speed/OS")
xypad bounds(255, 0, 250, 210), channel("LFOshape", "LFOdepth"), rangex(0, 1, 0.7), rangey(0.1, 4, 2), text("Shape/Depth")
xypad bounds(5, 210, 250, 210), channel("pan", "amp"), rangex(0, 1, 0.5), rangey(0, 1, 0.8), text("pan/amp")
xypad bounds(255, 210, 250, 210), channel("DelTim", "DelSnd"), rangex(0, 1.00, 0.5), rangey(0, 1.00, 0.5), text("Delay Time/Send")
infobutton bounds(5,425, 100, 20), text("Help"), file("SonicLavaLampHelp.html")
image bounds(105, 425, 300, 20), colour(75, 85, 90, 100), plant("credit"), line(0){
label bounds(0.03, 0.1, .9, .7), text("Author: Iain McCurdy |2012|"), fontcolour("white")
}
</Cabbage>
<CsoundSynthesizer>
<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>
<CsInstruments>
sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	2
0dbfs	=	1

;Author: Iain McCurdy (2012)

gisine		ftgen	0, 0, 4096, 10, 1				;SINE WAVE
giSawUp		ftgen	0, 0, 4096, -7, -1, 4096, 1
giTri		ftgen	0, 0, 4096, -7,  -1, 2048, 1, 2048, -1
giSawDn		ftgen	0, 0, 4096, -7, 1, 4096, -1
giSq		ftgen	0, 0, 4096, -7, 1, 2048, 1, 0, -1, 2048, -1
giMorfTab	ftgen	0, 0, 4096, -7, 1, 2048, 1, 0, -1, 2048, -1
giTabs4Morf	ftgen	0, 0, 8, -2, giSq, giSawUp, giTri, giSawDn, giSq, giSq, giSq, giSq
giAmpCurve	ftgen	0, 0, 16, -16,   1, 6, 0, 1,   5, -4, 0.2,   5, 0, 0.2
giEnv		ftgen	0, 0, 4096, 20,3,1	;9, 0.5, 1, 0

opcode	PingPongDelay, aa,aakk
	ainL,ainR,ktime,kfeedback	xin
	atime		interp	ktime					;INTERPOLATED A-RATE VERSION OF DELAY TIME
	aL_OS		vdelay	ainL,(atime*1000)/2,(10*1000)/2	;DELAYED OFFSET OF LEFT CHANNEL (FIRST 'PING')
	;LEFT CHANNEL
	abuf		delayr	10					;ESTABLISH DELAY BUFFER
	aDelL		deltapi	atime					;TAP BUFFER
			delayw	aL_OS+(aDelL*kfeedback)			;WRITE INPUT AUDIO INTO BUFFER
	;RIGHT CHANNEL
	abuf		delayr	10					;ESTABLISH DELAY BUFFER
	aDelR		deltapi	atime					;TAP BUFFER
			delayw	ainR+(aDelR*kfeedback)			;WRITE INPUT AUDIO INTO BUFFER
			xout	aDelL+aL_OS,aDelR
endop

instr	InitialiseXYpads
; xypads output zeroes until they are moved (regardless of any initialisation done within the widget)
; a workaround is to initialise the xypad using chnset within an instrument
; here I have used a macro so cut down on code repetition
#define	SET_XYPAD_INIT(NAME'VAL)#
	kval	=	$VAL
	chnset	kval,"$NAME"#
$SET_XYPAD_INIT(LFOspeed'0.01)
$SET_XYPAD_INIT(LFO_OS'8)
$SET_XYPAD_INIT(LFOshape'0.7)
$SET_XYPAD_INIT(LFOdepth'2)
$SET_XYPAD_INIT(pan'0.5)
$SET_XYPAD_INIT(amp'0.8)
$SET_XYPAD_INIT(DelTim'0.5)
$SET_XYPAD_INIT(DelSnd'0.5)
endin

instr	1
	kLFOspeed	chnget	"LFOspeed"
	kLFO_OS		chnget	"LFO_OS"
	kLFOshape	chnget	"LFOshape"
	kLFOdepth	chnget	"LFOdepth"
	kamp		chnget	"amp"
	kpan		chnget	"pan"
	kDelTim		chnget	"DelTim"
	kDelSnd		chnget	"DelSnd"

	kLFOspeed	expcurve	kLFOspeed,6
	kLFOspeed	scale	kLFOspeed, 40,0.01
	kDelTim		expcurve	kDelTim,6
	kDelTim		scale	kDelTim, 0.5,0.01

	kporttime	linseg	0,0.01,0.03
	kDelSnd		portk	kDelSnd,kporttime*3
	kLFOdepth	portk	kLFOdepth,kporttime
	kLFO_OS		portk	kLFO_OS,kporttime
	kLFOshape	portk	kLFOshape,kporttime
	kamp		portk	kamp,kporttime
	kamp		expcurve	kamp,2
	kpan		portk	kpan,kporttime
			ftmorf	kLFOshape*5, giTabs4Morf, giMorfTab
	aoctLFO		oscili	kLFOdepth,kLFOspeed,giMorfTab
	aoct		=	aoctLFO+kLFO_OS
	koct		downsamp	aoct
	kAmpCurve	tablei	koct,giAmpCurve
	kcps		=	cpsoct(koct)
	aamp		interp	kAmpCurve/3
	asig		oscili	aamp,kcps,gisine	;AUDIO OSCILLATOR
	aenv		oscili	1,kLFOspeed,giEnv
	kEnvXFade	jspline	1,0.2,0.6
	kEnvXFade	limit	kEnvXFade,0,1
	asig		ntrpol	asig*aenv,asig,kEnvXFade

	
	aL,aR		pan2	asig,kpan
	aRvbL,aRvbR	reverbsc	aL,aR,0.8,4000
	aL		sum	(aL*kamp),(aRvbL*0.1)
	aR		sum	(aR*kamp),(aRvbR*0.1)
	kDelTim		portk	kDelTim,kporttime*10
	aDlyL,aDlyR	PingPongDelay	aL*kDelSnd,aR*kDelSnd,2*kDelTim,0.6
	aL		sum	aL,(aDlyL*0.5)
	aR		sum	aR,(aDlyR*0.5)

			outs	aL, aR
endin

</CsInstruments>

<CsScore>
i "InitialiseXYpads" 0.1 0.01
i 1 0.2 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; Splat.csd
; Written by Iain McCurdy, 2014.
;
; Left click somewhere within the swarm to splat the flies.
; Left click again somewhere within the field of splatted flies to unsplat them and bring them back to life.
;
; Population	-	the number of flies in the swarm
; Liveliness	-	the speed with which flies will move about within the swarm
; Excursion	-	how far flies will move away from the centre of the swarm, therefore this also defines the area covered by the swarm.
; Fly Size	-	doesn't affect the physical size of flies but instead affects the central frequency of the buzzing tone they produce.
; Swarm Speed	-	the speed with which the swarm moves around the panel. The swarm can exit the panel completely.
;
; If the swarm area (excursion) is very small it can become difficult to splat (and unsplat) it.
; If this becomes a problem, simply raise the value for excursion, even while the swarm is splatted.

<Cabbage>
form caption("Splat!"), size(1000,530), colour(230,230,230),guirefresh(64), pluginid("Splt") style("legacy")
image bounds(0,   0, 0, 0), colour(white), shape(ellipse), widgetarray("fly",500)
nslider  bounds(  5,495,60,34), channel("Population"),    range(1,100, 10,1,1),       textcolour(black), fontcolour(black), text("Population"), colour(white)
nslider  bounds( 70,495,60,34), channel("Liveliness"),    range(0.1,10.00, 4,1,0.1),  textcolour(black), fontcolour(black), text("Liveliness"), colour(white)
nslider  bounds(135,495,60,34), channel("Excursion"),     range(2,300, 50,1,1),       textcolour(black), fontcolour(black), text("Excursion"),  colour(white)
nslider  bounds(200,495,60,34), channel("FlySize"),       range(2,12, 5,1,0.001),     textcolour(black), fontcolour(black), text("Fly Size"),   colour(white)
nslider  bounds(265,495,80,34), channel("SwarmSpeed"),    range(0.1,10, 0.3,1,0.001), textcolour(black), fontcolour(black), text("Swarm Speed"),colour(white)
label    bounds(  0, 0,  0, 0), text("Click swarm to splat. Click again to unsplat."), align(centre), fontcolour(white), identchannel("instructions1")		; Instructions
label    bounds(350,519,100, 10), text("Iain McCurdy 2014"), align(left), fontcolour(0,0,0,150)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
seed	0

giPanelWidth	=	1000
giPanelHeight	=	530
gisine	ftgen	0,0,131072,10,1
giMaxFlies	=	500

; UDO that provide different portamento times whether a value is rising or falling
opcode	SwitchPort, k, kkk
	kin,kUpPort,kDnPort	xin
	kold			init	0
	kporttime		=	(kin<kold?kDnPort:kUpPort)
	kout			portk	kin, kporttime
	kold			=	kout
				xout	kout
endop

; UDO for an i-rate version of the 'scale' opcode
opcode	scale_i,i,iii
 ival,imax,imin	xin
 ival	=	(ival * (imax-imin)) + imin
	xout	ival
endop

; UDO for moving fly and creating its buzzing sound
opcode	Fly,aa,kkkkkkkip
 kSplat,kExcursion,kLiveliness,koct,kFlySize,kOffX,kOffY,iMaxFlies,iCount	xin

 if kSplat==0 then							; if flies are living...
  kX	rspline	-kExcursion,kExcursion,kLiveliness,kLiveliness*2	; variables for fly movement within the swarm
  kY	rspline	-kExcursion,kExcursion,kLiveliness,kLiveliness*2
  kDist	rspline	0.5,1.5,0.02,0.03						; z-plane distance of the fly. Really just a bit of size modulation.
 endif

 kamp	=	((kY*0.5)/kExcursion) + 0.5				; amplitude of the buzzing sound varie according to the distance of the fly along the y-axis from the front of the swarm
 kamp	scale	kamp,1,0.1						; amplitude value scaled so that flies never audibly disappear entirely
 asig	vco2	0.01*kamp,cpsoct(koct)*semitone((kX+kY)*0.02),6		; the buzzing sound: a pulse wave

 kpan	=	((kX*0.5)/kExcursion) + 0.5				; buzzing sounds are panned according to their left/right position within the swarm
 aL,aR	pan2	asig,kpan						; panned

 kFlySizeL	scale	(kFlySize-1)/9,3,0.5		; this layer's fly size

 kRefreshTrig	metro	ksmps,iCount/giMaxFlies				; frame rate with which flies will be graphically moved. A different trigger (each with a different phase offset) for each fly so that all chnsets don't happen at the same time and cripple performance.
 if kRefreshTrig==1 && kSplat==0 then					; if a refresh trigger has occured...
 	Smess	sprintfk	"bounds(%d,%d,%d,%d), colour(0,0,0,200)",kOffX+kX,kOffY+kY,kDist*kFlySizeL,kDist*kFlySizeL	; generate message for fly widget
 	Sident	sprintfk	"fly_ident%d", iCount							; generate ident string appropriate to this fly
 	chnset Smess, Sident						; update the fly
 endif

 aMixL	=	0
 aMixR	=	0

 if iCount<iMaxFlies then
  aMixL,aMixR	Fly	kSplat,kExcursion,kLiveliness,koct,kFlySize,kOffX,kOffY,iMaxFlies,iCount+1
 endif

	xout	aL+aMixL, aR+aMixR
endop

instr	1
 kMOUSE_X		chnget	"MOUSE_X"		; track mouse activity
 kMOUSE_Y		chnget	"MOUSE_Y"
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"
 kMOUSE_DOWN_RIGHT	chnget	"MOUSE_DOWN_RIGHT"

 kSplat	init	0					; splat status: 0 = alive, 1 = splatted

 aMixL,aMixR	init	0				; audio mix of all buzzing sounds (initialised)
 kLiveliness	chnget	"Liveliness"			; speed with which flies move within the swarm
 kExcursion	chnget	"Excursion"			; range (in pixels) that individual flies might go from the the centre of the swarm
 kFlySize	chnget	"FlySize"			; fly size (affects pitch of buzzing only)
 koct		scale	(kFlySize-1)/9,7,12		; scale buzzing pitch (oct format)
 kporttime	linseg	0,0.001,0.05			; portamento time rises from zero to a held value
 koct		portk	koct,kporttime			; smooth chages to buzzing frequency
 kSwarmSpeed	chnget	"SwarmSpeed"			;

 if kSplat==0 then					; if flies are alive...
  gkPopulation	chnget	"Population"			; read changes to population. This widget is only read while flies are alive so that splatted flies don't appear or disappear while splatted.
 endif

 if changed(gkPopulation)==1 then			; if a change to the number of flies is made by the user. (Changes made while flies are dead will only register once the flies are unsplatted.)
  event	"i",10,0,0					; call instrument that hides all active flies. This is done so to ensure that deactivated flies are no longer visible. Flies that should be active flies will be made visible immediately after in this instrument.
 endif

 if trigger(kSplat,0.5,0)==1 then			; if a succesful splatting has been made...
  event	"i",20,0,0					; call the instrument that splats all active flies
 endif

 if kSplat==0 then					; if flies are living...
  kOffX		rspline	0,giPanelWidth,kSwarmSpeed,kSwarmSpeed*2		; generate variables that move the entire swarm. i.e. the swarm should not move while all flies are splatted.
  kOffY		rspline	0,giPanelHeight,kSwarmSpeed,kSwarmSpeed*2
 endif

 ; if a left click is made within the boundaries of the swarm it will be alternately splatted or unsplatted as appropriate
 if trigger(kMOUSE_DOWN_LEFT,0.5,0)==1 && kMOUSE_X>=(kOffX-kExcursion) && kMOUSE_X<=(kOffX+kExcursion)  && kMOUSE_Y>=(kOffY-kExcursion) && kMOUSE_Y<=(kOffY+kExcursion) then
  kSplat	=	(kSplat==1?0:1)
 endif

 ; Call UDO for moving fly and creating buzzing sound
 if changed:k(gkPopulation)==1 then
  reinit ChangedPopulation
 endif
 ChangedPopulation:
 aMixL,aMixR	Fly	kSplat,kExcursion,kLiveliness,koct,kFlySize,kOffX,kOffY,i(gkPopulation)
 rireturn

 kenv	linseg	0,4,1	; initial rise in amplitude
 aMixL	*=	SwitchPort((1-kSplat),0.5,0.001)*kenv	; turn audio on an off according to splat status. When splatted audio is interrupted suddenly, when unsplatted audio rises more slowly.
 aMixR	*=	SwitchPort((1-kSplat),0.5,0.001)*kenv	;
	outs	aMixL,aMixR	; send audio to outputs
	clear	aMixL,aMixR	; clear audio mix variables
endin

instr	10	; hide all flies
 iCount	=	1
 while iCount<=giMaxFlies do
 Sid	sprintf	"fly_ident%d",iCount
 chnset	"bounds(-100,-100,0,0), colour(0,0,0,0)",Sid
 iCount	+=	1
 od
endin


instr	20	; graphically splat flies
 event_i "i",21,0,0.1	; call instrument that produces the sound effect
 iCount	=	1
 while iCount<=giMaxFlies do
 isize	random	4,20		; splat size randomised
 ialpha	random	80,180		; alpha (transparency) randomised
 ired	random	30,150		; add in a random amount of red to give it a bit of gore
 Smess	sprintf	"size(%d,%d), colour(%d,0,0,%d)",isize,isize,ired,ialpha	; create message for graphical splat
 Sid	sprintf	"fly_ident%d",iCount
 chnset	Smess,Sid	; send message to the fly widget
 iCount	+=	1
 od
endin

instr	21	; splat sound effect
 idur	scale_i	rnd(1)^2,0.15,0.08	; random duration
 p3	=	idur			; assign to p3
 imin	random	8,10			; minimum frequency for splat filter (in oct)
 anoise	dust2	10,100*gkPopulation	; some crackly noise, the density of which is dependent upon the fly population
 kcf	random	cpsoct(imin),cpsoct(imin+3)	; cutoff frequency is a random function moving to a new value every k-cycle
 anoise	moogladder	anoise,kcf,0.7	; filter the crackly noise using moogladder to give it a bit of squelch
 anoise	buthp	anoise,200		; highpass filter to remove some of the lower frequencies
 aenv	expon	1,p3,0.1		; amplitude envelope which will give the splat sound a percussive shape
 anoise	*=	aenv			; apply envelope
 	outch	1,anoise		; send this signal to the left channel

 anoise	dust2	10,1000			; repeat for the left channel. Doing both channels completely seperately create a nice stereo effect
 kcf	random	cpsoct(imin),cpsoct(imin+3)
 anoise	moogladder	anoise,kcf,0.7
 anoise	buthp	anoise,200
 aenv	expon	1,p3,0.1
 anoise	*=	aenv
 	outch	2,anoise
endin


instr	1001	; Print and then hide instructions
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"	; sense left click
 kEscapeTrig	trigger	kMOUSE_DOWN_LEFT,0.5,0		; trigger of left click is pressed
 krel release						; release flag - normally 0, 1 at note release
 kalpha	transeg	0,0.2,4,255,p3-0.4,0,255,0.2,-4,-1	; colour alpha channel: fades in, holds, fades out

 if metro(ksmps)==1||krel==1 then			; peg updates or interrupt if mouse has been clicked
  Smess1	sprintfk	"bounds(%d,%d,400,17), fontcolour(0,0,0,%d)", (giPanelWidth*0.5) - 200, (giPanelHeight*0.5)-10, kalpha*(1-krel)
  chnset	Smess1,"instructions1"
 endif

 ktime		times					; note elapsed time in seconds
 if trigger(ktime,p3-0.2,0)==1||kEscapeTrig==1 then	; if time is up mouse has been clicked...
  event "i",1,0,3600*24*7	; start swarm
  turnoff
 endif

endin

</CsInstruments>

<CsScore>
i 1001 0 3		; Instructions fade up then down (currently not working)
</CsScore>

</CsoundSynthesizer>
; Windmills.csd
; Written by Iain McCurdy, 2014
;
; This doesn't make sound yet!

<Cabbage>
form caption("Windmills") size(700,500), colour(150,150,255), scrollbars(0), guirefresh(32), pluginid("WinM") style("legacy")
; SUN
image bounds(610, 20,70,70), colour(250,250,100), shape(ellipse)			; sun

; CLOUDS
image bounds( 30,50,40,40), colour(240,240,240), shape(ellipse), identchannel(cloud1_a)
image bounds( 50,30,60,60), colour(240,240,240), shape(ellipse), identchannel(cloud1_b)
image bounds( 90,50,40,40), colour(240,240,240), shape(ellipse), identchannel(cloud1_c)
image bounds( 52,70,56,20), colour(240,240,240), shape(sharp),   identchannel(cloud1_d)

image bounds(125, 90, 60,60), colour(240,240,240), shape(ellipse), identchannel(cloud2_a)
image bounds(155, 60, 90,90), colour(240,240,240), shape(ellipse), identchannel(cloud2_b)
image bounds(215, 90, 60,60), colour(240,240,240), shape(ellipse), identchannel(cloud2_c)
image bounds(160,120, 80,30), colour(240,240,240), shape(sharp),   identchannel(cloud2_d)

image bounds(290, 80, 25, 25), colour(240,240,240), shape(ellipse), identchannel(cloud3_a)
image bounds(305, 65, 35, 35), colour(240,240,240), shape(ellipse), identchannel(cloud3_b)
image bounds(330, 80, 25, 25), colour(240,240,240), shape(ellipse), identchannel(cloud3_c)
image bounds(302, 90, 36, 15), colour(240,240,240), shape(sharp),   identchannel(cloud3_d)

; WINDMILL 1
image bounds( 96,150,  8,200), colour(white), shape(sharp) 				; post
image bounds( 92,142, 16, 16), colour(white), shape(ellipse)				; joint
image bounds( 98,154,  0,  0), colour(white), shape(ellipse), identchannel("Axle1")	; axle
image bounds(  0,  0,  0,  0), colour(white), shape(ellipse), widgetarray("CircleSix1",6)


; WINDMILL 3
image bounds(548,220, 4, 200), colour(white), shape(sharp) 				; post
image bounds(546,216, 8,   8), colour(white), shape(ellipse)				; joint
image bounds(548,224,  0,  0), colour(white), shape(ellipse),   identchannel("Axle3")	; axle
image bounds(  0,  0,  0,  0), colour(white), shape(ellipse), widgetarray("CircleNine3",9)


; HILLS
image bounds( 100,310,750,500),  colour(  0,170,100), shape(ellipse)			; hill
image bounds( 350,280,1050,500), colour(  0,160, 50), shape(ellipse)			; hill
image bounds(-400,300,900,500),  colour(  0,150,  0), shape(ellipse)			; hill


; WINDMILL 2
image bounds(296,170, 8, 200), colour(white), shape(sharp) 				; post
image bounds(296,368, 8,   4), colour(white), shape(ellipse) 				; base
image bounds(292,162,16,  16), colour(white), shape(ellipse)				; joint
image bounds(298,174,  0,  0), colour(white), shape(ellipse),   identchannel("Axle2")	; axle
image bounds(  0,  0,  0,  0), colour(white), shape(ellipse), widgetarray("CircleSeven2",7)


; WINDMILL 4
image bounds(594,470, 12, 200), colour(white), shape(sharp) 				; post
image bounds(588,458, 24, 24), colour(white), shape(ellipse)				; joint
image bounds(600,474,  0,  0), colour(white), shape(ellipse),   identchannel("Axle4")	; axle
image bounds(  0,  0,  0,  0), colour(white), shape(ellipse), widgetarray("CircleSeven4",7)

; BLACK OUT SCREEN
image bounds(  0,  0,700,500), colour("black"), shape(sharp), identchannel("Blackout")

; INSTRUCTIONS
label    bounds(  0, 0,  0, 0), text("Blow into your microphone..."), align(centre), fontcolour(white), identchannel("instructions1")		; Instructions

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -dm0
</CsOptions>

<CsInstruments>

sr = 44100
ksmps = 32
nchnls = 2
0dbfs=1

gisine	ftgen	0,0,4096,10,1
giPanelWidth	=	700
giPanelHeight	=	500
giRefreshRate	=	1024

instr	1
 aL,aR	ins
 krms	rms	(aL+aR)*4

 ; Move clouds
 kCloudOffset1,kCloudOffset2,kCloudOffset3	init	0
 kCloudTrig1	metro	(giRefreshRate/ksmps)*0.05,(kr-1)/kr
 kCloudTrig2	metro	(giRefreshRate/ksmps)*0.1,(kr-1)/kr
 kCloudTrig3	metro	(giRefreshRate/ksmps)*0.15,(kr-1)/kr
 if kCloudTrig1==1 then
  Smess1a	sprintfk	"bounds( %d,50,40,40)",30+kCloudOffset1
  Smess1b	sprintfk	"bounds( %d,30,60,60)",50+kCloudOffset1
  Smess1c	sprintfk	"bounds( %d,50,40,40)",90+kCloudOffset1
  Smess1d	sprintfk	"bounds( %d,70,56,20)",52+kCloudOffset1
  		chnset		Smess1a,"cloud1_a"
  		chnset		Smess1b,"cloud1_b"
  		chnset		Smess1c,"cloud1_c"
  		chnset		Smess1d,"cloud1_d"
  kCloudOffset1	wrap	kCloudOffset1+1,-200,giPanelWidth
 elseif kCloudTrig2==1 then
  Smess2a	sprintfk	"bounds(%d, 90, 60,60)",125+kCloudOffset2
  Smess2b	sprintfk	"bounds(%d, 60, 90,90)",155+kCloudOffset2
  Smess2c	sprintfk	"bounds(%d, 90, 60,60)",215+kCloudOffset2
  Smess2d	sprintfk	"bounds(%d,120, 80,30)",160+kCloudOffset2
  		chnset		Smess2a,"cloud2_a"
  		chnset		Smess2b,"cloud2_b"
  		chnset		Smess2c,"cloud2_c"
  		chnset		Smess2d,"cloud2_d"
  kCloudOffset2	wrap	kCloudOffset2+1,-250,giPanelWidth
 elseif kCloudTrig3==1 then
  Smess3a	sprintfk	"bounds(%d, 80, 25, 25)",290+kCloudOffset3
  Smess3b	sprintfk	"bounds(%d, 65, 35, 35)",305+kCloudOffset3
  Smess3c	sprintfk	"bounds(%d, 80, 25, 25)",330+kCloudOffset3
  Smess3d	sprintfk	"bounds(%d, 90, 40, 15)",302+kCloudOffset3
  		chnset		Smess3a,"cloud3_a"
  		chnset		Smess3b,"cloud3_b"
  		chnset		Smess3c,"cloud3_c"
  		chnset		Smess3d,"cloud3_d"
  kCloudOffset3	wrap	kCloudOffset3+1,-300,giPanelWidth
 endif

 ; MACRO FOR AN INDIVIDUAL CIRCLE
 #define INDIVIDUAL_CIRCLE(N'P'NUMBER'WIDTH'X'Y'NUM)
 #

 kwidth$N	=	$WIDTH
 kspeed2	portk	kspeed,limit((ksize*kMaxWidth)/1000,0,2)

 kx$N	oscil	kwidth$N*(1-abs(kSwing2)),kspeed2,gisine,$P
 ky$N	oscil	kwidth$N,kspeed2,gisine,$P+0.25

 ; Create a sound
 ;ktrig	trigger	kx$N,0,0
 ;schedkwhen	ktrig,0,0,100+$NUM,0,0.05,$GroupNum,$N,kspeed2,kSwing2

 if kRefreshTrig==1 then
  Smess$N	sprintfk	"bounds(%d,%d,%d,%d), colour(%d,%d,%d)", kx$N+$X+kX_Offset+(kAxleLenMax*kSwing2)-(ksize*0.5) - (ksize*0.5*abs(kSwing2)), ky$N+$Y-(ksize*0.5), ksize*ktilt, ksize, kR, kG, kB
  Sident	sprintfk	"Circle$NUMBER.%d_ident%d",$NUM,$N
  chnset	Smess$N,Sident
 endif
 #




 #define CIRCLE_OF_FIVE(SIZE'WIDTH'X'Y'NUM)
 #
  $INDIVIDUAL_CIRCLE(1'0/5'Five'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(2'1/5'Five'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(3'2/5'Five'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(4'3/5'Five'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(5'4/5'Five'$WIDTH'$X'$Y'$NUM)
 #

 #define CIRCLE_OF_SIX(SIZE'WIDTH'X'Y'NUM)
 #
  $INDIVIDUAL_CIRCLE(1'0/6'Six'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(2'1/6'Six'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(3'2/6'Six'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(4'3/6'Six'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(5'4/6'Six'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(6'5/6'Six'$WIDTH'$X'$Y'$NUM)
 #

 #define CIRCLE_OF_SEVEN(SIZE'WIDTH'X'Y'NUM)
 #
  $INDIVIDUAL_CIRCLE(1'0/7'Seven'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(2'1/7'Seven'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(3'2/7'Seven'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(4'3/7'Seven'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(5'4/7'Seven'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(6'5/7'Seven'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(7'6/7'Seven'$WIDTH'$X'$Y'$NUM)
 #

 #define CIRCLE_OF_NINE(SIZE'WIDTH'X'Y'NUM)
 #
  $INDIVIDUAL_CIRCLE(1'0/9'Nine'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(2'1/9'Nine'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(3'2/9'Nine'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(4'3/9'Nine'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(5'4/9'Nine'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(6'5/9'Nine'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(7'6/9'Nine'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(8'7/9'Nine'$WIDTH'$X'$Y'$NUM)
  $INDIVIDUAL_CIRCLE(9'8/9'Nine'$WIDTH'$X'$Y'$NUM)
 #



 #define WINDMILL(NUM'X'Y'SIZE'WIDTH'R'G'B'AXLE_WIDTH'AXLE_LENGTH)
 #
 ; WINDMILL 1
 kX	=	$X
 kY	=	$Y
 ksize	=	$SIZE
 kMaxWidth	=	$WIDTH
 kSwing2	portk kSwing,limit((ksize*kMaxWidth)/1000,0,2)
 ktilt	=	1 - abs(kSwing2)

 ; printk	0.5,ktilt	; 1 = full 0.5 = tilted
 ; printk	0.5,kspeed		; 1 = full 0.5 = tilted

 kWidth		=	(1-abs(kSwing2))*kMaxWidth
 kX_Offset	=	(kMaxWidth - kWidth) * 0.5

 kColour	=	(kSwing2+1)*0.5
 kR		scale	kColour, $R, 10
 kG		scale	kColour, $G,  0
 kB		scale	kColour, $B,  0

 iAxle_Width$NUM	=	$AXLE_WIDTH

 kAxleLenMax	=	$AXLE_LENGTH
 kAxleLen	=	kAxleLenMax*abs(kSwing2)
 kAxleX		=	limit(kSwing2,-1,0) * kAxleLenMax

 kRefreshTrig	metro	giRefreshRate/ksmps,$NUM/4
 if kRefreshTrig==1 then
  Smess2	sprintfk	"bounds(%d,%d,%d,%d)",kX+kAxleX, kY-(iAxle_Width$NUM*0.5), kAxleLen ,iAxle_Width$NUM
  Sident	sprintfk	"Axle%d",$NUM
  chnset	Smess2,Sident
 endif
 #


 kspeed	rspline	-5,5,0.025,0.1
 kSwing	rspline	-0.95,0.95,0.05,0.2
 kspeed	=	kspeed * krms
 ;kSwing	=	kSwing * krms

 ;         NUM  X   Y SIZE WIDTH R G B Ax_WID AX_LEN
 $WINDMILL(1  '100'150'20'50'255'70'70'8'30)
 ;               SIZE'WIDTH'X'Y
 $CIRCLE_OF_SIX(ksize'kMaxWidth'kX'kY'1)

 ;         NUM  X   Y SIZE WIDTH R G B Ax_WID AX_LEN
 $WINDMILL(2  '300'170'40'80'70'70'255'8'30)
 ;                SIZE'WIDTH'X'Y
 $CIRCLE_OF_SEVEN(ksize'kMaxWidth'kX'kY'2)

 ;         NUM  X   Y SIZE WIDTH R G B Ax_WID AX_LEN
 $WINDMILL(3  '550'220'12'30'255'0'200'4'15)
 ;               SIZE'WIDTH'X'Y
 $CIRCLE_OF_NINE(ksize'kMaxWidth'kX'kY'3)

 ;         NUM  X   Y SIZE WIDTH R G B Ax_WID AX_LEN
 $WINDMILL(4  '600'470'90'200'200'  0'250'12'50)
 ;                SIZE'WIDTH'X'Y
 $CIRCLE_OF_SEVEN(ksize'kMaxWidth'kX'kY'4)
endin





instr	1001	; Print and then hide instructions
 p3	=	3.5

 kalpha		linseg	1,0.5,255,1,255,0.5,0		; Writing transparency
 kalpha2	linseg	255,2,255,1.5,0			; Blacking screen transparency

 if metro(giRefreshRate/ksmps)==1 then			; peg updates or interrupt if mouse has been clicked
  Smess1	sprintfk	"bounds(%d,%d,400,25), fontcolour(255,255,255,%d)", (giPanelWidth*0.5) - 200, (giPanelHeight*0.5)-20, kalpha
  chnset	Smess1,"instructions1"
  Smess2	sprintfk	"colour(0,0,0,%d)", kalpha2
  chnset	Smess2,"Blackout"
 endif

endin


</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
i 1001 0 0
</CsScore>

</CsoundSynthesizer>
; GEN02
; demonstration of writing to GEN02 function tables and also a demonstration of Cabbage's 'gentable' widget
; the example creates an 8-note sequence of notes which can be played and looped in various ways

; The sequen

; Harm.		factor which controls a frequency shift applied to each note. Value here is arbitrary as freq shift is also dependent upon note number. Even number will produce harmonic results, odd numbers inharmonic results. Zero will result in no frequency shift.
; Filt.		shifts all filter cutoff envelopes up or down. (Zero = no shift). Value here is in octaves.
; Res.		resonance of the moogladder lowpass filter
; Dur.		duration of the filter envelope applied to each note (in seconds).
; Echo		amount of synth signal sent to the echo (delay) effect
; Repeats	number of echo/delay repeats. Actually the amount of feedback in the delay effect.
; Time		time spacing of echos. Related to tempo and numbers here are arbitary. 0 = 1/4 beat, 1 = 1/2 beat, 2 = 3/4 beat, 3 = 1 beat, 4 = 5/4 beats and so on
; Direction	three-way toggle switch to choose direction of the sequence looping: Forward, Forward/Backward or Backward
; Tempo		in beats per minute

<Cabbage>
form caption("GEN02"), size(720, 440), scrollbars(0), colour( 50, 50, 50),pluginid("gn02"), guirefresh(32) style("legacy")

#define RSliderStyle1 # colour("yellow"), outlinecolour(100,100,100), trackercolour(150,150,150) #
#define RSliderStyle2 # colour("green"),  outlinecolour(100,100,100), trackercolour(150,150,150) #
#define RSliderStyle3 # colour("blue"),   outlinecolour(100,100,100), trackercolour(150,150,150) #
                                                                                  
gentable bounds(  5,  5, 400,140), identchannel("table1"),  tablenumber(1), tablecolour("yellow"),amprange(36,108,1,1), zoom(-1), tablegridcolour(0,0,0,0), active(1)
gentable bounds(  5,150, 400,140), identchannel("table2"),  tablenumber(2), tablecolour("green"), amprange(0,1,2), zoom(-1), tablegridcolour(0,0,0,0), active(1)
gentable bounds(  5,295, 400,140), identchannel("table3"),  tablenumber(3), tablecolour("blue"),  amprange(1,4,3,1), zoom(-1), tablegridcolour(0,0,0,0), active(1)
label    bounds(  7,  5, 100, 12), text("NOTES"),      align("left"), fontcolour(255,255,255,100)
label    bounds(  7,150, 100, 12), text("AMPLITUDES"), align("left"), fontcolour(255,255,255,100)
label    bounds(  7,295, 100, 12), text("DURATIONS"),  align("left"), fontcolour(255,255,255,100)

image   bounds(  5, 5, 50,430), colour(255,255,255,50), shape("sharp"), identchannel("ScrubberID")

image   bounds(410,  5,400,430), colour( 50, 50, 50), plant("controls"), shape("sharp"), {
rslider bounds(  0,  0, 75, 75), channel("fshift"), text("Harm."),   range(0, 32, 0,1,1),       $RSliderStyle1
rslider bounds( 75,  0, 75, 75), channel("filt"),   text("Filt."),   range(-4.00, 4.00, 0),     $RSliderStyle1
rslider bounds(150,  0, 75, 75), channel("res"),    text("Res."),    range(0, 0.99, 0.7),       $RSliderStyle1
rslider bounds(225,  0, 75, 75), channel("dur"),    text("Dur."),    range(0.10, 4, 1,0.5),     $RSliderStyle1

rslider bounds( 40, 75, 75, 75), channel("echo"),   text("Echo"),    range(0, 1.00, 0.3),       $RSliderStyle2
rslider bounds(115, 75, 75, 75), channel("rpts"),   text("Repeats"), range(0, 1.00, 0.4),       $RSliderStyle2
rslider bounds(190, 75, 75, 75), channel("time"),   text("Time"),    range(0, 7, 3,1,1),        $RSliderStyle2

rslider  bounds(115,160,75,75), channel("tempo"), text("Tempo"), range(10,500,150, 1, 1), $RSliderStyle3
rslider  bounds(190,160,75,75), channel("amp"),   text("Level"), range(0, 1.00, 0.5),     $RSliderStyle3

button  bounds( 10,160, 80,20), text("Bwd.","Bwd."),           channel("bwd"),    value(0), fontcolour:0(255,255,255,50), fontcolour:1(105,255,105,250), radiogroup(1)
button  bounds( 10,180, 80,20), text("Fwd./Bwd.","Fwd./Bwd."), channel("fwdbwd"), value(1), fontcolour:0(255,255,255,50), fontcolour:1(105,255,105,250), radiogroup(1)
button  bounds( 10,200, 80,20), text("Fwd.","Fwd."),           channel("fwd"),    value(0), fontcolour:0(255,255,255,50), fontcolour:1(105,255,105,250), radiogroup(1)
button  bounds( 10,220, 80,20), text("Freeze","Freeze"),       channel("freeze"), value(0), fontcolour:0(255,255,255,50), fontcolour:1(155,155,255,250), radiogroup(1)
button  bounds( 10,240, 80,20), text("Random","Random"),       channel("rnd"),    value(0), fontcolour:0(255,255,255,50), fontcolour:1(125,175,155,250), radiogroup(1)
button  bounds( 10,260, 80,20), text("Stop","Stop"),           channel("stop"),   value(0), fontcolour:0(255,255,255,50), fontcolour:1(255, 55, 55,250), radiogroup(1)
}
</Cabbage>                                                   
                    
<CsoundSynthesizer>                                                                                                 

<CsOptions>                                                     
-dm0 -n -+rtmidi=null -M0                                        
</CsOptions>
                                  
<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	;MAXIMUM AMPLITUDE     

gisine		ftgen	0,0,4096,10,1

; tables for note numbers, velocities and speeds **gentable and ftgen seems unreliable at the moment. Tables created in score instead.**
;ginotes		ftgen	1,0, 8,-2, 48,50,46,48,54,53,51,42
;giamps		ftgen	2,0, 8,-2, 0.8 ,0.37,0.4 ,0.7 ,0.4 ,0.8 ,0.45,0.5
;gispeeds	ftgen	3,0, 8,-2, 2,2,2,1,1,2,1,1

; function table numbers (tables created in score)
ginotes		=	1
giamps		=	2
gispeeds	=	3


/* UDOs */
opcode	scale_i, i, iii					; i-rate version of the 'scale' opcode
	ival,imax,imin	xin
	ival		=	(ival*(imax-imin))+imin
			xout	ival
endop

opcode	FreqShifter,a,aki					; frequency shifter
	ain,kfshift,ifn	xin					;READ IN INPUT ARGUMENTS
	areal, aimag hilbert ain				;HILBERT OPCODE OUTPUTS TWO PHASE SHIFTED SIGNALS, EACH 90 OUT OF PHASE WITH EACH OTHER
	asin 	oscili       1,    kfshift,     ifn,          0
	acos 	oscili       1,    kfshift,     ifn,          0.25	
	;RING MODULATE EACH SIGNAL USING THE QUADRATURE OSCILLATORS AS MODULATORS
	amod1	=		areal * acos
	amod2	=		aimag * asin	
	;UPSHIFTING OUTPUT
	aFS	= (amod1 - amod2)
		xout	aFS				;SEND AUDIO BACK TO CALLER INSTRUMENT
endop

instr	1							; play note sequence
	gktempo	chnget	"tempo"					; read tempo from widget
	kstop	chnget	"stop"
	gkspeed	init	1					; initialise speed value (may be changed later in instrument 3)
	gkdir	chnget	"dir"
	gindx	init	0					; initialise index to the start of the sequence
	ginotecount	init	0				; initialise note counter (counts all the notes that have occured without wrapping)
	ktrig	metro	(gktempo*gkspeed)/60			; metronome
	schedkwhen	ktrig*(1-kstop),0,0,2,0,-1		; trigger instr 2
endin

instr	2
	inote	table	gindx,ginotes				; read note number from table (range: 0 - 1)
	inote	=	int(inote)
	gknote	init	inote             			; set global krate variable for note number
	iamp	table	gindx,giamps				; read amplitude from table (range: 0 - 1)
	gkamp	init	iamp					; set global krate variable for amplitude
	ispeed	table	gindx,gispeeds        			; read speed from table (range: 0 - 1)
	ispeed	limit	ispeed,1,4
	ispeed	=	int(ispeed)
	gkspeed	init	ispeed					; set global krate variable for speed
	idur	chnget	"dur"					; read envelope duration from table
	gkcf	expseg	inote+(60*iamp),idur,inote,1,inote	; create filter cutoff envelope
	kfilt	chnget	"filt"					; read filter envelope shift from widget
	gkcf	limit	cpsmidinn(gkcf+(12*kfilt)),20,20000	; convert envelope from note number to CPS, shift up or down and limit to prevent out of range values

	ibwd	chnget	"bwd"
	ifwdbwd	chnget	"fwdbwd"
	ifwd	chnget	"fwd"
	irnd	chnget	"rnd"
	ifreeze	chnget	"freeze"
	istop	chnget	"stop"
	if ibwd==1 then
	 idir	=	3
	elseif ifwdbwd==1 then
	 idir	=	2
	elseif ifwd==1 then
	 idir	=	1
	elseif irnd==1 then
	 idir	=	(int(random:i(0,2))*2)+1
	 print	idir
	elseif ifreeze==1 then
	 idir	=	0
	elseif istop==1 then
	 idir	=	0
	endif
	


	/* MOVE AND PRINT SCRUBBER HIGHLIGHTER */
	iScrubPos	=	5 + (gindx*50)			; derive x-position
	Smsg	sprintf	"pos(%d,5)",iScrubPos			; create message string
	chnset	Smsg,"ScrubberID"				; send new position to widget
	
		
	/* SHIFT INDEX FOR NEXT NOTE */
	if(idir==1) then					; FWD
	 ginotecount	=	ginotecount+1			; increment note index
	 gindx	wrap	ginotecount,0,ftlen(ginotes)		; wrap out of range values
	 gindx	=	int(gindx)
	elseif(idir==2) then					; FWD/BWD
	 ginotecount	=	ginotecount+1			; increment note index 
	 gindx	mirror	ginotecount,0,ftlen(ginotes)-1		; mirror out of range values
	 gindx	=	int(gindx)
	elseif(idir==3) then					; BWD
	 ginotecount	=	ginotecount-1			; decrement note index 
	 gindx	wrap	ginotecount,-0.5,ftlen(ginotes)-0.5	; wrap out of range values
	 gindx	=	int(gindx)
	endif
endin

instr	3
	kres		chnget	"res"				; read in widgets...
	klev		chnget	"amp"
	kecho		chnget	"echo"
	krpts		chnget	"rpts"
	kfshift		chnget	"fshift"
	kporttime	linseg	0,0.001,1			; portamento time ramps up quickly from zero, holds at '1'                                 
	knote	portk	gknote,kporttime*0.001			; portamento smoothing to note number changes         
	kcf	portk	gkcf,kporttime*0.001			; portamento smoothing to filter cutoff frequency (prevents clicks resulting from discontinuities)
	kamp	portk	gkamp,kporttime				; portamento smoothing to amplitude (prevents clicks resulting from discontinuities)
	a1	vco2	gkamp*klev,cpsmidinn(knote),0,0.5	; VCO audio signal generator
	a1	moogladder	a1,kcf,kres			; moogladder lowpass filter                                                                                                                                                                                                                
	a1	FreqShifter	a1,cpsmidinn(knote)*kfshift*0.5,gisine	; frequency shift applied to audio signal (using a UDO: see above). Frequency is a function of note number of the sequence and the on-screen control 'harm.'
	idry	ftgen	0,0,1024,7,1,512,1,512,0		; table used to shape amplitude control of the 'dry' signal level
	kdry	table	kecho,idry,1				; read 'dry' signal level
	aR	=	a1 * klev * kdry			; scale audio signal with 'Level' and 'Echo' controls
	aL	delay	aR,0.002				; slightly delay audio signal (used to create a stereo effect)
		outs	aL,aR					; send audio to outputs (left channel slightly delayed)
	
	/* DELAY EFFECT */
	ktime	chnget	"time"					; read delay time from widget (arbitrary value)
	itimes	ftgen	0,0,8, -2, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2	; table of delay time multipliers
	kmult	table	ktime,itimes				; read delay time multiplier
	ktempo	portk	gktempo,kporttime			; long portamento smoothing to changes in tempo
	kmult	portk	kmult,kporttime*0.001			; very short portamento smoothing to changes to delay time using the 'Time' widget
	kdeltim	=	(60/ktempo)*kmult			; calculate delay time
	adeltim	interp	kdeltim					; convert to a-rate with interpolation  
	abuf	delayr	(60*2)/10				; create an audio delay buffer
	atapL	deltapi	adeltim					; tap delay buffer
		delayw	(aL*kecho)+(atapL*krpts)		; write audio into delay buffer. Add in a bit of feedback
	abuf	delayr	(60*2)/10				; create an audio delay buffer
	atapR	deltapi	adeltim					; tap delay buffer
		delayw	(aR*kecho)+(atapR*krpts)		; write audio into delay buffer. Add in a bit of feedback
		outs	atapL,atapR				; send audio to outputs (right channel slightly delayed)
endin                                                                                                                     


</CsInstruments>

<CsScore>
; tables for note numbers, velocities and speeds
f 1 0  8 -2  48 50 46 48 54 53 51 42
f 2 0  8 -2  0.8  0.37 0.4  0.7  0.4  0.8  0.45 0.5
f 3 0  8 -2  2 2 2 1 1 2 1 1

i 1 0 [3600*24*7]		; instrument to play note sequence
i 3 0 [3600*24*7]		; instrument to play note sequence
</CsScore>                            

</CsoundSynthesizer>
; GEN05.csd
; Demonstration of GEN05
; Written by Iain McCurdy, 2014
; 
; GEN05 generates breakpoint functions by joining user-defined values using exponential curves each of user-definable duration.
; Node values must be non-zero and alike in sign.
; 
; In this example the user can input node values of zero but these will be offset using the value of the 'Offset' control.
; It can be observed how changing this offset value will vary the curvature of segments.
; 
; An audio test generator uses this function table as a repeating amplitude envelope. 
; The offset value is subtracted so that the envelope can experience values of zero. 

<Cabbage>
form caption("GEN05"), size(245, 390), pluginid("gn05"), colour(13, 50, 67,50) style("legacy")

label    bounds( 10,  8, 95, 15), text("Edit Method:")
combobox bounds(105,  5, 80, 20), text("sliders","drawing"), value(1), channel("mode")

gentable bounds( 10, 30, 225, 120), tablenumber(1), tablecolour("silver"), identchannel("table"), amprange(0,1.1,1), zoom(-1), active(1)

rslider bounds( 10,150, 50, 70), channel("val1"), text("Value.1"), textBox(1), range(0, 1, 0), colour(100,130,130,250), trackercolour("silver")
rslider bounds( 70,150, 50, 70), channel("val2"), text("Value.2"), textBox(1), range(0, 1, 1), colour(100,130,130,250), trackercolour("silver")
rslider bounds(130,150, 50, 70), channel("val3"), text("Value.3"), textBox(1), range(0, 1, 0), colour(100,130,130,250), trackercolour("silver")

rslider bounds(190,150, 50, 70), channel("offset"), text("Offset"), textBox(1), range(0.0001, 0.1, 0.001), colour(200,130,130, 50), trackercolour("silver")

rslider bounds( 40,225, 50, 70), channel("dur1"), text("Dur.1"), textBox(1), range(0, 4096, 0, 1, 1), colour(130,100,130,250), trackercolour("silver")
rslider bounds(100,225, 50, 70), channel("dur2"), text("Dur.2"), textBox(1), range(0, 4096, 4096, 1, 1), colour(130,100,130,250), trackercolour("silver")
              
line     bounds( 10,300,225,  2), colour("Grey")
checkbox bounds( 15,310,80, 17), channel("TestGen"), text("Test"),  value(1), colour("yellow"), shape("square")
rslider  bounds( 60,310, 70, 70), channel("speed"), text("Speed"), textBox(1), range(0.25, 8.00, 1,0.5,0.001),   colour(250,230,250,250), trackercolour("silver")
rslider  bounds(120,310, 70, 70), channel("freq"),  text("Freq."), textBox(1), range(50, 5000, 500,0.5,0.1),     colour(250,230,250,250), trackercolour("silver")
rslider  bounds(180,310, 70, 70), channel("lev"),   text("Level"), textBox(1), range(0, 1.00, 0.5),              colour(250,230,250,250), trackercolour("silver")

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	;MAXIMUM AMPLITUDE

instr	1
	kmode	chnget	"mode"
	if kmode==1 then

		; read in widgets
		gkval1	chnget	"val1"
		gkval2	chnget	"val2"
		gkval3	chnget	"val3"
        	
		gkdur1	chnget	"dur1"
		gkdur2	chnget	"dur2"
        	
		gkoffset	chnget	"offset"
		gkoffset	init	0.001
		
		; if any of the variables in the input list are changed, a momentary '1' trigger is generated at the output. This trigger is used to update function tables.
		ktrig	changed		gkval1,gkval2,gkval3,gkdur1,gkdur2,gkoffset
		if ktrig==1 then
		 reinit	UPDATE
		endif
		UPDATE:
		; Update function table
		  if	(i(gkdur1)+i(gkdur2))>4096 then				; if sum of segments exceeds table size...
		   idur1	=	i(gkdur1)* (4096/(i(gkdur1)+i(gkdur2)))	; ...scale segment durations down
		   idur2	=	i(gkdur2)* (4096/(i(gkdur1)+i(gkdur2)))
		   irem		=	0					; remainder duration of table
		  else								; if sum of segments is less than table size...
		   idur1	=	i(gkdur1)
		   idur2	=	i(gkdur2)
		   irem		=	4096 - (i(gkdur1) + i(gkdur2))		; remainder duration of table
		  endif
		gi1	ftgen	1, 0,   4096, -5, i(gkval1)+i(gkoffset), idur1, i(gkval2)+i(gkoffset), idur2, i(gkval3)+i(gkoffset), irem, i(gkoffset)
		chnset	"tablenumber(1)", "table"	; update table display	
		rireturn
	endif

	kTestGen	chnget	"TestGen"				; test generator on/off
	kspeed	chnget	"speed"
	kamp	chnget	"lev"
	kfreq	chnget	"freq"
	aphasor	phasor	kspeed
	aenv	tablei	aphasor,gi1,1
	asig	vco2	0.4*kamp*kTestGen,kfreq,4,0.5			; triangle audio wave
	asig	=	asig * (aenv - gkoffset)			; remove GEN05 offset
		outs	asig, asig
endin

</CsInstruments>

<CsScore>
; create the function table
f 1 0    4096 -16  1 0 0
; play instrument 1 for 1 hour
i 1 0 3600
</CsScore>

</CsoundSynthesizer>
; GEN07.csd
; Demonstration of GEN07
; Written by Iain McCurdy, 2014
;
; GEN07 generates breakpoint functions by joining user-defined values using straight lines each of user-definable duration.
; The user can toggle between using the sliders to input data for the envelope or by drawing and clicking and dragging on 
; the actual waveform. 
;
; An audio test generator uses this function table as a repeating amplitude envelope. 
; The offset value is subtracted so that the envelope can experience values of zero. 

<Cabbage>
form caption("GEN07"), size(250,400), pluginid("gn07"), colour(13, 50, 67,50) style("legacy")

label    bounds( 10,  8, 95, 15), text("Edit Method:")
combobox bounds(105,  5, 80, 20), text("sliders","drawing"), value(1), channel("mode")

gentable bounds( 15, 30, 225, 120), tablenumbers(1), tablecolour("blue"), tablebackgroundcolour("white"), tablegridcolour(230,230,230), identchannel("table"), amprange(0,1,1), zoom(-1), active(1)
label    bounds(  0, 26,15,9), text("1")
label    bounds(  0, 38,15,9), text("0.9")
label    bounds(  0, 50,15,9), text("0.8")
label    bounds(  0, 62,15,9), text("0.7")
label    bounds(  0, 74,15,9), text("0.6")
label    bounds(  0, 86,15,9), text("0.5")
label    bounds(  0, 99,15,9), text("0.4")
label    bounds(  0,110,15,9), text("0.3")
label    bounds(  0,122,15,9), text("0.2")
label    bounds(  0,134,15,9), text("0.1")
label    bounds(  0,146,15,9), text("0")
label    bounds( 31,151,15,9), text("0.1")
label    bounds( 54,151,15,9), text("0.2")
label    bounds( 77,151,15,9), text("0.3")
label    bounds( 99,151,15,9), text("0.4")
label    bounds(122,151,15,9), text("0.5")
label    bounds(145,151,15,9), text("0.6")
label    bounds(167,151,15,9), text("0.7")
label    bounds(189,151,15,9), text("0.8")
label    bounds(212,151,15,9), text("0.9")
label    bounds(232,151,15,9), text("1")

rslider  bounds( 40,160, 50, 70), channel("val1"), text("Value.1"), textBox(1), range(0, 1, 0), colour(100,130,130,250), trackercolour("silver")
rslider  bounds(100,160, 50, 70), channel("val2"), text("Value.2"), textBox(1), range(0, 1, 1), colour(100,130,130,250), trackercolour("silver")
rslider  bounds(160,160, 50, 70), channel("val3"), text("Value.3"), textBox(1), range(0, 1, 0), colour(100,130,130,250), trackercolour("silver")

rslider  bounds( 70,235, 50, 70), channel("dur1"), text("Dur.1"), textBox(1), range(0, 1, 0.2, 1, 0.001), colour(130,100,130,250), trackercolour("silver")
rslider  bounds(130,235, 50, 70), channel("dur2"), text("Dur.2"), textBox(1), range(0, 1, 0.8, 1, 0.001), colour(130,100,130,250), trackercolour("silver")

line     bounds( 10,310,225,  2), colour("Grey")
checkbox bounds( 15,320,80, 17), channel("TestGen"), text("Test"),  value(1), colour("yellow"), shape("square")
rslider  bounds( 60,320, 70, 70), channel("speed"), text("Speed"), textBox(1), range(0.25, 8.00, 1,0.5,0.001),   colour(250,230,250,250), trackercolour("silver")
rslider  bounds(120,320, 70, 70), channel("freq"),  text("Freq."), textBox(1), range(50, 5000, 500,0.5,0.1),     colour(250,230,250,250), trackercolour("silver")
rslider  bounds(180,320, 70, 70), channel("lev"),   text("Level"), textBox(1), range(0, 1.00, 0.5),              colour(250,230,250,250), trackercolour("silver")

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	;MAXIMUM AMPLITUDE

giTabLen	=	1024

instr	1
	kmode	chnget	"mode"
	if kmode==1 then

		; read in widgets
		gkval1	chnget	"val1"
		gkval2	chnget	"val2"
		gkval3	chnget	"val3"
        	
		gkdur1	chnget	"dur1"
		gkdur2	chnget	"dur2"
		
		gkdur1	*=	giTabLen
		gkdur2	*=	giTabLen
		
		; if any of the variables in the input list are changed, a momentary '1' trigger is generated at the output. This trigger is used to update function tables.
		ktrig	changed		gkval1,gkval2,gkval3,gkdur1,gkdur2
		if ktrig==1 then
		 reinit	UPDATE
		endif
		UPDATE:
		; Update function table
		  if	(i(gkdur1)+i(gkdur2))>giTabLen then				; if sum of segments exceeds table size...
		   idur1	=	i(gkdur1)* (giTabLen/(i(gkdur1)+i(gkdur2)))	; ...scale segment durations down
		   idur2	=	i(gkdur2)* (giTabLen/(i(gkdur1)+i(gkdur2)))
		   irem		=	0					; remainder duration of table
		  else								; if sum of segments is less than table size...
		   idur1	=	i(gkdur1)
		   idur2	=	i(gkdur2)
		   irem		=	giTabLen - (i(gkdur1) + i(gkdur2))		; remainder duration of table
		  endif
		gi1	ftgen	1, 0,   giTabLen, -7, i(gkval1), idur1, i(gkval2), idur2, i(gkval3), irem, 0
		chnset	"tablenumber(1)", "table"	; update table display	
		rireturn
	endif

	kTestGen	chnget	"TestGen"				; test generator on/off
	kspeed	chnget	"speed"
	kamp	chnget	"lev"
	kfreq	chnget	"freq"
	aphasor	phasor	kspeed
	aenv	tablei	aphasor,gi1,1
	asig	vco2	0.4*kamp*kTestGen,kfreq,4,0.5			; triangle audio wave
	asig	=	asig * aenv					; 
		outs	asig, asig
endin

</CsInstruments>

<CsScore>
; play instrument 1 for 1 hour
i 1 0 3600
</CsScore>

</CsoundSynthesizer>
; GEN08.csd
; Written by Iain McCurdy, 2013

; Demonstration of GEN08 (generates as smooth a line as possible between a sequence of user-defined break points)
; The user defines a number of nodes (the amplitude values at these nodes are modulated randomly)
; Random value sequence can be wrapped so that values are repeated for higher nodes.

; Nodes		-	number of nodes
; Wrap		-	number of nodes before wrap-around
; Speed		-	speed of random modulation
; Level		-	amplitude level of the synthesizer
; Reverb	-	amount of reverb 
; Env.Shape	-	Duration of attack and release of synthesizer notes 

<Cabbage>
form caption("GEN08"), size(410, 300), pluginid("gn08"), colour(120,70,170,150) style("legacy")

gentable bounds(  5,  5, 400, 120), identchannel("table1"), tablenumber(1), tablecolour("yellow"), amprange(-1,1,1), outlinethickness(2), tablegridcolour(0,0,0,0), zoom(-1), fill(1)

rslider bounds( 15,130, 80, 80), channel("nodes"), text("Nodes"), textbox(1), valuetextbox(1), range(1, 16, 16,1,1),        colour(160,110,210,200), trackercolour("yellow"), outlinecolour(100,100,100), fontcolour("white"), textcolour("white")
rslider bounds( 75,130, 80, 80), channel("wrap"), text("Repeat"), textbox(1), valuetextbox(1), range(2, 16,16,1,1),         colour(160,110,210,200), trackercolour("yellow"), outlinecolour(100,100,100), fontcolour("white"), textcolour("white")
rslider bounds(135,130, 80, 80), channel("speed"), text("Speed"), textbox(1), valuetextbox(1), range(1, 5.00, 1),           colour(160,110,210,200), trackercolour("yellow"), outlinecolour(100,100,100), fontcolour("white"), textcolour("white")
rslider bounds(195,130, 80, 80), channel("level"), text("Level"), textbox(1), valuetextbox(1), range(0, 1.00,0.1),          colour(160,110,210,200), trackercolour("yellow"), outlinecolour(100,100,100), fontcolour("white"), textcolour("white")
rslider bounds(255,130, 80, 80), channel("reverb"), text("Reverb"), textbox(1), valuetextbox(1), range(0, 1.00,0.1),        colour(160,110,210,200), trackercolour("yellow"), outlinecolour(100,100,100), fontcolour("white"), textcolour("white")
rslider bounds(315,130, 80, 80), channel("EnvShape"), text("Env.Shape"), textbox(1), valuetextbox(1), range(0, 2.00,0.5),   colour(160,110,210,200), trackercolour("yellow"), outlinecolour(100,100,100), fontcolour("white"), textcolour("white")

keyboard bounds(  0,220,410, 80)
</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	8	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE
		massign	0,3	; send all midi notes to instr 3 
		zakinit	16,16

; default waveform		
giwave	ftgen	1,0, 512, 8, 0, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16,rnd(2)-1, 512/16, 0

instr	1
	; read in widgets
	gknodes	chnget	"nodes"
	gknodes	init	16
	kwrap	chnget	"wrap"
	kwrap	init	16
	kspeed		chnget	"speed"
	gklevel		chnget	"level"
	gkreverb	chnget	"reverb"
	gkEnvShape	chnget	"EnvShape"
	
	iftlen	=	ftlen(1)		; length of function  table


; define a macro that will be used create a random amplitude
#define	RandStr(N)	
#
	kstr$N	rspline	-0.9,0.9,0.1*kspeed,1*kspeed
		zkw	kstr$N, $N
#
; expand macro multiple times
$RandStr(1)
$RandStr(2)
$RandStr(3)
$RandStr(4)
$RandStr(5)
$RandStr(6)
$RandStr(7)
$RandStr(8)
$RandStr(9)
$RandStr(10)
$RandStr(11)
$RandStr(12)
$RandStr(13)
$RandStr(14)
$RandStr(15)
$RandStr(16)


; define macro for reading random amplitude values		
#define	ReadStr(N)
#
kndx	wrap	$N,1,kwrap
kstr$N	zkr	kndx
#
; expand macro multiple times
$ReadStr(1) 
$ReadStr(2) 
$ReadStr(3) 
$ReadStr(4) 
$ReadStr(5) 
$ReadStr(6) 
$ReadStr(7) 
$ReadStr(8) 
$ReadStr(9) 
$ReadStr(10)
$ReadStr(11)
$ReadStr(12)
$ReadStr(13)
$ReadStr(14)
$ReadStr(15)
$ReadStr(16)

	if metro(200)==1 then	; peg rate of update. Tables updated at this rate. If too slow, glitching will be heard in the output, particularly if random movement speed is high. If too high CPU performance will suffer.
	 reinit	UPDATE
	endif
	UPDATE:
	
	; generation of wave for each configuration of number of nodes
	; 1 node
	#define	N	#1#
	if i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1),   iftlen/($N+1),   0

	#define	N	#2#
	; 2 nodes
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2),   iftlen/($N+1),   0

	#define	N	#3#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3),   iftlen/($N+1),   0

	#define	N	#4#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4),   iftlen/($N+1),   0

	#define	N	#5#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5),   iftlen/($N+1),   0

	#define	N	#6#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6),   iftlen/($N+1),   0

	#define	N	#7#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7),   iftlen/($N+1),   0

	#define	N	#8#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8),   iftlen/($N+1),   0

	#define	N	#9#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8), iftlen/($N+1),i(kstr9),   iftlen/($N+1),   0

	#define	N	#10#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8), iftlen/($N+1),i(kstr9), iftlen/($N+1),i(kstr10),   iftlen/($N+1),   0

	#define	N	#11#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8), iftlen/($N+1),i(kstr9), iftlen/($N+1),i(kstr10), iftlen/($N+1),i(kstr11),   iftlen/($N+1),   0

	#define	N	#12#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8), iftlen/($N+1),i(kstr9), iftlen/($N+1),i(kstr10), iftlen/($N+1),i(kstr11), iftlen/($N+1),i(kstr12),   iftlen/($N+1),   0

	#define	N	#13#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8), iftlen/($N+1),i(kstr9), iftlen/($N+1),i(kstr10), iftlen/($N+1),i(kstr11), iftlen/($N+1),i(kstr12), iftlen/($N+1),i(kstr13),   iftlen/($N+1),   0

	#define	N	#14#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8), iftlen/($N+1),i(kstr9), iftlen/($N+1),i(kstr10), iftlen/($N+1),i(kstr11), iftlen/($N+1),i(kstr12), iftlen/($N+1),i(kstr13), iftlen/($N+1),i(kstr14),   iftlen/($N+1),   0

	#define	N	#15#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8), iftlen/($N+1),i(kstr9), iftlen/($N+1),i(kstr10), iftlen/($N+1),i(kstr11), iftlen/($N+1),i(kstr12), iftlen/($N+1),i(kstr13), iftlen/($N+1),i(kstr14), iftlen/($N+1),i(kstr15),   iftlen/($N+1),   0

	#define	N	#16#
	elseif i(gknodes)==$N then
	 giwave	ftgen	1,0, iftlen, 8, 0, iftlen/($N+1),i(kstr1), iftlen/($N+1),i(kstr2), iftlen/($N+1),i(kstr3), iftlen/($N+1),i(kstr4), iftlen/($N+1),i(kstr5), iftlen/($N+1),i(kstr6), iftlen/($N+1),i(kstr7), iftlen/($N+1),i(kstr8), iftlen/($N+1),i(kstr9), iftlen/($N+1),i(kstr10), iftlen/($N+1),i(kstr11), iftlen/($N+1),i(kstr12), iftlen/($N+1),i(kstr13), iftlen/($N+1),i(kstr14), iftlen/($N+1),i(kstr15), iftlen/($N+1),i(kstr16),   iftlen/($N+1),   0

	endif
	
	rireturn

	if metro(32)==1 then			; peg table display rate. Audio quality is unaffected by this.
	 chnset	"tablenumber(1)", "table1"	; update table display	
	endif
endin

gaSendL,gaSendR	init	0	; initialise reverb send variables

instr	3
	icps	cpsmidi					; CPS from midi note played
	iamp	ampmidi	1				; amplitude from midi note velocity 
	
	a1	oscili	iamp*gklevel,icps/4,giwave	; audio oscillator read GEN08 wave created
	a1	*=		oscili:a(1,(icps/4)+oscili:a(icps/100,icps/4,giwave),giwave)	; ring modulate it with itself
		
	a2	delay	-a1,0.01

	aenv	transegr	0,2*i(gkEnvShape),-4,1,4*i(gkEnvShape),-4,0	; amplitude envelope

	a1	=	a1 * aenv			; apply envelope
	a2	=	a2 * aenv			; apply envelope
	
	gaSendL	=	gaSendL + (a1*gkreverb)
	gaSendR	=	gaSendR + (a2*gkreverb)
		outs	a1*(1-gkreverb), a2*(1-gkreverb)	; send audio to outputs
endin


instr	Reverb
	a1,a2	reverbsc	gaSendL,gaSendR, 0.85, 8000
		outs		a1,a2
		clear		gaSendL,gaSendR
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
i "Reverb" 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; GEN08_Envelopes.csd
; Written by Iain McCurdy, 2015.

; A method of editing GEN08 function tables by clicking and dragging breakpoints.
; GEN08 generates function tables by drawing the smoothest possible curve between defined breakpoints.
; Note that this can often result in the function extending well above the highest breakpoint or well below the lowest breakpoint.
; In the example when the functions are used as amplitude envelopes they are clipped at zero and 1 to prevent out of range amplitudes.
; It is also to normalise the function to fit within the range 0 to 1. In this case the curve will probably not pass through the breakpoints.

; In this example two envelopes are created: one with 3 breakpoints and the other with 4.
; The first and last breakpoints can only be moved up or down.
; The two envelope types are encapsulated within UDOs to facilitate easy transplantation and reuse.

; Input arguments for the 3-breakpoint envelope are: knorm,iTabX,iTabY,iTabWidth,iTabHeight,iNodeSize,ifn,STabIdent,Snode1,Snode2,Snode3
; iTabX		-	table X location in pixels (from upper panel edge)
; iTabY		-	table Y location in pixels (from left panel edge)
; iTabWidth	-	table width in pixels
; iTabHeight	-	table height in pixels
; iNodeSize	-	node widget radius in pixels
; ifn		-	function table used to store the ADSR (only used for GUI - output values used to create envelope)
; STabIdent	-	a string representing the ident channel of the gentable
; Snode1	-	a string representing the ident channel of the first node
; Snode2	-	a string representing the ident channel of the second node
; Snode3	-	a string representing the ident channel of the third node

; The output arguments are: gky1,gkx2,gky2,gky3
; gky1		-	first breakpoint value	
; gkx2		-	second breakpoint location (0 - 1)
; gky2		-	second breakpoint value	
; gky3		-	third breakpoint value

; The input arguments for the 4-breakpoint envelope are the same except for the addition of an extra node ident channel
; The output arguments for the 4-breakpoint envelope are the same except for the addition of the location and value of the additional breakpoint


<Cabbage>
form caption("GEN08 Envelopes"), size(800, 510), pluginid("G8En"), guirefresh(32), colour(0,0,0) style("legacy")

gentable bounds( 10,  5,380,290), tablenumber(1), tablecolour("silver"), identchannel("table1"), amprange(0,1,1), zoom(-1), tablegridcolour(0,0,0,0), tablebackgroundcolour(20,20,20), outlinethickness(2), identchannel("table1")
label bounds(10, 5,140,12), text("3 Break-point Envelope"), align("left")

gentable bounds(410,  5,380,290), tablenumber(2), tablecolour("silver"), identchannel("table2"), amprange(0,1,2), zoom(-1), tablegridcolour(0,0,0,0), tablebackgroundcolour(20,20,20), outlinethickness(2), identchannel("table2")
label bounds(410, 5,140,12), text("4 Break-point Envelope"), align("left")

label   bounds( -5, -5, 10, 10), text("1"), colour("white"), fontcolour("black"), identchannel("node1")
label   bounds( -5, -5, 10, 10), text("2"), colour("white"), fontcolour("black"), identchannel("node2")
label   bounds( -5, -5, 10, 10), text("3"), colour("white"), fontcolour("black"), identchannel("node3")

nslider  bounds( 10,300, 50,30), text("Value 1"), channel("aV1"), range(0,1,0,1,0.001)
nslider  bounds( 60,300, 50,30), text("Dur. 1"),  channel("aD1"), range(0,1024,0,1,1)
nslider  bounds(110,300, 50,30), text("Value 2"), channel("aV2"), range(0,1,0,1,0.001)
nslider  bounds(160,300, 50,30), text("Dur. 2"),  channel("aD2"), range(0,1024,0,1,1)
nslider  bounds(210,300, 50,30), text("Value 3"), channel("aV3"), range(0,1,0,1,0.001)
nslider  bounds(290,300, 50,30), text("Max"), channel("aMax"), range(0,1000,0,1,0.001)
nslider  bounds(340,300, 50,30), text("Min"), channel("aMin"), range(-1000,0,0,1,0.001)

label   bounds( -5, -5, 10, 10), text("1"), colour("white"), fontcolour("black"), identchannel("node4")
label   bounds( -5, -5, 10, 10), text("2"), colour("white"), fontcolour("black"), identchannel("node5")
label   bounds( -5, -5, 10, 10), text("3"), colour("white"), fontcolour("black"), identchannel("node6")
label   bounds( -5, -5, 10, 10), text("4"), colour("white"), fontcolour("black"), identchannel("node7")

nslider  bounds(410,300, 50,30), text("Value 1"), channel("bV1"), range(0,1,0,1,0.001)
nslider  bounds(460,300, 50,30), text("Dur. 1"),  channel("bD1"), range(0,1024,0,1,1)
nslider  bounds(510,300, 50,30), text("Value 2"), channel("bV2"), range(0,1,0,1,0.001)
nslider  bounds(560,300, 50,30), text("Dur. 2"),  channel("bD2"), range(0,1024,0,1,1)
nslider  bounds(610,300, 50,30), text("Value 3"), channel("bV3"), range(0,1,0,1,0.001)
nslider  bounds(660,300, 50,30), text("Dur. 2"),  channel("bD3"), range(0,1024,0,1,1)
nslider  bounds(710,300, 50,30), text("Value 3"), channel("bV4"), range(0,1,0,1,0.001)
nslider  bounds(690,335, 50,30), text("Max"),     channel("bMax"), range(0,1000,0,1,0.001)
nslider  bounds(740,335, 50,30), text("Min"),     channel("bMin"), range(-1000,0,0,1,0.001)

image bounds( 10,375,780,1), shape("ellipse")

checkbox bounds( 10,350,100, 15), channel("norm"), text("Normalise")

label    bounds(150,390, 90,15) text("Synth uses:"), align("right")
combobox bounds(240,389,130,17), text("3 point envelope","4 point envelope"), channel("env")

hslider  bounds(405,387,390,10), channel("dur"), range(0.2,10,1,0.5,0.001)
label    bounds(405,399,380,12), text("Total Duration")

keyboard bounds( 10, 420, 780, 80)
</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	32
nchnls 		= 	2
0dbfs		=	1
massign	0,2	; all midi plays instr 2



	      opcode         tabmaxk,kk,i		; UDO for deriving maximum value and its index from a table
itabnum       xin     
inumitems     =              ftlen(itabnum)             ; derive number of items in table
kmax          table          0,itabnum                  ; maximum value starts as first table items
kcount        =              1                          ; counter starts at 1 (we've already read item 0)
loop:                                                   ; loop 1 beginning
kval          table          kcount,itabnum             ; read value from table
if kval>=kmax then					; if value read from table is higher than (or equal to) current maximum...
 kmax	=	kval					; ...values becomes new maximum
 kndx	=	kcount					; index of maximum becomes the index of this value
endif							; end of conditional branch
              loop_lt        kcount,1,inumitems,loop    ; conditionally loop back
	      xout           kmax,kndx			; return maximium value to caller instrument
              endop


	      opcode         tabmink,kk,i		; UDO for deriving maximum value and its index from a table
itabnum       xin     
inumitems     =              ftlen(itabnum)             ; derive number of items in table
kmin          table          0,itabnum                  ; maximum value starts as first table items
kcount        =              1                          ; counter starts at 1 (we've already read item 0)
loop:                                                   ; loop 1 beginning
kval          table          kcount,itabnum             ; read value from table
if kval<kmin then					; if value read from table is higher than (or equal to) current maximum...
 kmin	=	kval					; ...values becomes new maximum
 kndx	=	kcount					; index of maximum becomes the index of this value
endif							; end of conditional branch
              loop_lt        kcount,1,inumitems,loop    ; conditionally loop back
	      xout           kmin,kndx			; return maximium value to caller instrument
              endop


opcode	GEN08_3NodeEnvelope,kkkk,kiiiiiiSSSS
 knorm, iTabX, iTabY, iTabWidth, iTabHeight, iNodeSize, ifn, STabIdent, Snode1, Snode2, Snode3	xin

 kMOUSE_X		chnget	"MOUSE_X"
 kMOUSE_Y		chnget	"MOUSE_Y"
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"
 
 ky1	init	iTabY+iTabHeight-(iNodeSize*0.5)
 kx2	init	iTabX+(iTabWidth*0.5)-(iNodeSize*0.5)
 ky2	init	(iTabHeight*0.5)-(iNodeSize*0.5)
 ky3	init	iTabY+iTabHeight-(iNodeSize*0.5)
 kin1,kin2,kin3	init	0

 kclick		trigger	kMOUSE_DOWN_LEFT,0.5,2
 
 ; test whether click is in widget or not
 if kclick==1 then
  kin1	=	(kMOUSE_X>iTabX-(iNodeSize*0.5)            && kMOUSE_X<iTabX+(iNodeSize*0.5)           && kMOUSE_Y>iTabY+ky1-(iNodeSize*0.5) && kMOUSE_Y<iTabY+ky1+(iNodeSize*0.5) && kMOUSE_DOWN_LEFT==1) ? 1 : 0
  kin2	=	(kMOUSE_X>kx2-(iNodeSize)                  && kMOUSE_X<kx2+(iNodeSize)                 && kMOUSE_Y>iTabY+ky2-(iNodeSize*0.5) && kMOUSE_Y<iTabY+ky2+(iNodeSize*0.5) && kMOUSE_DOWN_LEFT==1) ? 1 : 0
  kin3	=	(kMOUSE_X>iTabX+iTabWidth-(iNodeSize*0.5)  && kMOUSE_X<iTabX+iTabWidth+(iNodeSize*0.5) && kMOUSE_Y>iTabY+ky3-(iNodeSize*0.5) && kMOUSE_Y<iTabY+ky3+(iNodeSize*0.5) && kMOUSE_DOWN_LEFT==1) ? 1 : 0
 endif
 
 ; click and drag
 if kin1==1 then
  ky1	limit	kMOUSE_Y - (iNodeSize*0.5), iTabY-(iNodeSize*0.5), iTabY+iTabHeight-(iNodeSize*0.5)
 endif
 if kin2==1 then
  kx2	limit	kMOUSE_X - (iNodeSize*0.5), iTabX-(iNodeSize*0.5), iTabX+iTabWidth-(iNodeSize*0.5)
  ky2	limit	kMOUSE_Y - (iNodeSize*0.5), iTabY-(iNodeSize*0.5), iTabY+iTabHeight-(iNodeSize*0.5)
 endif
 if kin3==1 then
  ky3	limit	kMOUSE_Y - (iNodeSize*0.5), iTabY-(iNodeSize*0.5), iTabY+iTabHeight-(iNodeSize*0.5)
 endif
  
 kmetro	metro	ksmps

 if kmetro==1 then				; slow down checking
  if changed(knorm)==1 then			; normalise check box changed
   reinit REBUILD_TABLE
  endif
  ktrig	changed	ky1				; node 1 (beginning) moved
  if ktrig==1 then
   Smsg	sprintfk	"pos(%d,%d)", iTabX-(iNodeSize*0.5), ky1
   	chnset	Smsg,Snode1
   reinit REBUILD_TABLE
  endif
  ktrig	changed	kx2,ky2				; node 2 moved
  if ktrig==1 then
   Smsg	sprintfk	"pos(%d,%d)", kx2, ky2
   	chnset	Smsg,Snode2
   reinit REBUILD_TABLE
  endif
  ktrig	changed	ky3				; node 3 (end) moved
  if ktrig==1 then
   Smsg	sprintfk	"pos(%d,%d)", iTabX+iTabWidth-(iNodeSize*0.5), ky3
   	chnset	Smsg,Snode3
   reinit REBUILD_TABLE
  endif
  
  REBUILD_TABLE:
  inorm		=	(i(knorm)*2)-1
  iy1		limit	1-((i(ky1)+(iNodeSize*0.5)-iTabY)/iTabHeight), 0, 1
  ix2		limit	((i(kx2)+(iNodeSize*0.5)-iTabX)/iTabWidth * ftlen(ifn)),1,1022
  iy2		limit	1-((i(ky2)+(iNodeSize*0.5)-iTabY)/iTabHeight), 0, 1
  iy3		limit	1-((i(ky3)+(iNodeSize*0.5)-iTabY)/iTabHeight), 0, 1
  gitable1	ftgen	ifn,0,1024,8*inorm,	iy1, ix2, iy2, 1023-ix2, iy3
  Smsg		sprintf	"tablenumber(%d)",ifn
  	 	chnset	Smsg,STabIdent
  rireturn
 endif

 ky1o	=	1-((ky1+iTabY-(iNodeSize*0.5))/iTabHeight)
 kx2o	=	(kx2-(iNodeSize*0.5))/iTabWidth
 ky2o	=	1-((ky2+iTabY-(iNodeSize*0.5))/iTabHeight)
 ky3o	=	1-((ky3+iTabY-(iNodeSize*0.5))/iTabHeight)
 xout	ky1o,kx2o,ky2o,ky3o

endop














opcode	GEN08_4NodeEnvelope,kkkkkk,kiiiiiiSSSSS
 knorm, iTabX, iTabY, iTabWidth, iTabHeight, iNodeSize, ifn, STabIdent, Snode1, Snode2, Snode3, Snode4	xin

 kMOUSE_X		chnget	"MOUSE_X"
 kMOUSE_Y		chnget	"MOUSE_Y"
 kMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"
 
 ky1	init	iTabY+iTabHeight-(iNodeSize*0.5)
 kx2	init	iTabX+(iTabWidth*0.33)-(iNodeSize*0.5)
 ky2	init	(iTabHeight*0.5)-(iNodeSize*0.5)
 kx3	init	iTabX+(iTabWidth*0.67)-(iNodeSize*0.5)
 ky3	init	(iTabHeight*0.5)-(iNodeSize*0.5)
 ky4	init	iTabY+iTabHeight-(iNodeSize*0.5)
 kin1,kin2,kin3,kin4	init	0

 kclick		trigger	kMOUSE_DOWN_LEFT,0.5,2
 
 ; test whether click is in widget or not
 if kclick==1 then
  kin1	=	(kMOUSE_X>iTabX-(iNodeSize*0.5)            && kMOUSE_X<iTabX+(iNodeSize*0.5)           && kMOUSE_Y>iTabY+ky1-(iNodeSize*0.5) && kMOUSE_Y<iTabY+ky1+(iNodeSize*0.5) && kMOUSE_DOWN_LEFT==1) ? 1 : 0
  kin2	=	(kMOUSE_X>kx2-iNodeSize                    && kMOUSE_X<kx2+iNodeSize                   && kMOUSE_Y>iTabY+ky2-(iNodeSize*0.5) && kMOUSE_Y<iTabY+ky2+(iNodeSize*0.5) && kMOUSE_DOWN_LEFT==1) ? 1 : 0
  kin3	=	(kMOUSE_X>kx3-iNodeSize                    && kMOUSE_X<kx3+iNodeSize                   && kMOUSE_Y>iTabY+ky3-(iNodeSize*0.5) && kMOUSE_Y<iTabY+ky3+(iNodeSize*0.5) && kMOUSE_DOWN_LEFT==1) ? 1 : 0
  kin4	=	(kMOUSE_X>iTabX+iTabWidth-(iNodeSize*0.5)  && kMOUSE_X<iTabX+iTabWidth+(iNodeSize*0.5) && kMOUSE_Y>iTabY+ky4-(iNodeSize*0.5) && kMOUSE_Y<iTabY+ky4+(iNodeSize*0.5) && kMOUSE_DOWN_LEFT==1) ? 1 : 0
 endif

 ; click and drag
 if kin1==1 then
  ky1	limit	kMOUSE_Y - (iNodeSize*0.5), iTabY-(iNodeSize*0.5), iTabY+iTabHeight-(iNodeSize*0.5)
 endif
 if kin2==1 then
  kx2	limit	kMOUSE_X - (iNodeSize*0.5), iTabX-(iNodeSize*0.5), kx3
  ky2	limit	kMOUSE_Y - (iNodeSize*0.5), iTabY-(iNodeSize*0.5), iTabY+iTabHeight-(iNodeSize*0.5)
 endif
 if kin3==1 then
  kx3	limit	kMOUSE_X - (iNodeSize*0.5), kx2, iTabX+iTabWidth-(iNodeSize*0.5)
  ky3	limit	kMOUSE_Y - (iNodeSize*0.5), iTabY-(iNodeSize*0.5), iTabY+iTabHeight-(iNodeSize*0.5)
 endif
 if kin4==1 then
  ky4	limit	kMOUSE_Y - (iNodeSize*0.5), iTabY-(iNodeSize*0.5), iTabY+iTabHeight-(iNodeSize*0.5)
 endif
  
 kmetro	metro	ksmps

 if kmetro==1 then				; slow down checking
  if changed(knorm)==1 then			; normalise check box changed
   reinit REBUILD_TABLE
  endif
  ktrig	changed	ky1				; node 1 (beginning) moved
  if ktrig==1 then
   Smsg	sprintfk	"pos(%d,%d)", iTabX-(iNodeSize*0.5), ky1
   	chnset	Smsg,Snode1
   reinit REBUILD_TABLE
  endif
  ktrig	changed	kx2,ky2				; node 2 moved
  if ktrig==1 then
   Smsg	sprintfk	"pos(%d,%d)", kx2, ky2
   	chnset	Smsg,Snode2
   reinit REBUILD_TABLE
  endif
  ktrig	changed	kx3,ky3				; node 3 moved
  if ktrig==1 then
   Smsg	sprintfk	"pos(%d,%d)", kx3, ky3
   	chnset	Smsg,Snode3
   reinit REBUILD_TABLE
  endif
  ktrig	changed	ky4				; node 4 (end) moved
  if ktrig==1 then
   Smsg	sprintfk	"pos(%d,%d)", iTabX+iTabWidth-(iNodeSize*0.5), ky4
   	chnset	Smsg,Snode4
   reinit REBUILD_TABLE
  endif
  
  REBUILD_TABLE:
  inorm		=	(i(knorm)*2)-1
  iy1		limit	1-((i(ky1)+(iNodeSize*0.5)-iTabY)/iTabHeight), 0, 1
  ix2		limit	((i(kx2)+(iNodeSize*0.5)-iTabX)/iTabWidth * ftlen(ifn)),1,1022
  iy2		limit	1-((i(ky2)+(iNodeSize*0.5)-iTabY)/iTabHeight), 0, 1
  ix3		limit	((i(kx3)+(iNodeSize*0.5)-iTabX)/iTabWidth * ftlen(ifn))-ix2,1,1022
  iy3		limit	1-((i(ky3)+(iNodeSize*0.5)-iTabY)/iTabHeight), 0, 1
  iy4		limit	1-((i(ky4)+(iNodeSize*0.5)-iTabY)/iTabHeight), 0, 1
  gitable1	ftgen	ifn,0,1024,8*inorm,	iy1, ix2, iy2, ix3, iy3, 1023-ix2-ix3, iy4
  Smsg		sprintf	"tablenumber(%d)",ifn
  	 	chnset	Smsg,STabIdent
  kx2o	init	ix2/ftlen(ifn)
  kx3o	init	ix3/ftlen(ifn)
  rireturn
 endif

 ky1o	=	1-((ky1+iTabY-(iNodeSize*0.5))/iTabHeight)

 ky2o	=	1-((ky2+iTabY-(iNodeSize*0.5))/iTabHeight)
 ky3o	=	1-((ky3+iTabY-(iNodeSize*0.5))/iTabHeight)
 ky4o	=	1-((ky4+iTabY-(iNodeSize*0.5))/iTabHeight)
 xout	ky1o,kx2o,ky2o,kx3o,ky3o,ky4o
endop







instr	1	; create envelopes and interact with Cabbage GUI (via UDOs)
 knorm			chnget	"norm"		; normalise value (0 = don't normalise, 1 = do normalise)
 iTabX			init	10		; table x location in pixels 
 iTabY			init	5		; table y location in pixels
 iTabWidth		init	380		; width of the table in pixels
 iTabHeight		init	290		; height of the table in pixels
 iNodeSize		init	10 		; size of the breakpoint widget in pixels
 ifn			=	1		; function table number

 gky1,gkx2,gky2,gky3	GEN08_3NodeEnvelope	knorm, iTabX,     iTabY, iTabWidth, iTabHeight, iNodeSize, ifn,   "table1", "node1", "node2", "node3"

 if metro(16)==1 then
  if	changed(gky1,gkx2,gky2,gky3,knorm)==1 then
   chnset	gky1,"aV1"
   chnset	gkx2*1024,"aD1"
   chnset	gky2,"aV2"
   chnset	1024*(1-gkx2),"aD2"
   chnset	gky3,"aV3"
   kmin,kndx	tabmink	ifn
   chnset	kmin,"aMin"
   kmax,kndx	tabmaxk	ifn
   chnset	kmax,"aMax"
  endif
 endif
 
;; optional - print out output arguments from envelope
; if changed(gky1,gkx2,gky2,gky3)==1 then
;  Senv	sprintfk	"y1:%f x2:%f y2:%f y3:%f\n",gky1,gkx2,gky2,gky3
;  printks	Senv,0
; endif

 gky1,gkx2,gky2,gkx3,gky3,gky4	GEN08_4NodeEnvelope	knorm, iTabX+400, iTabY, iTabWidth, iTabHeight, iNodeSize, ifn+1, "table2", "node4", "node5", "node6", "node7"

 if metro(16)==1 then
  if	changed(gky1,gkx2,gky2,gkx3,gky3,gky4,knorm)==1 then
   chnset	gky1,"bV1"
   chnset	gkx2*1024,"bD1"
   chnset	gky2,"bV2"
   chnset	gkx3*1024,"bD2"
   chnset	gky3,"bV3"
   chnset	(1-gkx3-gkx2)*1024,"bD3"
   chnset	gky4,"bV4"
   kmin,kndx	tabmink	ifn+1
   chnset	kmin,"bMin"
   kmax,kndx	tabmaxk	ifn+1
   chnset	kmax,"bMax"
  endif
 endif

;; optional - print out output arguments from envelope
; if changed(gky1,gkx2,gky2,gkx3,gky3,gky4)==1 then
;  Senv	sprintfk	"y1:%f x2:%f y2:%f x3:%f y3:%f y4:%f\n",gky1,gkx2,gky2,gkx3,gky3,gky4
;  printks	Senv,0
; endif
 
endin



instr	2
 idur	chnget	"dur"			; envelope duration
 
 if timeinsts()>=idur then		; if full duration is achieved...
  turnoff				; turn instrument off
 endif
 
 kphr	phasor	1/idur			; phasor reads through once
 ienv	chnget	"env"			; envelope type selection (1 or 2, 1 = 3_point, 2 = 4_point)
 kenv	tablei	kphr,ienv,1		; read values from function table. Amplitude envelope.
 kenv	limit	kenv,0,1		; limit to prevent amplitude values that might produce out of range samples
 kenv	expcurve	kenv,8		; shape the dynamics of the envelope to be more musical
 aenv	interp		kenv		; interpolate and create a-rate version of envelope. (Less 'zipper' noise)
 icps	cpsmidi				; read in midi pitch in cps
 asig	vco2	0.2,icps,4,0.5		; create a triangle wave oscillator
 aDeClick	linsegr	1,0.01,0	; de-click envelope (if note is stopped before envelope has completed
 	outs	asig*aenv*aDeClick, asig*aenv*aDeClick	; send audio to outputs, apply amplitude envelope and de-clicking envelope
endin

</CsInstruments>

<CsScore>
i 1 0 3600
</CsScore>

</CsoundSynthesizer>; GEN09.csd
; Written by Iain McCurdy
; "P.N.1-8" 	sets the partial number for each of the 8 partials. Note that "Base" and "Int" will also have an influence upon the partial number values.
; "Str.1-8" 	sets the strengths for the 8 partials.
; "Mute 1-8"	allow the user to mute individual partials
; "Solo 1-8"	allow the user to solo individual partials (multiple solos can be employed)
; "Ph.1-8" 	sets the initial phases (in degrees) for the 8 partials.
; "Base" 	sets a base offset (integer) for all partial numbers. The oscillator frequency will also be divided by this value.
; "Int." 	defines an additional cumulative interval (integer) between partials. E.g. if "Int." is '2', partials 1 will be unaffected, an additional interval of '2' will be added to partial 2, an additional interval of '4' will be added to partial 3 and so on. 
; Table Size	size of the table used by the synthesizer.
;		If table size is reduced quantisation artefacts will become more prevalent, particularly if partial numbers are high. This 'lo-fi' effect may be desirable. 
; 		In actual fact, separate tables are used for each table size but the table display widget only ever displays the ninth table.

; 		The frequency of the audio oscillator is always scaled down according to the lowest partial number defined. This is to ensure that an audible fundemental is always played, something that may not otherwise occur if all partial numbers are high.
; 		The user can choose between three opcodes for synthesis: oscil, oscili or poscil. 
;		The interpolating opcodes oscili and poscil are less likely to produce quantisation artifacts when small table sizes are used.
;		The waveform can be played back using oscbnk (if 'voices' is greater than 1), in which case 'spread' and 'speed' can be used to modify the texture of the tone cluster.

<Cabbage>
form caption("GEN09"), size(420, 555), pluginid("gn09") style("legacy")

gentable bounds( 10,  5, 400, 120), tablenumber(8), tablecolour("LightBlue"), identchannel("table"), zoom(-1)

rslider bounds( 13,130, 43, 43), channel("pn1"), range(1, 200, 1,1,1), colour(230,230,230,200)
rslider bounds( 63,130, 43, 43), channel("pn2"), range(1, 200, 2,1,1), colour(230,230,230,200)
rslider bounds(113,130, 43, 43), channel("pn3"), range(1, 200, 3,1,1), colour(230,230,230,200)
rslider bounds(163,130, 43, 43), channel("pn4"), range(1, 200, 4,1,1), colour(230,230,230,200)
rslider bounds(213,130, 43, 43), channel("pn5"), range(1, 200, 5,1,1), colour(230,230,230,200)
rslider bounds(263,130, 43, 43), channel("pn6"), range(1, 200, 6,1,1), colour(230,230,230,200)
rslider bounds(313,130, 43, 43), channel("pn7"), range(1, 200, 7,1,1), colour(230,230,230,200)
rslider bounds(363,130, 43, 43), channel("pn8"), range(1, 200, 8,1,1), colour(230,230,230,200)

rslider  bounds(  0,175, 70, 26), text("P.N.1"), textbox(1), valuetextbox(1), channel("pn1_out"), range(1, 10000, 1, 1, 1)
rslider  bounds( 50,175, 70, 26), text("P.N.2"), textbox(1), valuetextbox(1), channel("pn2_out"), range(1, 10000, 1, 1, 1)
rslider  bounds(100,175, 70, 26), text("P.N.3"), textbox(1), valuetextbox(1), channel("pn3_out"), range(1, 10000, 1, 1, 1)
rslider  bounds(150,175, 70, 26), text("P.N.4"), textbox(1), valuetextbox(1), channel("pn4_out"), range(1, 10000, 1, 1, 1)
rslider  bounds(200,175, 70, 26), text("P.N.5"), textbox(1), valuetextbox(1), channel("pn5_out"), range(1, 10000, 1, 1, 1)
rslider  bounds(250,175, 70, 26), text("P.N.6"), textbox(1), valuetextbox(1), channel("pn6_out"), range(1, 10000, 1, 1, 1)
rslider  bounds(300,175, 70, 26), text("P.N.7"), textbox(1), valuetextbox(1), channel("pn7_out"), range(1, 10000, 1, 1, 1)
rslider  bounds(350,175, 70, 26), text("P.N.8"), textbox(1), valuetextbox(1), channel("pn8_out"), range(1, 10000, 1, 1, 1)

rslider bounds( 10,205, 50, 70), channel("str1"), text("Str.1"), textbox(1), valuetextbox(1), range(0, 1, 1, 0.5, 0.001), colour(200,200,200,200)
rslider bounds( 60,205, 50, 70), channel("str2"), text("Str.2"), textbox(1), valuetextbox(1), range(0, 1, 0.5, 0.5, 0.001), colour(200,200,200,200)
rslider bounds(110,205, 50, 70), channel("str3"), text("Str.3"), textbox(1), valuetextbox(1), range(0, 1, 0.3, 0.5, 0.001), colour(200,200,200,200)
rslider bounds(160,205, 50, 70), channel("str4"), text("Str.4"), textbox(1), valuetextbox(1), range(0, 1, 0.25, 0.5, 0.001), colour(200,200,200,200)
rslider bounds(210,205, 50, 70), channel("str5"), text("Str.5"), textbox(1), valuetextbox(1), range(0, 1, 0.2, 0.5, 0.001), colour(200,200,200,200)
rslider bounds(260,205, 50, 70), channel("str6"), text("Str.6"), textbox(1), valuetextbox(1), range(0, 1, 0.16, 0.5, 0.001), colour(200,200,200,200)
rslider bounds(310,205, 50, 70), channel("str7"), text("Str.7"), textbox(1), valuetextbox(1), range(0, 1, 0.14287, 0.5, 0.001), colour(200,200,200,200)
rslider bounds(360,205, 50, 70), channel("str8"), text("Str.8"), textbox(1), valuetextbox(1), range(0, 1, 0.125, 0.5, 0.001), colour(200,200,200,200)

checkbox bounds( 29,275, 12, 12), channel("mute1"),  value(0), colour("red"), shape("square")
checkbox bounds( 79,275, 12, 12), channel("mute2"),  value(0), colour("red"), shape("square")
checkbox bounds(129,275, 12, 12), channel("mute3"),  value(0), colour("red"), shape("square")
checkbox bounds(179,275, 12, 12), channel("mute4"),  value(0), colour("red"), shape("square")
checkbox bounds(229,275, 12, 12), channel("mute5"),  value(0), colour("red"), shape("square")
checkbox bounds(279,275, 12, 12), channel("mute6"),  value(0), colour("red"), shape("square")
checkbox bounds(329,275, 12, 12), channel("mute7"),  value(0), colour("red"), shape("square")
checkbox bounds(379,275, 12, 12), channel("mute8"),  value(0), colour("red"), shape("square")

checkbox bounds( 29,297, 12, 12), channel("solo1"),  value(0), colour("yellow"), shape("square")
checkbox bounds( 79,297, 12, 12), channel("solo2"),  value(0), colour("yellow"), shape("square")
checkbox bounds(129,297, 12, 12), channel("solo3"),  value(0), colour("yellow"), shape("square")
checkbox bounds(179,297, 12, 12), channel("solo4"),  value(0), colour("yellow"), shape("square")
checkbox bounds(229,297, 12, 12), channel("solo5"),  value(0), colour("yellow"), shape("square")
checkbox bounds(279,297, 12, 12), channel("solo6"),  value(0), colour("yellow"), shape("square")
checkbox bounds(329,297, 12, 12), channel("solo7"),  value(0), colour("yellow"), shape("square")
checkbox bounds(379,297, 12, 12), channel("solo8"),  value(0), colour("yellow"), shape("square")

label    bounds( 23,286, 24, 10), text("Mute"),  fontcolour("white")
label    bounds( 73,286, 24, 10), text("Mute"),  fontcolour("white")
label    bounds(123,286, 24, 10), text("Mute"),  fontcolour("white")
label    bounds(173,286, 24, 10), text("Mute"),  fontcolour("white")
label    bounds(223,286, 24, 10), text("Mute"),  fontcolour("white")
label    bounds(273,286, 24, 10), text("Mute"),  fontcolour("white")
label    bounds(323,286, 24, 10), text("Mute"),  fontcolour("white")
label    bounds(373,286, 24, 10), text("Mute"),  fontcolour("white")

label    bounds( 24,307, 21, 10), text("Solo"),  fontcolour("white")
label    bounds( 74,307, 21, 10), text("Solo"),  fontcolour("white")
label    bounds(124,307, 21, 10), text("Solo"),  fontcolour("white")
label    bounds(174,307, 21, 10), text("Solo"),  fontcolour("white")
label    bounds(224,307, 21, 10), text("Solo"),  fontcolour("white")
label    bounds(274,307, 21, 10), text("Solo"),  fontcolour("white")
label    bounds(324,307, 21, 10), text("Solo"),  fontcolour("white")
label    bounds(374,307, 21, 10), text("Solo"),  fontcolour("white")

rslider bounds( 10,320, 50, 70), channel("ph1"), text("Ph.1"), textbox(1), valuetextbox(1), range(0, 360, 0), colour(150,150,150,200)
rslider bounds( 60,320, 50, 70), channel("ph2"), text("Ph.2"), textbox(1), valuetextbox(1), range(0, 360, 0), colour(150,150,150,200)
rslider bounds(110,320, 50, 70), channel("ph3"), text("Ph.3"), textbox(1), valuetextbox(1), range(0, 360, 0), colour(150,150,150,200)
rslider bounds(160,320, 50, 70), channel("ph4"), text("Ph.4"), textbox(1), valuetextbox(1), range(0, 360, 0), colour(150,150,150,200)
rslider bounds(210,320, 50, 70), channel("ph5"), text("Ph.5"), textbox(1), valuetextbox(1), range(0, 360, 0), colour(150,150,150,200)
rslider bounds(260,320, 50, 70), channel("ph6"), text("Ph.6"), textbox(1), valuetextbox(1), range(0, 360, 0), colour(150,150,150,200)
rslider bounds(310,320, 50, 70), channel("ph7"), text("Ph.7"), textbox(1), valuetextbox(1), range(0, 360, 0), colour(150,150,150,200)
rslider bounds(360,320, 50, 70), channel("ph8"), text("Ph.8"), textbox(1), valuetextbox(1), range(0, 360, 0), colour(150,150,150,200)

rslider  bounds( 10,395, 50, 70), channel("base"), text("Base"), textbox(1), valuetextbox(1), range(0, 200, 1, 1,1), colour(110,110,110,200)
rslider  bounds( 60,395, 50, 70), channel("int"), text("Int."), textbox(1), valuetextbox(1), range(0, 200, 2, 1,1) , colour(110,110,110,200)
label    bounds(120,400, 95, 13), text("Table Size")
combobox bounds(120,415, 95, 20), channel("tabsize"), value(8), text("32","64","128","256","512","1024","2048","4096","8192")
label    bounds(195,400, 95, 13), text("Opcode")
combobox bounds(195,415, 95, 20), channel("opcode"), value(3), text("oscil","oscili","poscil")
button   bounds(285,395,120, 20), text("EXPORT TABLE"), channel("export"), value(0), fontcolour("yellow")

rslider bounds(283,420, 45, 40), channel("spread"), text("Spread"), range(0, 1, 0.05,0.5,0.00001), colour("yellow")
rslider bounds(323,420, 45, 40), channel("voices"), text("Voices"), range(1, 20, 8,1,1), colour("yellow")
rslider bounds(363,420, 45, 40), channel("speed"), text("Speed"), range(0,100, 1.5,0.5,0.001), colour("yellow")

keyboard bounds(  0,475,420, 80)

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	;MAXIMUM AMPLITUDE
		massign	0,3	; send all midi notes to instr 3

gicos		ftgen	0,0,4096,11,1		;COSINE WAVE (USED BY THE LFOS)
gieqffn		ftgen	0,0,4097,7,-1,4096,1
gieqlfn		ftgen	0,0,4097,7,-1,4096,1
gieqqfn		ftgen	0,0,4097,7,-1,4096,1

instr	1
	; read in widgets
	gkpn1	chnget	"pn1"
	gkpn2	chnget	"pn2"
	gkpn3	chnget	"pn3"
	gkpn4	chnget	"pn4"
	gkpn5	chnget	"pn5"
	gkpn6	chnget	"pn6"
	gkpn7	chnget	"pn7"
	gkpn8	chnget	"pn8"

	gkstr1	chnget	"str1"
	gkstr2	chnget	"str2"
	gkstr3	chnget	"str3"
	gkstr4	chnget	"str4"
	gkstr5	chnget	"str5"
	gkstr6	chnget	"str6"
	gkstr7	chnget	"str7"
	gkstr8	chnget	"str8"

	gkmute1	chnget	"mute1"
	gkmute2	chnget	"mute2"
	gkmute3	chnget	"mute3"
	gkmute4	chnget	"mute4"
	gkmute5	chnget	"mute5"
	gkmute6	chnget	"mute6"
	gkmute7	chnget	"mute7"
	gkmute8	chnget	"mute8"

	gksolo1	chnget	"solo1"
	gksolo2	chnget	"solo2"
	gksolo3	chnget	"solo3"
	gksolo4	chnget	"solo4"
	gksolo5	chnget	"solo5"
	gksolo6	chnget	"solo6"
	gksolo7	chnget	"solo7"
	gksolo8	chnget	"solo8"

	kSoloSum	=	gksolo1+gksolo2+gksolo3+gksolo4+gksolo5+gksolo6+gksolo7+gksolo8

#define	SOLO_MUTE_STATUS(N)	
	#
	if gksolo$N==1 then
	 kstatus$N	=	1
	elseif kSoloSum>0 then
	 kstatus$N	=	0
	else
	 kstatus$N	=	(1-gkmute$N)
	endif
	#
	$SOLO_MUTE_STATUS(1)
	$SOLO_MUTE_STATUS(2)
	$SOLO_MUTE_STATUS(3)
	$SOLO_MUTE_STATUS(4)
	$SOLO_MUTE_STATUS(5)
	$SOLO_MUTE_STATUS(6)
	$SOLO_MUTE_STATUS(7)
	$SOLO_MUTE_STATUS(8)

	gkph1	chnget	"ph1"
	gkph2	chnget	"ph2"
	gkph3	chnget	"ph3"
	gkph4	chnget	"ph4"
	gkph5	chnget	"ph5"
	gkph6	chnget	"ph6"
	gkph7	chnget	"ph7"
	gkph8	chnget	"ph8"

	gkbase	chnget	"base"
	gkint	chnget	"int"
	gkopcode	chnget	"opcode"
	gkopcode	init	3		; init pass value for gkopcode
	
	; if any of the variables in the input list are changed, a momentary '1' trigger is generated at the output. This trigger is used to update function tables.
	ktrig	changed	gkpn1,gkpn2,gkpn3,gkpn4,gkpn5,gkpn6,gkpn7,gkpn8,gkstr1,gkstr2,gkstr3,gkstr4,gkstr5,gkstr6,gkstr7,gkstr8,kstatus1,kstatus2,kstatus3,kstatus4,kstatus5,kstatus6,kstatus7,kstatus8,gkph1,gkph2,gkph3,gkph4,gkph5,gkph6,gkph7,gkph8,gkbase,gkint

	if ktrig==1 then
	 reinit	UPDATE
	endif
	UPDATE:
	; Update function tables.
	gi1	ftgen	1, 0,   32,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	gi2	ftgen	2, 0,   64,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	gi3	ftgen	3, 0,  128,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	gi4	ftgen	4, 0,  256,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	gi5	ftgen	5, 0,  512,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	gi6	ftgen	6, 0, 1024,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	gi7	ftgen	7, 0, 2048,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	gi8	ftgen	8, 0, 4096,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	gi9	ftgen	9, 0, 8192,9, i(gkbase)+i(gkpn1),i(gkstr1)*i(kstatus1),i(gkph1), i(gkbase)+i(gkpn2)+i(gkint),i(gkstr2)*i(kstatus2),i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2),i(gkstr3)*i(kstatus3),i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3),i(gkstr4)*i(kstatus4),i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4),i(gkstr5)*i(kstatus5),i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5),i(gkstr6)*i(kstatus6),i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6),i(gkstr7)*i(kstatus7),i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7),i(gkstr8)*i(kstatus8),i(gkph8)
	rireturn
	if ktrig==1 then
	 chnset	"tablenumber(8)", "table"	; update table display	
	endif
	; update "P.N.1-8" (partial numbers) value display boxes.
	chnset	i(gkbase)+i(gkpn1),"pn1_out"
	chnset	i(gkbase)+i(gkpn2)+i(gkint),"pn2_out"
	chnset	i(gkbase)+i(gkpn3)+(i(gkint)*2),"pn3_out"
	chnset	i(gkbase)+i(gkpn4)+(i(gkint)*3),"pn4_out"
	chnset	i(gkbase)+i(gkpn5)+(i(gkint)*4),"pn5_out"
	chnset	i(gkbase)+i(gkpn6)+(i(gkint)*5),"pn6_out"
	chnset	i(gkbase)+i(gkpn7)+(i(gkint)*6),"pn7_out"
	chnset	i(gkbase)+i(gkpn8)+(i(gkint)*7),"pn8_out"
	gkscal	min	gkbase+gkpn1, gkbase+gkpn2, gkbase+gkpn3, gkbase+gkpn4, gkbase+gkpn5, gkbase+gkpn6, gkbase+gkpn7, gkbase+gkpn8
	rireturn

	kexport	chnget	"export"
	ktrig	changed	kexport
		schedkwhen	ktrig,0,0,4,0,0.01

	gktabsize	init	9		; init pass value for gktabsize
endin


instr	3	; sound producing instrument

	gktabsize	chnget	"tabsize"
	gktabsize	init	9		; init pass value for gktabsize

	icps	cpsmidi				; CPS from midi note played
	iamp	ampmidi	0.3			; amplitude from midi note velocity 
	ifn	init	i(gktabsize)		; function table to be used by the oscillator. This will be dependent upon tables size selected.

	kvoices	chnget	"voices"
	ktrig	changed	kvoices
	if ktrig==1 then
	 reinit update
	endif
	update:
	ivoices	init	i(kvoices)
	iscal	=	i(gkscal)
	aenv	linsegr	0,0.01,1,0.1,0		; amplitude envelope to prevent clicks


	if ivoices==1 then	
	 if gkopcode==1 then			; if option 1 is selected by the "Opcode" combo box...
	  asig	oscil	iamp,icps/gkscal,ifn	; use oscil
	 elseif gkopcode==2 then		; if option 2 is selected by the "Opcode" combo box...
	  asig	oscili	iamp,icps/gkscal,ifn	; use oscili                                         
	 elseif gkopcode==3 then		; if option 3 is selected by the "Opcode" combo box...
	  asig	poscil	iamp,icps/gkscal,ifn	; use poscil                                         
	 endif					; end of conditional
	 asig	=	asig * aenv		; apply envelope
	  	outs	asig,asig
        else
         kwave	init	ifn
         kspread	chnget	"spread"
         kspeed		chnget	"speed"
        	;OUTPUT	OPCODE  CPS  | AMD  |    FMD    |  PMD  | OVERLAPS   | SEED | L1MINF  | L1MAXF  | L2MINF  | L2MAXF  | LFOMODE | EQMINF  | EQMAXF | EQMINL | EQMAXL | EQMINQ | EQMAXQ  | EQMODE | KFN  | L1FN | L2FN | EQFFN  | EQLF   |  EQQFN |  TABL  | OUTFN
	 aL	oscbnk	icps/(gkscal),   0,      0,      kspread,     ivoices,   rnd(1),      0,   kspeed,      0,        0,       238,      0,       8000,      1,       1,       1,       1,       -1,   kwave, gicos, gicos, gieqffn, gieqlfn, gieqqfn
	 aR	oscbnk	icps/(gkscal),   0,      0,     -kspread,     ivoices,   rnd(1),      0,  -kspeed,      0,        0,       238,      0,       8000,      1,       1,       1,       1,       -1,   kwave, gicos, gicos, gieqffn, gieqlfn, gieqqfn
	 aL	=	(aL * aenv * iamp) / (ivoices^0.5) 		; apply envelope
	 aR	=	(aR * aenv * iamp) / (ivoices^0.5)		; apply envelope
	  	outs	aL, aR
        endif
endin

instr	4
	ifn	chnget	"tabsize"
	isize	=	ftlen(ifn)
	fprints	"GEN09Table.txt", "giGEN09wave ftgen 0,0,%d,9,%d,%f,%f,%d,%f,%f,%d,%f,%f,%d,%f,%f,%d,%f,%f,%d,%f,%f,%d,%f,%f,%d,%f,%f",isize, i(gkbase)+i(gkpn1), i(gkstr1), i(gkph1), i(gkbase)+i(gkpn2)+i(gkint), i(gkstr2), i(gkph2), i(gkbase)+i(gkpn3)+(i(gkint)*2), i(gkstr3), i(gkph3), i(gkbase)+i(gkpn4)+(i(gkint)*3), i(gkstr4), i(gkph4), i(gkbase)+i(gkpn5)+(i(gkint)*4), i(gkstr5), i(gkph5), i(gkbase)+i(gkpn6)+(i(gkint)*5), i(gkstr6), i(gkph6), i(gkbase)+i(gkpn7)+(i(gkint)*6), i(gkstr7), i(gkph7), i(gkbase)+i(gkpn8)+(i(gkint)*7), i(gkstr8), i(gkph8)

endin

</CsInstruments>

<CsScore>
; create the function tables
f1 0    32 9  1 0 0
f2 0    64 9  1 0 0
f3 0   128 9  1 0 0
f4 0   256 9  1 0 0
f5 0   512 9  1 0 0
f6 0  1024 9  1 0 0
f7 0  2048 9  1 0 0
f8 0  4096 9  1 0 0
f9 0  8192 9  1 0 0
; play instrument 1 for 1 hour
i 1 0 3600
</CsScore>

</CsoundSynthesizer>
; GEN10.csd
; Written by Iain McCurdy, 2013
; Demonstration of GEN10
; Create a wave and then play it using the keyboard
; Negative strength values result in inverted phase

<Cabbage>
form caption("GEN10"), size(410, 340), pluginid("gn10"), colour("20,70,170,150") style("legacy")

gentable bounds(  5,  5, 400, 120), identchannel("table1"), tablenumber(1), tablecolour("yellow"), zoom(-1)

rslider bounds(  5,130, 50, 70), channel("str1"), text("Str.1"), valuetextbox(1), textbox(1), range(-1.00, 1.00, 1), colour(100,100,250,200)
rslider bounds( 55,130, 50, 70), channel("str2"), text("Str.2"), valuetextbox(1), textbox(1), range(-1.00, 1.00, 0), colour(100,100,250,200)
rslider bounds(105,130, 50, 70), channel("str3"), text("Str.3"), valuetextbox(1), textbox(1), range(-1.00, 1.00, 0), colour(100,100,250,200)
rslider bounds(155,130, 50, 70), channel("str4"), text("Str.4"), valuetextbox(1), textbox(1), range(-1.00, 1.00, 0), colour(100,100,250,200)
rslider bounds(205,130, 50, 70), channel("str5"), text("Str.5"), valuetextbox(1), textbox(1), range(-1.00, 1.00, 0), colour(100,100,250,200)
rslider bounds(255,130, 50, 70), channel("str6"), text("Str.6"), valuetextbox(1), textbox(1), range(-1.00, 1.00, 0), colour(100,100,250,200)
rslider bounds(305,130, 50, 70), channel("str7"), text("Str.7"), valuetextbox(1), textbox(1), range(-1.00, 1.00, 0), colour(100,100,250,200)
rslider bounds(355,130, 50, 70), channel("str8"), text("Str.8"), valuetextbox(1), textbox(1), range(-1.00, 1.00, 0), colour(100,100,250,200)

checkbox bounds( 24,203, 12, 12), channel("mute1"),  value(0), colour("red"), shape("square")
checkbox bounds( 74,203, 12, 12), channel("mute2"),  value(0), colour("red"), shape("square")
checkbox bounds(124,203, 12, 12), channel("mute3"),  value(0), colour("red"), shape("square")
checkbox bounds(174,203, 12, 12), channel("mute4"),  value(0), colour("red"), shape("square")
checkbox bounds(224,203, 12, 12), channel("mute5"),  value(0), colour("red"), shape("square")
checkbox bounds(274,203, 12, 12), channel("mute6"),  value(0), colour("red"), shape("square")
checkbox bounds(324,203, 12, 12), channel("mute7"),  value(0), colour("red"), shape("square")
checkbox bounds(374,203, 12, 12), channel("mute8"),  value(0), colour("red"), shape("square")

checkbox bounds( 24,228, 12, 12), channel("solo1"),  value(0), colour("yellow"), shape("square")
checkbox bounds( 74,228, 12, 12), channel("solo2"),  value(0), colour("yellow"), shape("square")
checkbox bounds(124,228, 12, 12), channel("solo3"),  value(0), colour("yellow"), shape("square")
checkbox bounds(174,228, 12, 12), channel("solo4"),  value(0), colour("yellow"), shape("square")
checkbox bounds(224,228, 12, 12), channel("solo5"),  value(0), colour("yellow"), shape("square")
checkbox bounds(274,228, 12, 12), channel("solo6"),  value(0), colour("yellow"), shape("square")
checkbox bounds(324,228, 12, 12), channel("solo7"),  value(0), colour("yellow"), shape("square")
checkbox bounds(374,228, 12, 12), channel("solo8"),  value(0), colour("yellow"), shape("square")

label    bounds( 19,216, 24, 10), text("Mute"),  FontColour("white")
label    bounds( 69,216, 24, 10), text("Mute"),  FontColour("white")
label    bounds(119,216, 24, 10), text("Mute"),  FontColour("white")
label    bounds(169,216, 24, 10), text("Mute"),  FontColour("white")
label    bounds(219,216, 24, 10), text("Mute"),  FontColour("white")
label    bounds(269,216, 24, 10), text("Mute"),  FontColour("white")
label    bounds(319,216, 24, 10), text("Mute"),  FontColour("white")
label    bounds(369,216, 24, 10), text("Mute"),  FontColour("white")

label    bounds( 20,241, 21, 10), text("Solo"),  FontColour("white")
label    bounds( 70,241, 21, 10), text("Solo"),  FontColour("white")
label    bounds(120,241, 21, 10), text("Solo"),  FontColour("white")
label    bounds(170,241, 21, 10), text("Solo"),  FontColour("white")
label    bounds(220,241, 21, 10), text("Solo"),  FontColour("white")
label    bounds(270,241, 21, 10), text("Solo"),  FontColour("white")
label    bounds(320,241, 21, 10), text("Solo"),  FontColour("white")
label    bounds(370,241, 21, 10), text("Solo"),  FontColour("white")

keyboard bounds(  0,260,410, 80)
</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE
		massign	0,3	; send all midi notes to instr 3 
			
giwave	ftgen	1,0, 4096,10, 0	; GEN10 generated wave

instr	1
	; read in widgets
	gkstr1	chnget	"str1"
	gkstr2	chnget	"str2"
	gkstr3	chnget	"str3"
	gkstr4	chnget	"str4"
	gkstr5	chnget	"str5"
	gkstr6	chnget	"str6"
	gkstr7	chnget	"str7"
	gkstr8	chnget	"str8"

	gkmute1	chnget	"mute1"
	gkmute2	chnget	"mute2"
	gkmute3	chnget	"mute3"
	gkmute4	chnget	"mute4"
	gkmute5	chnget	"mute5"
	gkmute6	chnget	"mute6"
	gkmute7	chnget	"mute7"
	gkmute8	chnget	"mute8"

	gksolo1	chnget	"solo1"
	gksolo2	chnget	"solo2"
	gksolo3	chnget	"solo3"
	gksolo4	chnget	"solo4"
	gksolo5	chnget	"solo5"
	gksolo6	chnget	"solo6"
	gksolo7	chnget	"solo7"
	gksolo8	chnget	"solo8"

	kSoloSum	=	gksolo1+gksolo2+gksolo3+gksolo4+gksolo5+gksolo6+gksolo7+gksolo8	; sum of all solo buttons

#define	SOLO_MUTE_STATUS(N) 
	#
	if gksolo$N==1 then			; if solo for this voice is on...
	 kstatus$N	=	1		; this partial will be active
	elseif kSoloSum>0 then			; if any other solo is on...
	 kstatus$N	=	0		; this partial will be inactive
	else					; other wise
	 kstatus$N	=	(1-gkmute$N)	; partial will be on if mute is inactive
	endif
	#
	$SOLO_MUTE_STATUS(1)			; expand macro
	$SOLO_MUTE_STATUS(2)
	$SOLO_MUTE_STATUS(3)
	$SOLO_MUTE_STATUS(4)
	$SOLO_MUTE_STATUS(5)
	$SOLO_MUTE_STATUS(6)
	$SOLO_MUTE_STATUS(7)
	$SOLO_MUTE_STATUS(8)
	; generate a trigger if any of the input variables changes
	ktrig	changed	gkstr1,gkstr2,gkstr3,gkstr4,gkstr5,gkstr6,gkstr7,gkstr8,kstatus1,kstatus2,kstatus3,kstatus4,kstatus5,kstatus6,kstatus7,kstatus8
	if ktrig==1 then
	 reinit UPDATE
	endif
	UPDATE:	
	giwave	ftgen	1,0, 4096,10, i(gkstr1)*i(kstatus1),i(gkstr2)*i(kstatus2),i(gkstr3)*i(kstatus3),i(gkstr4)*i(kstatus4),i(gkstr5)*i(kstatus5),i(gkstr6)*i(kstatus6),i(gkstr7)*i(kstatus7),i(gkstr8)*i(kstatus8)
	rireturn
	if ktrig==1 then
	 chnset	"tablenumber(1)", "table1"	; update table display	
	endif
endin

instr	3
	icps	cpsmidi				; CPS from midi note played
	iamp	ampmidi	0.5			; amplitude from midi note velocity 
	a1	oscili	iamp,icps,giwave	; audio oscillator read GEN10 wave created
	aenv	linsegr	0,0.01,1,0.1,0		; amplitude envelope to prevent clicks
	a1	=	a1 * aenv		; apply envelope
		outs	a1, a1			; send audio to outputs
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; GEN16.csd
; Written by Iain McCurdy, 2013
; Demonstration of GEN16
; Envelope repeats once every two seconds therefore 1 second = 2048 table points
; Value 1 and Value 4 should probably be zero.
; Durations are specified in table points - 2048 = 1 second
; If the sum of durations exceeds table size they are automatically scaled down in order to prevent crashes.


<Cabbage>
form caption("GEN16"), size(325, 360), pluginid("gn16"), colour(100,100,110) style("legacy")

gentable bounds( 10,  5, 305, 120), tablenumber(1), tablecolour("lime"), identchannel("table"), zoom(-1), amprange(1,0,1)

#define SLIDER_SETTINGS #textBox(1), fontcolour("white"), textcolour("white"), trackercolour("silver")#

rslider bounds( 10,130, 50, 70), channel("val1"), text("Value.1"), range(0, 1, 0),   colour(80,80,80), $SLIDER_SETTINGS
rslider bounds( 70,130, 50, 70), channel("val2"), text("Value.2"), range(0, 1, 1),   colour(80,80,80), $SLIDER_SETTINGS
rslider bounds(130,130, 50, 70), channel("val3"), text("Value.3"), range(0, 1, 0.2), colour(80,80,80), $SLIDER_SETTINGS
rslider bounds(190,130, 50, 70), channel("val4"), text("Value.4"), range(0, 1, 0),   colour(80,80,80), $SLIDER_SETTINGS

rslider bounds( 40,205, 50, 70), channel("dur1"), text("Dur.1"), range(1, 4096, 80, 1, 1),   colour(80,80,80), $SLIDER_SETTINGS
rslider bounds(100,205, 50, 70), channel("dur2"), text("Dur.2"), range(1, 4096, 1000, 1, 1), colour(80,80,80), $SLIDER_SETTINGS
rslider bounds(160,205, 50, 70), channel("dur3"), text("Dur.3"), range(1, 4096, 3016, 1, 1), colour(80,80,80), $SLIDER_SETTINGS

rslider bounds( 40,280, 50, 70), channel("shp1"), text("Shape.1"), range(-20, 20, 3),   colour(80,80,80), $SLIDER_SETTINGS
rslider bounds(100,280, 50, 70), channel("shp2"), text("Shape.2"), range(-20, 20, -3),  colour(80,80,80), $SLIDER_SETTINGS
rslider bounds(160,280, 50, 70), channel("shp3"), text("Shape.3"), range(-20, 20, 1.5), colour(80,80,80), $SLIDER_SETTINGS

rslider bounds(265,130, 50, 70), channel("speed"), text("Speed"), range(0.25, 8.00, 0.5,0.5,0.001),  colour(80,80,80), $SLIDER_SETTINGS
rslider bounds(265,205, 50, 70), channel("freq"),  text("Freq."), range(50, 5000, 300,0.5,0.1),      colour(80,80,80), $SLIDER_SETTINGS
rslider bounds(265,280, 50, 70), channel("lev"),   text("Level"), range(0, 1.00, 0.5),               colour(80,80,80), $SLIDER_SETTINGS

line bounds(250,130,  2,220), colour("Grey")

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 	= 	32		; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 	= 	2		; NUMBER OF CHANNELS (1=MONO)
0dbfs	=	1		; MAXIMUM AMPLITUDE

opcode	butlpsr,a,aa					; butterworth lowpass filter with audio-rate variable cutoff frequency
	asig,acf	xin
		setksmps	1
	kcf	downsamp	acf
	asig	butlp	asig,kcf
		xout	asig
endop

instr	1
	; read in widgets
	gkval1	chnget	"val1"
	gkval2	chnget	"val2"
	gkval3	chnget	"val3"
	gkval4	chnget	"val4"

	gkdur1	chnget	"dur1"
	gkdur2	chnget	"dur2"
	gkdur3	chnget	"dur3"

	gkshp1	chnget	"shp1"
	gkshp2	chnget	"shp2"
	gkshp3	chnget	"shp3"

	; if any of the variables in the input list are changed, a momentary '1' trigger is generated at the output. This trigger is used to update function tables.
	ktrig	changed		gkval1,gkval2,gkval3,gkval4,gkdur1,gkdur2,gkdur3,gkshp1,gkshp2,gkshp3
	schedkwhen	ktrig,0,0,2,0,0.01	; call instrument 2 to update tables and some widgets
	
	kspeed	chnget	"speed"
	aphs	phasor	kspeed
	aamp	tablei	aphs,1,1
	kphs	downsamp	aphs
	;		chnset	kphs,"table"
	kamp	chnget	"lev"
	kfreq	chnget	"freq"
	asig	vco2	kamp, kfreq
	acf	=	cpsoct((aamp*5)+7)
	asig	butlpsr	asig, acf
	asig	=	asig * aamp

		outs	asig,asig
endin

instr	2
	; Update function table
	  if	(i(gkdur1)+i(gkdur2)+i(gkdur3))>4096 then
	   idur1	=	i(gkdur1)* (4096/(i(gkdur1)+i(gkdur2)+i(gkdur3)))
	   idur2	=	i(gkdur2)* (4096/(i(gkdur1)+i(gkdur2)+i(gkdur3)))
	   idur3	=	i(gkdur3)* (4096/(i(gkdur1)+i(gkdur2)+i(gkdur3)))
	  else
	   idur1	=	i(gkdur1)
	   idur2	=	i(gkdur2)
	   idur3	=	i(gkdur3)
	  endif
	gi1	ftgen	1, 0,   4096,-16, i(gkval1), idur1, i(gkshp1), i(gkval2), idur2, i(gkshp2), i(gkval3), idur3, i(gkshp3), i(gkval4)
	chnset	"tablenumber(1)", "table"	; update table display	
endin

</CsInstruments>

<CsScore>
; create the function table
f 1 0    4096 -16  1 0 0
; play instrument 1 for 1 hour
i 1 0 3600
</CsScore>

</CsoundSynthesizer>
; Demonstration of GEN17
; Written by Iain McCurdy, 2014.

; GEN17 is used to create histograms (step functions) in which the use defines locations and values. That value is then held until the next location is specified.

; In this example the histogram is used as a probability distribution from which notes are randomly chosen. Values define (midi) note numbers.

<Cabbage>
form caption("GEN17"), size(420, 395), pluginid("gn17"), colour(120,170,200, 50) style("legacy")

gentable bounds(  5,  5, 410, 115), identchannel("table1"), tablenumber(1), tablecolour("yellow"), amprange(24,72,1), zoom(-1), fill(0), outlinethickness(2)

groupbox bounds(0, 125,420,170), text("Histogram"), plant("histogram"), fontcolour("white"){
rslider bounds( 50, 25, 70, 70), channel("loc1"), text("Len. 1"), valuetextbox(1), textbox(1), range(1, 512, 24,1,1), colour(120,170,200,50), trackercolour("white")
rslider bounds(100, 25, 70, 70), channel("loc2"), text("Len. 2"), valuetextbox(1), textbox(1), range(1, 512, 64,1,1), colour(120,170,200,50), trackercolour("white")
rslider bounds(150, 25, 70, 70), channel("loc3"), text("Len. 3"), valuetextbox(1), textbox(1), range(1, 512, 64,1,1), colour(120,170,200,50), trackercolour("white")
rslider bounds(200, 25, 70, 70), channel("loc4"), text("Len. 4"), valuetextbox(1), textbox(1), range(1, 512, 34,1,1), colour(120,170,200,50), trackercolour("white")
rslider bounds(250, 25, 70, 70), channel("loc5"), text("Len. 5"), valuetextbox(1), textbox(1), range(1, 512, 64,1,1), colour(120,170,200,50), trackercolour("white")
rslider bounds(300, 25, 70, 70), channel("loc6"), text("Len. 6"), valuetextbox(1), textbox(1), range(1, 512, 84,1,1), colour(120,170,200,50), trackercolour("white")
rslider bounds(350, 25, 70, 70), channel("loc7"), text("Len. 7"), valuetextbox(1), textbox(1), range(1, 512, 64,1,1), colour(120,170,200,50), trackercolour("white")

rslider bounds(  0, 95, 70, 70), channel("val0"), text("Value 0"), valuetextbox(1), textbox(1), range(24, 127, 50,1,1), colour(120,170,200, 50), trackercolour("white")
rslider bounds( 50, 95, 70, 70), channel("val1"), text("Value 1"), valuetextbox(1), textbox(1), range(24, 72, 62,1,1),  colour(120,170,200, 50), trackercolour("white")
rslider bounds(100, 95, 70, 70), channel("val2"), text("Value 2"), valuetextbox(1), textbox(1), range(24, 72, 48,1,1),  colour(120,170,200, 50), trackercolour("white")
rslider bounds(150, 95, 70, 70), channel("val3"), text("Value 3"), valuetextbox(1), textbox(1), range(24, 72, 44,1,1),  colour(120,170,200, 50), trackercolour("white")
rslider bounds(200, 95, 70, 70), channel("val4"), text("Value 4"), valuetextbox(1), textbox(1), range(24, 72, 66,1,1),  colour(120,170,200, 50), trackercolour("white")
rslider bounds(250, 95, 70, 70), channel("val5"), text("Value 5"), valuetextbox(1), textbox(1), range(24, 72, 54,1,1),  colour(120,170,200, 50), trackercolour("white")
rslider bounds(300, 95, 70, 70), channel("val6"), text("Value 6"), valuetextbox(1), textbox(1), range(24, 72, 52,1,1),  colour(120,170,200, 50), trackercolour("white")
rslider bounds(350, 95, 70, 70), channel("val7"), text("Value 7"), valuetextbox(1), textbox(1), range(24, 72, 46,1,1),  colour(120,170,200, 50), trackercolour("white")
}


groupbox bounds(0, 295,420,100), text("Synthesiser"), plant("synth"), fontcolour("white"){
checkbox bounds( 15, 50,115, 17), channel("SynthOnOff"), text("On/Off"),  value(0), colour("yellow"), shape("square")
rslider  bounds( 75, 25, 70, 70), channel("lev"),  text("Level"), valuetextbox(1), textbox(1), range(0, 1.00, 0.7), colour(120,170,200, 50), trackercolour("white")
rslider  bounds(125, 25, 70, 70), channel("rate"), text("Rate"), valuetextbox(1),  textbox(1), range(0.2, 5.00, 1), colour(120,170,200, 50), trackercolour("white")
rslider  bounds(175, 25, 70, 70), channel("dur"),  text("Dur."), valuetextbox(1),  textbox(1), range(0.1, 3.00, 2), colour(120,170,200, 50), trackercolour("white")
}
</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE

; default histogram		
gihist	ftgen	1,0, 512, -17, 0, 48, 128, 84, 256, 72

instr	1
	iftlen	=	ftlen(1)		; length of function  table
	kftlen	init	iftlen
	
	; read in widgets
	kval0	chnget	"val0"
	kval1	chnget	"val1"
	kval2	chnget	"val2"
	kval3	chnget	"val3"
	kval4	chnget	"val4"
	kval5	chnget	"val5"
	kval6	chnget	"val6"
	kval7	chnget	"val7"

	kloc1	chnget	"loc1"
	kloc2	chnget	"loc2"
	kloc3	chnget	"loc3"
	kloc4	chnget	"loc4"
	kloc5	chnget	"loc5"
	kloc6	chnget	"loc6"
	kloc7	chnget	"loc7"

	kloc1	init	64
	kloc2	init	64
	kloc3	init	64
	kloc4	init	64
	kloc5	init	64
	kloc6	init	64
	kloc7	init	64

	gklev	chnget	"lev"
	gkSynthOnOff	chnget	"SynthOnOff"
	gkrate	chnget	"rate"
	gkdur	chnget	"dur"
	
	ktrig	changed		kval0,kval1,kval2,kval3,kval4,kval5,kval6,kval7, kloc1,kloc2,kloc3,kloc4,kloc5,kloc6,kloc7
	if ktrig==1 then	; peg rate of update. Tables updated at this rate. If too slow, glitching will be heard in the output, particularly if random movement speed is high. If too high CPU performance will suffer.
	 reinit	UPDATE
	endif
	UPDATE:
	gihist	ftgen	1,0, iftlen, -17, 0, i(kval0), i(kloc1),\ 
	                                     i(kval1), i(kloc1)+i(kloc2), \
	                                     i(kval2), i(kloc1)+i(kloc2)+i(kloc3), \
	                                     i(kval3), i(kloc1)+i(kloc2)+i(kloc3)+i(kloc4), \
	                                     i(kval4), i(kloc1)+i(kloc2)+i(kloc3)+i(kloc4)+i(kloc5), \
	                                     i(kval5), i(kloc1)+i(kloc2)+i(kloc3)+i(kloc4)+i(kloc5)+i(kloc6), \
	                                     i(kval6), i(kloc1)+i(kloc2)+i(kloc3)+i(kloc4)+i(kloc5)+i(kloc6)+i(kloc7), \
	                                     i(kval7)
	rireturn

	if ktrig==1 then			; 
	 chnset	"tablenumber(1)", "table1"	; update table display	
	endif
	
	; TRIGGER SOME NOTES
	kNoteTrig	init	1
	krate	rspline	0.5,2,0.01,0.1
	krhy	trandom	kNoteTrig,0,3
	kNoteTrig	metro	gkrate*krate*(2^int(krhy))
	schedkwhen	kNoteTrig*gkSynthOnOff,0,0,2,0,gkdur
endin

; SCALE FOR REFLECTION DEPENDENT UPON MIDI NOTE NUMBER (LESS DAMPING FOR HIGHER NOTES)
giScal	ftgen	0,0,128, -27,  0, 0.9, 24, 0.9, 36, 0.85, 48, 0.75, 60, 0.65, 72, 0.35, 84, 0.001, 96, 0.001, 127;, 0.001
;giScal	ftgen	0,0,128, -27,  0, 0.983, 24, 0.983, 36, 0.971, 48, 0.939, 60, 0.855, 72, 0.747, 84, 0.364, 96, 0.001, 127


instr	2
	iNote table     rnd(1),gihist,1					; read a random value from the function table
	aEnv  linsegr	0, 0.005, 1, p3-0.105, 1, 0.1, 0		; amplitude envelope
	iPlk  random	0.1, 0.3					; point at which to pluck the string
	iDtn  random    -0.05, 0.05					; random detune
	irefl	table	iNote, giScal					; read reflection value from giScal table according to note number  
	aSig  wgpluck2  0.58, gklev*0.5, cpsmidinn(iNote+iDtn), iPlk, irefl	; generate Karplus-Strong plucked string audio 
	kcf	expon	cpsoct(rnd(6)+6),p3,50				; filter cutoff frequency envelope
	aSig	clfilt	aSig, kcf, 0, 2					; butterworth lowpass filter	
	aL,aR pan2      aSig * aEnv, rnd(0.5)+0.5			; random panning   
	      outs      aL, aR						; send audio to outputs
endin


</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; GEN19.csd
; Written by Iain McCurdy, 2015

; GEN19 is an elaboration of GEN10 and GEN09 in that as well as offering control over partial number, strength and
; phase, we also have control over DC offset.

; In this example the GEN19 table is used as a 'terrain' rather than as an audio waveform.
; A small ball travels along the function as if threaded onto it. It responds to the contours of the wave 
; as if under the influence of gravity. As it travels it plays short sound pulses. The faster it moves the more 
; more frequently these pulses are generated and the louder they are, the higher it is, the higher in pitch these 
; pulses are.
; The shape of the GEN19 function is continually modulated by rspline random functions. The frequency of modulation
; for partial strength, phase and DC offset are set globally for all partials. Note that if an rspline frequency value
; is low, changes to frequency can take longer to take effect. The amplitude of modulation for the three partial 
; attributes can be set individually for each partial.

; CONTROLS
; --------
; Str.Rate	-	rate of partial strength modulation for all partials
; Phase Rate	-	rate of phase modulation for all partials
; DC Rate	-	rate of DC offset modulation for all partials
; Normalise	-	turns normalisation on or off for the GEN19 function
;			note that if normalisation is, off strength amplitudes may need to be lowered in order to keep
;			the function within the range of the gentable viewer.
; Sound On/Off	-	turns the sound on or off
; Speed		-	overall speed control for the sliding ball
; Friction	-	increasing this beyond zero adds an increasing amount of friction damping the movement of the 
;			ball. This can be useful to prevent constant movment of the ball in one direction.
; Density	-	Density of the sound impulses

; For each partial there are the following controls:
; Active	-	turns each partial on or off
; P.N.		-	partial number
; Str.		-	Amplitude of the random modulations of strength
; Phs.		-	Amplitude of the random modulations of phase
; DC		-	Amplitude of the random modulations of DC offset

			 
<Cabbage>
form caption("GEN19"), size(560, 490), pluginid("gn19"), guirefresh(32), colour(0,0,0) style("legacy")

gentable bounds(  0,  5, 560, 120), tablenumber(1), tablecolour("silver"), identchannel("table"), outlinethickness(2), amprange(-1,1,1), zoom(-1), tablegridcolour(0,0,0,0), tablebackgroundcolour(0,0,0), fill(0)
image   bounds(-50,-50, 10, 10), colour(250,150, 55), identchannel("ball"), shape("ellipse")

rslider  bounds(  5,140, 60, 60), channel("AmpRte"), text("Str.Rate"),   range(0.1, 5, 0.2,0.5,0.001)
rslider  bounds( 65,140, 60, 60), channel("PhsRte"), text("Phase Rate"), range(0.1, 5, 0.2,0.5,0.001)
rslider  bounds(125,140, 60, 60), channel("DCRte"),  text("DC Rate"),    range(0.1, 5, 0.2,0.5,0.001)
checkbox bounds(200,150,130,15), channel("Norm"), text("Normalise"), value(1)
checkbox bounds(200,170,130,15), channel("Sound"), text("Sound On/Off"), value(1)
rslider  bounds(315,140, 60, 60), channel("Speed"),  text("Speed"),    range(0.1, 16,   1,0.5,0.001)
rslider  bounds(375,140, 60, 60), channel("Friction"),  text("Friction"),    range(0,1,0.03,0.5,0.001)
rslider  bounds(435,140, 60, 60), channel("Density"),  text("Density"),    range(10,200,50,1,1)
rslider  bounds(495,140, 60, 60), channel("Level"),  text("Level"),    range(0,2,1,0.5,0.001)
line     bounds( 20,210,520,  3), colour("Grey")

button   bounds( 10,225, 50, 20), channel("On1"), text("Active"), value(1), fontcolour:0(50,50,50), fontcolour:1(255,255,0)
combobox bounds( 10,250, 50, 20), channel("PN1"), text(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), value(1)
label    bounds( 15,270, 40, 12), text("P.N.")
rslider  bounds(  5,290, 60, 60), channel("Amp1"), text("Str."),   range(0, 1, 0.5,1,0.001)
rslider  bounds(  5,355, 60, 60), channel("Phs1"), text("Phs."),   range(0,360,180,1,0.001)
rslider  bounds(  5,420, 60, 60),  channel("DC1"),  text("DC."),   range(0, 1, 0.5,1,0.001)

button   bounds( 80,225, 50, 20), channel("On2"), text("Active"), value(1), fontcolour:0(50,50,30), fontcolour:1(255,255,0)
combobox bounds( 80,250, 50, 20), channel("PN2"), text(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), value(2)
label    bounds( 85,270, 40, 12), text("P.N.")
rslider  bounds( 75,290, 60, 60), channel("Amp2"), text("Str."),   range(0, 1, 0.5,1,0.001)
rslider  bounds( 75,355, 60, 60), channel("Phs2"), text("Phs."),   range(0,360,180,1,0.001)
rslider  bounds( 75,420, 60, 60),  channel("DC2"),  text("DC."),   range(0, 1, 0.5,1,0.001)

button   bounds(150,225, 50, 20), channel("On3"), text("Active"), value(1), fontcolour:0(50,50,30), fontcolour:1(255,255,0)
combobox bounds(150,250, 50, 20), channel("PN3"), text(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), value(3)
label    bounds(155,270, 40, 12), text("P.N.")
rslider  bounds(145,290, 60, 60), channel("Amp3"), text("Str."),   range(0, 1, 0.5,1,0.001)
rslider  bounds(145,355, 60, 60), channel("Phs3"), text("Phs."),   range(0,360,180,1,0.001)
rslider  bounds(145,420, 60, 60),  channel("DC3"),  text("DC."),   range(0, 1, 0.5,1,0.001)

button   bounds(220,225, 50, 20), channel("On4"), text("Active"), value(1), fontcolour:0(50,50,30), fontcolour:1(255,255,0)
combobox bounds(220,250, 50, 20), channel("PN4"), text(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), value(4)
label    bounds(225,270, 40, 12), text("P.N.")
rslider  bounds(215,290, 60, 60), channel("Amp4"), text("Str."),   range(0, 1, 0.5,1,0.001)
rslider  bounds(215,355, 60, 60), channel("Phs4"), text("Phs."),   range(0,360,180,1,0.001)
rslider  bounds(215,420, 60, 60),  channel("DC4"),  text("DC."),   range(0, 1, 0.5,1,0.001)

button   bounds(290,225, 50, 20), channel("On5"), text("Active"), value(0), fontcolour:0(50,50,30), fontcolour:1(255,255,0)
combobox bounds(290,250, 50, 20), channel("PN5"), text(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), value(5)
label    bounds(295,270, 40, 12), text("P.N.")
rslider  bounds(285,290, 60, 60), channel("Amp5"), text("Str."),   range(0, 1, 0.5,1,0.001)
rslider  bounds(285,355, 60, 60), channel("Phs5"), text("Phs."),   range(0,360,180,1,0.001)
rslider  bounds(285,420, 60, 60),  channel("DC5"),  text("DC."),   range(0, 1, 0.5,1,0.001)

button   bounds(360,225, 50, 20), channel("On6"), text("Active"), value(0), fontcolour:0(50,50,30), fontcolour:1(255,255,0)
combobox bounds(360,250, 50, 20), channel("PN6"), text(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), value(6)
label    bounds(365,270, 40, 12), text("P.N.")
rslider  bounds(355,290, 60, 60), channel("Amp6"), text("Str."),   range(0, 1, 0.5,1,0.001)
rslider  bounds(355,355, 60, 60), channel("Phs6"), text("Phs."),   range(0,360,180,1,0.001)
rslider  bounds(355,420, 60, 60),  channel("DC6"),  text("DC."),   range(0, 1, 0.5,1,0.001)

button   bounds(430,225, 50, 20), channel("On7"), text("Active"), value(0), fontcolour:0(50,50,30), fontcolour:1(255,255,0)
combobox bounds(430,250, 50, 20), channel("PN7"), text(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), value(7)
label    bounds(435,270, 40, 12), text("P.N.")
rslider  bounds(425,290, 60, 60), channel("Amp7"), text("Str."),   range(0, 1, 0.5,1,0.001)
rslider  bounds(425,355, 60, 60), channel("Phs7"), text("Phs."),   range(0,360,180,1,0.001)
rslider  bounds(425,420, 60, 60),  channel("DC7"),  text("DC."),   range(0, 1, 0.5,1,0.001)

button   bounds(500,225, 50, 20), channel("On8"), text("Active"), value(0), fontcolour:0(50,50,30), fontcolour:1(255,255,0)
combobox bounds(500,250, 50, 20), channel("PN8"), text(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16), value(8)
label    bounds(505,270, 40, 12), text("P.N.")
rslider  bounds(495,290, 60, 60), channel("Amp8"), text("Str."),   range(0, 1, 0.5,1,0.001)
rslider  bounds(495,355, 60, 60), channel("Phs8"), text("Phs."),   range(0,360,180,1,0.001)
rslider  bounds(495,420, 60, 60),  channel("DC8"),  text("DC."),   range(0, 1, 0.5,1,0.001)

label bounds(0,480,100,10), text("Iain McCurdy |2015|")
</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	;MAXIMUM AMPLITUDE

seed	0	; seed random number generators for the system clock
opcode	scale_i,i,iii
 ival,imax,imin	xin
 ival	=	(ival * (imax-imin)) + imin
	xout	ival
endop

instr	1
	kPhsrSpd	init	0.1		; initial phasor speed
	kSpeed		chnget	"Speed"		; speed
	kphasor	phasor	kPhsrSpd		; phasor that moves the 'ball'
	kAmpMod	chnget	"AmpRte"		; random partial strength modulation frequency
	kPhsMod	chnget	"PhsRte"		; random phase modulation frequency
	kDCMod	chnget	"DCRte"			; random DC offset modulation frequency
	kNorm	chnget	"Norm"			; normalise on/off
	kSound	chnget	"Sound"			; sound on/off
	kFriction	chnget	"Friction"	; friction
	kDensity	chnget	"Density"	; sound pulse density

	; define a macro to read in and process attributes for each partial
	#define	MOD_PARTIAL(N)
	#
	kOn$N	chnget	"On$N"						; partial on/off (active switch)
	kPN$N	chnget	"PN$N"						; partial number
	kamp	chnget	"Amp$N"						; amount of strength modulation
	kphs	chnget	"Phs$N"						; amount of phase modulation
	kDC	chnget	"DC$N"						; amount of DC offset modulation
	kamp$N	rspline		0,kamp,    kAmpMod,kAmpMod		; random partial strength function
	kamp$N	limit		kamp$N,-1,1				; limit it (rspline can otherwise exceed its given limits)
	kphs$N	rspline		-kphs,kphs,    kPhsMod,kPhsMod		; random phase function
	kDC$N	rspline		-kDC,kDC,      kDCMod, kDCMod		; random DC offset function
	kDC$N	limit		kDC$N,-1,1				; limit it (rspline can otherwise exceed its given limits)
	#
	; expand macro for each partial required
	$MOD_PARTIAL(1)
	$MOD_PARTIAL(2)
	$MOD_PARTIAL(3)
	$MOD_PARTIAL(4)
	$MOD_PARTIAL(5)
	$MOD_PARTIAL(6)
	$MOD_PARTIAL(7)
	$MOD_PARTIAL(8)
	
	kmetro	metro	16			; a metronome trigger used to restrict the rate of updates
	if kmetro==1 then			; if trigger is generated...
	 reinit REBUILD_TABLE			; ... do a reinit in order to rebuild the table
	endif
	REBUILD_TABLE:
	 iNorm	=	(i(kNorm) * 2) -1	; Normalise value: 0 to 1 mapped to -1 to 1
	 ; create the new updated table
	 gifun	ftgen	1,0,512,19*iNorm,	i(kPN1),i(kamp1)*i(kOn1),i(kphs1),i(kDC1)*i(kOn1),	\
	  					i(kPN2),i(kamp2)*i(kOn2),i(kphs2),i(kDC2)*i(kOn2),	\
	  					i(kPN3),i(kamp3)*i(kOn3),i(kphs3),i(kDC3)*i(kOn3),	\
	  					i(kPN4),i(kamp4)*i(kOn4),i(kphs4),i(kDC4)*i(kOn4),	\
	  					i(kPN5),i(kamp5)*i(kOn5),i(kphs5),i(kDC5)*i(kOn5),	\
	  					i(kPN6),i(kamp6)*i(kOn6),i(kphs6),i(kDC6)*i(kOn6),	\
	  					i(kPN7),i(kamp7)*i(kOn7),i(kphs7),i(kDC7)*i(kOn7),	\
	  					i(kPN8),i(kamp8)*i(kOn8),i(kphs8),i(kDC8)*i(kOn8)
	rireturn				; out of reinit
	if kmetro==1 then			; if trigger was '1' (i.e. and table was updated...
	 chnset	"tablenumber(1)", "table"	; update the table 'view'
	 kndx	=	ftlen(gifun)*kphasor	; convert phasor (0 to 1) to raw index (0 to 512(table size))
	 kval	table	kphasor,gifun,1		; read value from table (used to calculate ball graphical height
	 k1	table	kndx-1,gifun		; read the value before the widget location
	 k2	table	kndx+1,gifun		; read the value after the widget location
	 kDlta	=	k2 - k1					; difference between the next table value and the previous table value to the ball location. This indicates slope (magnitude) and direction (sign)
	 kPhsrSpd	=	kPhsrSpd - (kDlta*kSpeed)	; acceleration/deceleration due to gravity 
	 kPhsrSpd	=	kPhsrSpd * (1-(0.1*kFriction*(kSpeed^0.25)))	; friction
	 
	 ; move the 'ball' widget (account for ball size, n.b. widget location refers to the top left hand corner)
	 Smsg	sprintfk	"pos(%d,%d)", (kphasor*560)-5, 60+(120*-(kval*0.5))
	 	chnset		Smsg,"ball"
	endif
	
	ktrig	metro	abs(kPhsrSpd)*kDensity	; trigger for sound pulses. Density depends on ball speed (regardless of direction (abs)) and Density slider
	schedkwhen	ktrig*kSound,0,0,2,0,0.3,kval,abs(kPhsrSpd),kphasor	; trigger a sound pulse and send it table value (height), widget speed and y position as p4,p5 and p6

endin

instr	2	; sound pulse
	ispd	limit	p5,0.05,0.4		; limit speed values. Otherwise when the ball move very fast the sound sound gets too loud.
	asig	mpulse	0.2*(ispd^2),0		; generate a click
	icfoct	scale_i	(p4*0.5)+1,10,5		; derive a pitch value (in oct) from ball height
	icfoct	limit	icfoct,4,12		; convert to CPS (and limit - use of unnormalised GEN19 can result in tables that extend way beyond the graphical limits)
	iLevel	chnget	"Level"
	asig	reson	asig*100*iLevel,cpsoct(icfoct),cpsoct(icfoct)*0.05,2	; filter the click to produce a note
	aL,aR	pan2	asig,p6		; pan the click
	aL	delay	aL,0.01*(1-p6)		; spatialise
	aR	delay	aR,0.01*p6		;
		outs	aL,aR
endin


</CsInstruments>

<CsScore>
i 1 0 3600
</CsScore>

</CsoundSynthesizer>
; GEN20.csd
; Written by Iain McCurdy, 2014

<Cabbage>
form caption("GEN20"), size(410, 230), pluginid("gn20"), colour("20,70,170,150") style("legacy")

gentable bounds(  5,  5, 400, 120), tablenumber(1), identchannel("table1"), zoom(-1), amprange(0,1,1), tablecolour("LightSlateGrey"), zoom(-1), tablebackgroundcolour("white"), fill(0), outlinethickness(2) tablegridcolour(220,220,220)

combobox bounds(130, 130, 175,20), channel("window"), value(1), text("Hamming","Hanning","Bartlett [Triangle]","Blackman [3-term]","Blackman-Harris [4-term]","Gaussian","Kaiser","Rectangle","Sync.")

hslider  bounds(  5,150,340, 30), text("Option"), channel("opt"), range(0, 10.00, 1, 0.5), valuetextbox(1), textbox(1), trackercolour("yellow"), fontcolour("white")
label    bounds(  3,172,110, 11), text("[Gaussian & Kaiser]"),  fontcolour("white")
checkbox bounds(345,158, 55, 13), text("x 100") channel("x100"), colour("yellow"), fontcolour("white"),  value(0)

image bounds(-5,-125,4,4), colour("red"), identchannel("scrubber"), shape("sharp")

nslider  bounds(  5,190, 50, 30), text("Index"), channel("ndx"), range(0, 4095,1024, 1,1),      fontcolour("white")
nslider  bounds( 65,190, 50, 30), text("Value"), channel("val"), range(0,    1, 0, 1,0.0001), fontcolour("white")

checkbox bounds(160,200,100, 13), text("Tone On/Off") channel("ToneOnOff"), colour("yellow"), fontcolour("white"),  value(0)

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE
			
giwindow	ftgen	1,0,4096,20,1,1,1

instr	1
	iTabSize	=	ftlen(giwindow)
	
	; read in widgets
	gkwindow	chnget	"window"
	gkndx		chnget	"ndx"
	gkndx		init	1024
	gkwindow	init	1
	gkopt	chnget	"opt"
	gkopt	init	1
	gkx100	chnget	"x100"
	gkToneOnOff	chnget	"ToneOnOff"
	
	ktrig1	changed	gkwindow
	ktrig2	changed	gkopt,gkx100
	if ktrig1==1 || ( (ktrig2==1&&(gkwindow==6||gkwindow==7))) then
	 reinit UPDATE
	endif
	UPDATE:
	 giwindow	ftgen	1,0,ftlen(giwindow),20,i(gkwindow),1,i(gkopt)* ((i(gkx100)*99)+1)
	rireturn
	if ktrig1==1||ktrig2==1 then
	 chnset	"tablenumber(1)", "table1"	; update table display	
	endif
	
	; Read index input and print value
	kval	table	gkndx,giwindow
	if changed(kval)==1||changed(gkndx)==1 then
	 kval	table	gkndx,giwindow
	 	chnset	kval,"val"
	 kxpos	=	5 + (400 * (gkndx/iTabSize))
	 kypos	=	5 + (120 * (1-kval))	 
	 Smess	sprintfk	"bounds(%d,%d,2,%d)",kxpos-2,kypos+1,125-kypos-2
	 	chnset		Smess,"scrubber"
	endif
	
	; CREATE A SOUND
	aenv	poscil	0.05*gkToneOnOff,1,giwindow
	asig	vco2	1,440,4,0.5
	asig	*=		aenv
			outs	asig,asig
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
e
</CsScore>

</CsoundSynthesizer>
; GEN21.csd
; Written by Iain McCurdy

; demonstration of the GEN21 opcode, used to create various random distributions

; changing the value given for giTabSize (in instrument header area) and the value for 'drawmode' (part of the table widget) can change the appearance of the distribution.

; display is set between -1 and 1. Certain distributions may require reduction of the 'level' control in order for them to be fully displayed

<Cabbage>
form caption("GEN21"), size(410, 220), pluginid("gn21"), colour( 40,110, 80) style("legacy")

gentable bounds(  5,  5, 400, 120), tablenumber(1), tablecolour("lime"), identchannel("table1"), amprange(-1,1,1), fill(0)

combobox bounds( 10, 130, 200,20), channel("dist"), value(1), text("Uniform [pos.]","Linear [pos.]","Triangular [pos. and neg.]","Exponential [pos.]","Biexponential [pos. and neg.]","Gaussian [pos. and neg.]","Cauchy [pos. and neg.]","Cauchy [pos.]","Beta","Weibull","Poisson")
checkbox bounds( 10, 160, 100,14), channel("AudOnOff"), text("Audio On/Off")
rslider  bounds(210, 130, 80, 80), text("Level"), channel("level"), range(0, 1.00, 1,0.5,0.001), textbox(1), valuetextbox(1), colour(20, 90, 60), trackercolour("yellow"), fontcolour("white")
rslider  bounds(270, 130, 80, 80), text("Arg.1"), channel("arg1"),  range(0, 1.00, 1), textbox(1), valuetextbox(1), colour(20, 90, 60), trackercolour("yellow"), fontcolour("white"), visible(0), identchannel("ident_arg1")
rslider  bounds(330, 130, 80, 80), text("Arg.2"), channel("arg2"),  range(0, 1.00, 1), textbox(1), valuetextbox(1), colour(20, 90, 60), trackercolour("yellow"), fontcolour("white"), visible(0), identchannel("ident_arg2")

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE

giTabSize	=	128	

gi_ ftgen	1,0,giTabSize,10,1

instr	1
	; read in widgets
	gkdist	chnget	"dist"
	gklevel	chnget	"level"
	gkarg1	chnget	"arg1"
	gkarg2	chnget	"arg2"
	gkdist	init	1
	
	ktrig	changed	gkdist,gklevel,gkarg1,gkarg2
	if ktrig==1 then
	 reinit UPDATE
	endif
	UPDATE:
	if i(gkdist)==9 then
	 chnset "visible(1)", "ident_arg1"
	 chnset "visible(1)", "ident_arg2"
	elseif i(gkdist)==10 then
	 chnset "visible(1)", "ident_arg1"
	 chnset "visible(0)", "ident_arg2"
	else
	 chnset "visible(0)", "ident_arg1"
	 chnset "visible(0)", "ident_arg2"
	endif
	idist	ftgen	1,0,giTabSize,-21,i(gkdist),i(gklevel),i(gkarg1),i(gkarg2)
	iaud	ftgen	2,0,2^18,-21,i(gkdist),i(gklevel),i(gkarg1),i(gkarg2)
	rireturn
	if ktrig==1 then
	 chnset	"tablenumber(1)", "table1"	; update table display	
	endif
	
	kAudOnOff	chnget	"AudOnOff"
	asig	poscil	0.1*kAudOnOff, sr/(2^18), iaud
			outs	asig,asig
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
e
</CsScore>

</CsoundSynthesizer>
; GEN30.csd
; Written by Iain McCurdy, 2014
; 
; GEN30 creates band limited versions of input harmonic waveforms. 
; Typically an input waveform is created using GEN07.
; The user can then define the limits, in terms of partial numbers, in the output waveform.
; If 'Interpolation' is on fractional settings for minimum and maximum partial numbers will fade the partials at the extremities of the spectrum in or out smoothly. 
; The input waveform is displayed in green, the output in yellow.

<Cabbage>
form caption("GEN30"), size(410, 290), pluginid("gn30"), colour(80, 30, 50) style("legacy")
gentable bounds(  5,  5, 400, 120), identchannel("table1"), tablenumber(1,2), tablecolour("lime","yellow"), tablecolour:0("lime"), tablecolour:1("yellow"), fill(0), outlinethickness(2), tablegridcolour(0,0,0,0)

label    bounds(348,130, 60, 10), text("SOURCE"), fontcolour("lime"), align("right")
label    bounds(348,140, 60, 10), text("RESULT"), fontcolour("yellow"), align("right")

label    bounds(  5, 136, 80, 12), text("Source")
combobox bounds(  5, 150, 80, 20), channel("src"), value(1), text("Sawtooth","Square","Triangle","Pulse")

rslider  bounds( 90,140, 80, 80), channel("minh"), text("Min.Harm."), textbox(1), valuetextbox(1), range(1.00, 100, 1), TrackerColour("yellow")
rslider  bounds(170,140, 80, 80), channel("maxh"), text("Max.Harm."), textbox(1), valuetextbox(1), range(1.00, 100, 20), TrackerColour("yellow")
rslider  bounds( 20,170, 50, 50), channel("pw"), text("P.W."), textbox(1), valuetextbox(1), range(1, 2048, 16,1,1), TrackerColour("yellow"), identchannel("pwID")
label    bounds(250,138, 80, 12), text("Listen to:")
button   bounds(250,152, 80, 18), text("SOURCE","RESULT"), channel("ListenTo"), value(1), fontcolour:0("yellow"), fontcolour:1("lime")
checkbox bounds(250,172,100, 14), channel("OnOff"),  value(0), text("Tone On/Off"), colour("yellow")
checkbox bounds(250,188,100, 14), channel("interp"),  value(1), text("Interpolate")
checkbox bounds(250,204,100, 14), channel("norm"),  value(1), text("Normalise"), colour("LightBlue")
hslider  bounds(  5,220,400, 30), channel("frq"), text("Freq."), textbox(1), valuetextbox(1), range(1, 5000, 200,0.5,1), TrackerColour("yellow")
hslider  bounds(  5,250,400, 30), channel("amp"), text("Ampl."), textbox(1), valuetextbox(1), range(0,    1, 0.1), TrackerColour("yellow")
</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE

gisaw	ftgen	101,0,4096,7,1,4096,-1
gisq	ftgen	102,0,4096,7,1,2048,1,0,-1,2048,-1
gitri	ftgen	103,0,4096,7,0,1024,1,2048,-1,1024,0
gipls	ftgen	104,0,4096,7,1,16,1,0,0,4096-16,0

gidisp	ftgen	2,0,4096,7,1,4096,-1

instr	1
 gkminh		chnget	"minh"
 gkmaxh		chnget	"maxh"
 gkinterp	chnget	"interp"
 gknorm		chnget	"norm"
 gksrc		chnget	"src"
 gkOnOff	chnget	"OnOff"
 gkfrq		chnget	"frq"
 gkamp		chnget	"amp"
 gkpw		chnget	"pw"
 gkListenTo	chnget	"ListenTo"
 gksrc	init	1
 kporttime	linseg	0,0.001,0.05
 gkfrq		portk	gkfrq, kporttime
 gkamp		portk	gkamp, kporttime
   
 if ( (gkfrq*gkmaxh) >= (sr/2) ) then
  chnset	gkmaxh-1,"maxh"
 endif 
    
 ; SHOW OR HIDE WIDGETS -------------------------------------
 kchange	changed	gksrc
 if(kchange==1) then
	if gksrc==4 then
	 chnset "visible(1)", "pwID"
	else
	 chnset "visible(0)", "pwID"
	endif
 endif
; -----------------------------------------------------------

 ktrig	changed	gkminh,gkmaxh,gksrc,gkinterp,gknorm, gkpw	; If any of the input arguments are changed generate a trigger (momentary '1').
 if ktrig==1 then					; If a trigger has been generated...
  reinit	REBUILD_WAVEFORM			; ...reinitialise from label
 endif
 REBUILD_WAVEFORM:
 inorm	=	(i(gknorm)==1?1:-1)
 gipls	ftgen	104, 0, 4096, 7, 1,i(gkpw),1,0,0,4096-i(gkpw),0
 ifn	ftgen	1, 0, 4096, 30*inorm, gisaw+i(gksrc)-1, i(gkminh), i(gkmaxh),sr,i(gkinterp)	; generate a waveform based on chosen source waveform with user-set modifications
 	tableicopy gidisp, gisaw+i(gksrc)-1
 rireturn

 if ktrig==1 then
  chnset	"tablenumber(2,1)", "table1"	; update table display	
 endif

 if gkOnOff==1 then					; if 'Play Tone' is activated
  if gkListenTo==0 then
   asig	oscili	gkamp, gkfrq, 2				; audio oscillator using GEN30 waveform
  else
   asig	oscili	gkamp, gkfrq, 1				; audio oscillator using GEN30 waveform
  endif  
 	outs	asig,asig
 endif
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; GEN33.csd
; Written by Iain McCurdy, 2014
; 
; GEN33 generates a harmonic waveform based on data stored in another table. 
; The data for each partial in the second table is stored in the form: Strength, Partial Number / Frequency, Phase, for each partial.
; Therefore data for 10 partials would be stored using 30 items of data. GEN02 is normally used for this purpose.
; 
; In this example the user can select from a number of data sets of partial using a combobox.
; The number of partials contained within the chosen data set is displayed below the combobox.
; 
; When the GEN33 table is created the user can choose to limit the number of partials used.
; 
; In this example the GEN33 table can be auditioned and interacted with manually using the controls in the first groupbox
; or it can be played from the MIDI keyboard in which case key velocity is mapped to the number of partials used by GEN33
; thereby implementing a kind of velocity to brightness mechanism.


<Cabbage>
form caption("GEN33"), size(520, 320), pluginid("gn33") style("legacy")
gentable bounds(  0,  0, 520, 120), identchannel("table1"), tablenumber(1), tablecolour("yellow"), zoom(-1), , fill(0), amprange(1,-1,1)


groupbox bounds(0, 120,370,120), text("Manual Control"), plant("Manual"), fontcolour("white"){
checkbox bounds( 10, 30,110, 20), channel("ManualOnOff"),  value(0), text("Test On/Off")
label    bounds( 10, 50,140, 11), text("Source")
combobox bounds( 10, 61,140, 20), channel("source"), value(1), text("Tubular Bell","Chladni Plates","Tibetan Bowl 180mm","Tibetan Bowl 152mm","Tibetan Bowl 140mm","Small Handbell","Spinel Sphere","Clarinet")

label     bounds( 10, 82,100, 11), text("Maximum Harms:"), fontcolour("white"), align(left)
nslider bounds( 110, 81, 40, 15), text(""), fontcolour(white), channel("NumPartials"), range(0, 100, 0,1,1)

rslider  bounds(150, 30, 80, 80), channel("nh"), text("Num.Harms."), valuetextbox(1), textbox(1), range(1,25,25,1,1), TrackerColour("yellow"), colour(200,200,200)
rslider  bounds(220, 30, 80, 80), channel("amp"), text("Amp."), valuetextbox(1), textbox(1), range(0,1.000,0.1,0.5), TrackerColour("yellow"), colour(200,200,200)
rslider  bounds(290, 30, 80, 80), channel("frq"), text("Freq."), valuetextbox(1), textbox(1), range(5,1000.000,520,0.5), TrackerColour("yellow"), colour(200,200,200)
}

groupbox bounds(370,120,150,120), text("MIDI [Keyboard]"), plant("MIDI"), fontcolour("white"){
rslider  bounds(  0, 30, 80, 80), channel("DecTim"), text("Dec.Time"), valuetextbox(1), textbox(1), range(0.1,15.00,8,0.5), TrackerColour("yellow"), colour(200,200,200)
rslider  bounds( 70, 30, 80, 80), channel("RelTim"), text("Rel.Tim"), valuetextbox(1),  textbox(1), range(0.1,15.00,8,0.5), TrackerColour("yellow"), colour(200,200,200)
}

keyboard bounds(  0,240,520, 80)
</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE
	massign	0,3	; assign midi notes on all channels to instrument 3

; partial frequency data 		strength	frequency	phase
; tubular bell
gidata1		ftgen	0,0,-10*3,-2,	1,		272,		0,\ 
					1,		538,		0,\ 
					1,		874,		0,\ 
					1,		1281,		0,\ 
					1,		1755,		0,\ 
					1,		2264,		0,\ 
					1,		2813,		0,\ 
					1,		3389,		0,\ 
					1,		4822,		0,\ 
					1,		5255,		0

;Chladni plates 	
gidata2		ftgen	0,0,-5*3,-2,	1,		62,		0,\
					1,		107,            0,\
					1,		360,            0,\
					1,		460,            0,\
					1,		863,            0

;tibetan bowl (180mm) 	
gidata3		ftgen	0,0,-7*3,-2,	1,		221,		0,\
					1,		614,            0,\
					1,		1145,           0,\
					1,		1804,           0,\
					1,		2577,           0,\
					1,		3456,           0,\
					1,		4419,           0

;tibetan bowl (152 mm)
gidata4		ftgen	0,0,-7*3,-2,	1,		314,		0,\
					1,		836,            0,\
					1,		1519,           0,\
					1,		2360,           0,\
					1,		3341,           0,\
					1,		4462,           0,\
					1,		5696,           0

;tibetan bowl (140 mm) 	
gidata5		ftgen	0,0,-5*3,-2,	1,		528,		0,\
					1,		1460,           0,\
					1,		2704,           0,\
					1,		4122,           0,\
					1,		5694,           0

;small handbell
gidata6		ftgen	0,0,-22*3,-2,	1,		1312.0,		0,\ 
					1,		1314.5,         0,\
					1,		2353.3,         0,\
					1,		2362.9,         0,\
					1,		3306.5,         0,\
					1,		3309.4,         0,\
					1,		3923.8,         0,\
					1,		3928.2,         0,\
					1,		4966.6,         0,\
					1,		4993.7,         0,\
					1,		5994.4,         0,\
					1,		6003.0,         0,\
					1,		6598.9,         0,\
					1,		6619.7,         0,\
					1,		7971.7,         0,\
					1,		7753.2,         0,\
					1,		8413.1,         0,\
					1,		8453.3,         0,\
					1,		9292.4,         0,\
					1,		9305.2,         0,\
					1,		9602.3,         0,\
					1,		9912.4,         0

;spinel sphere
gidata7		ftgen	0,0,-25*3,-2,	1,		977.25,		0,\
					1,		1003.16,        0,\
					1,		1390.13,        0,\
					1,		1414.93,        0,\
					1,		1432.84,        0,\
					1,		1465.34,        0,\
					1,		1748.48,        0,\
					1,		1834.20,        0,\
					1,		1919.90,        0,\
					1,		1933.64,        0,\
					1,		1987.20,        0,\
					1,		2096.48,        0,\
					1,		2107.10,        0,\
					1,		2202.08,        0,\
					1,		2238.40,        0,\
					1,		2280.10,        0,\
					1,		2290.53,        0,\
					1,		2400.88,        0,\
					1,		2435.85,        0,\
					1,		2507.80,        0,\
					1,		2546.30,        0,\
					1,		2608.55,        0,\
					1,		2652.35,        0,\
					1,		2691.70,        0,\
					1,		2708.00,        0
			
;clarinet
gidata8		ftgen	0,0,-24*3,-2,		0.753504,	100,	rnd(1),\
						0.011446,	200,	rnd(1),\
						0.501720,	300,	rnd(1),\
						0.055791,	400,	rnd(1),\
						0.241768,	500,	rnd(1),\
						0.037889,	600,	rnd(1),\
						0.027203,	700,	rnd(1),\
						0.062793,	800,	rnd(1),\
						0.102494,	900,	rnd(1),\
						0.030506,	1000,	rnd(1),\
						0.042453,	1100,	rnd(1),\
						0.050202,	1200,	rnd(1),\
						0.031077,	1300,	rnd(1),\
						0.027208,	1400,	rnd(1),\
						0.020897,	1500,	rnd(1),\
						0.022205,	1600,	rnd(1),\
						0.012154,	1700,	rnd(1),\
						0.008160,	1800,	rnd(1),\
						0.004886,	1900,	rnd(1),\
						0.005076,	2000,	rnd(1),\
						0.003805,	2100,	rnd(1),\
						0.001322,	2200,	rnd(1),\
						0.001149,	2300,	rnd(1),\
						0.001450,	2300,	rnd(1),\
						0.001450,	2400,	rnd(1)


giTabSize	=	(2^15) +1	; function table size of the GEN33 table

instr	1	; manual instrument
 gknh		chnget	"nh"			; read in widgets
 gkamp		chnget	"amp"
 gkfrq		chnget	"frq"
 gkManualOnOff	chnget	"ManualOnOff"
 gksource	chnget	"source"
 gksource	init	1
 
 kporttime	linseg	0,0.001,0.05
 gkfrq		portk	gkfrq, kporttime
 gkamp		portk	gkamp, kporttime
 
 ktrig		changed	gknh,gkManualOnOff,gksource	; if listed widgets are changed generate a trigger

 if ktrig==1 then				; if a trigger has been generated...
  reinit UPDATE_WAVEFORM			; ...begin a reinitialisation pass from the label UPDATE_WAVEFORM
 endif
 UPDATE_WAVEFORM:				; begin reinitialisation from here
  gisource	=	gidata1+i(gksource)-1	; derive number of source function table from combo box and number of first table in the list 
  iNumPartials	=	ftlen(gisource)/3
  		chnset	iNumPartials,"NumPartials"	; write number of partials for this algorithm to number box
  giwave	ftgen	1,0, giTabSize,-33,gisource,i(gknh),1,-1  ; create a GEN33 function table / waveform from the source function table data and make use of the user defined number of partials
 rireturn
 
 
 if ktrig==1 then				; if a widget for 'Num.Harms' or 'Manual On/Off' has been changed...
   chnset	"tablenumber(1)", "table1"	; ...update table display	
 endif
 
 if gkManualOnOff==1 then			; if 'Manual On/Off' button is on...
  aL		oscil3	gkamp,gkfrq/400,giwave	; create an audio oscillator using the GEN33 waveform
  aR		oscil3	gkamp,gkfrq/400,giwave,0.13	; create an audio oscillator using the GEN33 waveform
 		outs	aL,aR		
 endif
 
endin


instr	3	; midi / keyboard instrument
 iDecTim	chnget	"DecTim"
 iRelTim	chnget	"RelTim"
 
 iNumH	ampmidi	(ftlen(gisource)/3)+1			; midi velocity mapped to a value between zero (min velocity) and the number of partials in the data table (max velocity)
 
 	chnset	int(iNumH),"nh"
 ivel	ampmidi	1					; midi velocity mapped to a value in the range zero to 1 
 iwave	ftgentmp	0,0, giTabSize,-33,gisource,iNumH,1,-1	; create a local and temporary waveform using GEN33 (overlapping notes may need different tables)
 	tableicopy	giwave, iwave			; copy local table to global table at i-time
 
 ktrig	init	1					; only update table during the first k period of a note (to conserve resources)
 if  ktrig==1 then
  chnset	"tablenumber(1)", "table1"		; update table display	
 endif
 ktrig	=	0	

 ; CREATE SOME SOUND
 icps	cpsmidi						; midi note number
 aL	oscil3	gkamp,icps/400,iwave	; create an audio oscilator
 aR	oscil3	gkamp,icps/400,iwave,0.13; create an audio oscilator
 acf	expsegr	10000,iDecTim,   50,iRelTim,50		; filter cutoff envelope (percussive decay)
 aenv	expsegr	1,    iDecTim,0.001,iRelTim,0.001	; amplitude envelope
 aL	butlp	aL,acf					; filter audio
 aR	butlp	aR,acf					; filter audio
 aL	=	aL * (aenv-0.001) * ivel		; scale amplitude of audio using envelope and midi velocity
 aR	=	aR * (aenv-0.001) * ivel		; scale amplitude of audio using envelope and midi velocity
 	outs	aL, aR
 
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
;f 0 3600
</CsScore>

</CsoundSynthesizer>
; GEN41.csd
; Written by Iain McCurdy, 2014.

; Demonstration of GEN41
; GEN41 can be used to genrate histogram-like function tables in which the number of times each value is repeated is defined by its associated probability value.
; The actual probabilities as fractions of 1 are the value divided by the sum of all probability values. (a total of '1' indicates all possibilities are represented.)

; In this example the histogram is used as a probability distribution from which notes are randomly chosen. Values define (midi) note numbers.

<Cabbage>
form caption("GEN41"), size(420, 395), pluginid("gn41"), colour(120,70,170,150) style("legacy")

gentable bounds(  5,  5, 410, 115), identchannel("table1"), tablenumber(1), tablecolour("yellow"), outlinethickness(2), amprange(36,84,1), zoom(-1), fill(0)

groupbox bounds(0, 125,420,170), text("Histogram"), plant("histogram"), fontcolour("white"){
rslider bounds(  0, 25, 70, 70), channel("prob1"), text("Prob. 1"), valuetextbox(1), textbox(1), range(0, 100, 70,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds( 50, 25, 70, 70), channel("prob2"), text("Prob. 2"), valuetextbox(1), textbox(1), range(0, 100,  5,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(100, 25, 70, 70), channel("prob3"), text("Prob. 3"), valuetextbox(1), textbox(1), range(0, 100,  5,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(150, 25, 70, 70), channel("prob4"), text("Prob. 4"), valuetextbox(1), textbox(1), range(0, 100, 15,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(200, 25, 70, 70), channel("prob5"), text("Prob. 5"), valuetextbox(1), textbox(1), range(0, 100, 15,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(250, 25, 70, 70), channel("prob6"), text("Prob. 6"), valuetextbox(1), textbox(1), range(0, 100,  5,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(300, 25, 70, 70), channel("prob7"), text("Prob. 7"), valuetextbox(1), textbox(1), range(0, 100,  5,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(350, 25, 70, 70), channel("prob8"), text("Prob. 8"), valuetextbox(1), textbox(1), range(0, 100, 70,1,1), colour(160,110,210,200), trackercolour("white")

rslider bounds(  0, 95, 70, 70), channel("val1"), text("Value 1"), valuetextbox(1), textbox(1), range(36, 84, 60,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds( 50, 95, 70, 70), channel("val2"), text("Value 2"), valuetextbox(1), textbox(1), range(36, 84, 62,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(100, 95, 70, 70), channel("val3"), text("Value 3"), valuetextbox(1), textbox(1), range(36, 84, 64,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(150, 95, 70, 70), channel("val4"), text("Value 4"), valuetextbox(1), textbox(1), range(36, 84, 65,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(200, 95, 70, 70), channel("val5"), text("Value 5"), valuetextbox(1), textbox(1), range(36, 84, 67,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(250, 95, 70, 70), channel("val6"), text("Value 6"), valuetextbox(1), textbox(1), range(36, 84, 69,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(300, 95, 70, 70), channel("val7"), text("Value 7"), valuetextbox(1), textbox(1), range(36, 84, 71,1,1), colour(160,110,210,200), trackercolour("white")
rslider bounds(350, 95, 70, 70), channel("val8"), text("Value 8"), valuetextbox(1), textbox(1), range(36, 84, 72,1,1), colour(160,110,210,200), trackercolour("white")
}

groupbox bounds(0, 295,420,100), text("Synthesiser"), plant("synth"), fontcolour("white"){
checkbox bounds( 15, 50,115, 17), channel("SynthOnOff"), text("On/Off"),  value(0), colour("yellow"), shape("square")
rslider  bounds( 75, 25, 70, 70), channel("lev"),  text("Level"), valuetextbox(1), textbox(1), range(0, 1.00, 0.7), colour(160,110,210,200), trackercolour("white")
rslider  bounds(125, 25, 70, 70), channel("rate"), text("Rate"), valuetextbox(1),  textbox(1), range(0.2, 5.00, 2), colour(160,110,210,200), trackercolour("white")
rslider  bounds(175, 25, 70, 70), channel("dur"),  text("Dur."), valuetextbox(1),  textbox(1), range(0.1, 3.00, 2), colour(160,110,210,200), trackercolour("white")
}

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE

; default waveform		
gihist	ftgen	1,0, 512, -41, 0, 100, 84, 256, 72, 128

instr	1
	iftlen	=	ftlen(1)		; length of function  table
	kftlen	init	iftlen
	
	; read in widgets
	kval1	chnget	"val1"
	kval2	chnget	"val2"
	kval3	chnget	"val3"
	kval4	chnget	"val4"
	kval5	chnget	"val5"
	kval6	chnget	"val6"
	kval7	chnget	"val7"
	kval8	chnget	"val8"

	kprob1	chnget	"prob1"
	kprob2	chnget	"prob2"
	kprob3	chnget	"prob3"
	kprob4	chnget	"prob4"
	kprob5	chnget	"prob5"
	kprob6	chnget	"prob6"
	kprob7	chnget	"prob7"
	kprob8	chnget	"prob8"

	kprob1	init	64
	kprob2	init	64
	kprob3	init	64
	kprob4	init	64
	kprob5	init	64
	kprob6	init	64
	kprob7	init	64
	kprob8	init	64

	gklev	chnget	"lev"
	gkSynthOnOff	chnget	"SynthOnOff"
	gkrate	chnget	"rate"
	gkdur	chnget	"dur"

	ktrig	changed		kval1,kval2,kval3,kval4,kval5,kval6,kval7,kval8, kprob1,kprob2,kprob3,kprob4,kprob5,kprob6,kprob7,kprob8
	if ktrig==1 then	; peg rate of update. Tables updated at this rate. If too slow, glitching will be heard in the output, particularly if random movement speed is high. If too high CPU performance will suffer.
	 reinit	UPDATE
	endif
	UPDATE:
	gihist	ftgen	1,0, iftlen, -41, i(kval1), i(kprob1), i(kval2), i(kprob2),   i(kval3),i(kprob3),   i(kval4),i(kprob4),   i(kval5),i(kprob5),   i(kval6),i(kprob6),   i(kval7),i(kprob7),   i(kval8),i(kprob8)
	rireturn

	if ktrig==1 then			; 
	 chnset	"tablenumber(1)", "table1"	; update table display	
	endif

	; TRIGGER SOME NOTES
	kNoteTrig	init	1
	krhy	trandom	kNoteTrig,0,3
	kNoteTrig	metro	gkrate*(2^int(krhy))
	schedkwhen	kNoteTrig*gkSynthOnOff,0,0,2,0,gkdur
endin

; SCALE FOR REFLECTION DEPENDENT UPON MIDI NOTE NUMBER
giScal	ftgen	0,0,128, -27,  0, 0.9, 24, 0.9, 36, 0.85, 48, 0.75, 60, 0.65, 72, 0.35, 84, 0.001, 96, 0.001, 127;, 0.001


gisine	ftgen	0,0,4096,10,1

instr	2
	iNote 	table     	rnd(1),gihist,1                 	; read a random value from the function table
	aEnv  	linsegr		0, 0.005, 1, p3-0.105, 1, 0.1, 0 	; amplitude envelope
	iPlk  	random		0.1, 0.3                         	; point at which to pluck the string
	iDtn  	random    	-0.05, 0.05                      	; random detune
	irefl	table		iNote, giScal
	aSig  	wgpluck2  	0.58, 0.5*gklev, cpsmidinn(iNote+iDtn), iPlk, irefl   
	kcf		expon		cpsoct(rnd(6)+6),p3,50
	aSig	clfilt		aSig, kcf, 0, 2						; butterworth lowpass filter	
	aL,aR 	pan2		aSig * aEnv, rnd(0.5)+0.5        	; random panning   
	      	outs		aL, aR
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
; GEN42.csd
; Demonstration of GEN42
; Written by Iain McCurdy, 2014.

<Cabbage>
form caption("GEN42"), size(420,495), pluginid("gn42"), colour(210,110, 80,200) style("legacy")

gentable bounds(  5,  5, 410, 145), identchannel("table1"), tablenumber(1), outlinethickness(2), tablecolour("yellow"), amprange(24,96,1), zoom(-1), fill(0)

groupbox bounds(0, 155,420,240), text("Histogram"), plant("histogram"), fontcolour("white"){
rslider bounds(  0, 25, 70, 70), channel("prob1"), text("Prob. 1"), valuetextbox(1), textbox(1), range(0, 100, 24,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds( 50, 25, 70, 70), channel("prob2"), text("Prob. 2"), valuetextbox(1), textbox(1), range(0, 100, 64,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(100, 25, 70, 70), channel("prob3"), text("Prob. 3"), valuetextbox(1), textbox(1), range(0, 100, 64,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(150, 25, 70, 70), channel("prob4"), text("Prob. 4"), valuetextbox(1), textbox(1), range(0, 100, 34,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(200, 25, 70, 70), channel("prob5"), text("Prob. 5"), valuetextbox(1), textbox(1), range(0, 100, 64,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(250, 25, 70, 70), channel("prob6"), text("Prob. 6"), valuetextbox(1), textbox(1), range(0, 100, 84,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(300, 25, 70, 70), channel("prob7"), text("Prob. 7"), valuetextbox(1), textbox(1), range(0, 100, 64,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(350, 25, 70, 70), channel("prob8"), text("Prob. 8"), valuetextbox(1), textbox(1), range(0, 100, 64,1,1), colour(210,110, 80,200), trackercolour("white")

rslider bounds(  0, 95, 70, 70), channel("min1"), text("Min 1"), valuetextbox(1), textbox(1), range(24, 96, 50,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds( 50, 95, 70, 70), channel("min2"), text("Min 2"), valuetextbox(1), textbox(1), range(24, 96, 62,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(100, 95, 70, 70), channel("min3"), text("Min 3"), valuetextbox(1), textbox(1), range(24, 96, 48,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(150, 95, 70, 70), channel("min4"), text("Min 4"), valuetextbox(1), textbox(1), range(24, 96, 44,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(200, 95, 70, 70), channel("min5"), text("Min 5"), valuetextbox(1), textbox(1), range(24, 96, 56,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(250, 95, 70, 70), channel("min6"), text("Min 6"), valuetextbox(1), textbox(1), range(24, 96, 54,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(300, 95, 70, 70), channel("min7"), text("Min 7"), valuetextbox(1), textbox(1), range(24, 96, 52,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(350, 95, 70, 70), channel("min8"), text("Min 8"), valuetextbox(1), textbox(1), range(24, 96, 76,1,1), colour(210,110, 80,200), trackercolour("white")

rslider bounds(  0,165, 70, 70), channel("max1"), text("Max 1"), valuetextbox(1), textbox(1), range(24, 96, 51,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds( 50,165, 70, 70), channel("max2"), text("Max 2"), valuetextbox(1), textbox(1), range(24, 96, 61,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(100,165, 70, 70), channel("max3"), text("Max 3"), valuetextbox(1), textbox(1), range(24, 96, 49,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(150,165, 70, 70), channel("max4"), text("Max 4"), valuetextbox(1), textbox(1), range(24, 96, 44,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(200,165, 70, 70), channel("max5"), text("Max 5"), valuetextbox(1), textbox(1), range(24, 96, 57,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(250,165, 70, 70), channel("max6"), text("Max 6"), valuetextbox(1), textbox(1), range(24, 96, 53,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(300,165, 70, 70), channel("max7"), text("Max 7"), valuetextbox(1), textbox(1), range(24, 96, 53,1,1), colour(210,110, 80,200), trackercolour("white")
rslider bounds(350,165, 70, 70), channel("max8"), text("Max 8"), valuetextbox(1), textbox(1), range(24, 96, 75,1,1), colour(210,110, 80,200), trackercolour("white")
}

groupbox bounds(0, 395,420,100), text("Synthesiser"), plant("synth"), fontcolour("white"){
checkbox bounds( 15, 50,115, 17), channel("SynthOnOff"), text("On/Off"),  value(0), colour:1("yellow"), colour:0("black"), shape("square")
rslider  bounds( 75, 25, 70, 70), channel("lev"),  text("Level"), valuetextbox(1), textbox(1), textbox(1), range(0, 1.00, 0.7), colour(210,110, 80,200), trackercolour("white")
rslider  bounds(125, 25, 70, 70), channel("rate"), text("Rate"), valuetextbox(1), textbox(1),  textbox(1), range(0.2, 5.00, 2), colour(210,110, 80,200), trackercolour("white")
rslider  bounds(175, 25, 70, 70), channel("dur"),  text("Dur."), valuetextbox(1), textbox(1),  textbox(1), range(0.1, 3.00, 2), colour(210,110, 80,200), trackercolour("white")
}

</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100	; SAMPLE RATE
ksmps 		= 	32	; NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	; NUMBER OF CHANNELS (1=MONO)
0dbfs		=	1	; MAXIMUM AMPLITUDE

; default waveform		
gihist	ftgen	1,0, 512, -42, 0,0, 100 ;

instr	1
	iftlen	=	ftlen(1)		; length of function  table
	kftlen	init	iftlen
	
	; read in widgets
	kmin1	chnget	"min1"
	kmin2	chnget	"min2"
	kmin3	chnget	"min3"
	kmin4	chnget	"min4"
	kmin5	chnget	"min5"
	kmin6	chnget	"min6"
	kmin7	chnget	"min7"
	kmin8	chnget	"min8"

	kmax1	chnget	"max1"
	kmax2	chnget	"max2"
	kmax3	chnget	"max3"
	kmax4	chnget	"max4"
	kmax5	chnget	"max5"
	kmax6	chnget	"max6"
	kmax7	chnget	"max7"
	kmax8	chnget	"max8"

	kprob1	chnget	"prob1"
	kprob2	chnget	"prob2"
	kprob3	chnget	"prob3"
	kprob4	chnget	"prob4"
	kprob5	chnget	"prob5"
	kprob6	chnget	"prob6"
	kprob7	chnget	"prob7"
	kprob8	chnget	"prob8"

	gklev	chnget	"lev"
	gkSynthOnOff	chnget	"SynthOnOff"
	gkrate	chnget	"rate"
	gkdur	chnget	"dur"

	ktrig	changed		kmin1,kmin2,kmin3,kmin4,kmin5,kmin6,kmin7,kmin8, kmax1,kmax2,kmax3,kmax4,kmax5,kmax6,kmax7,kmax8, kprob1,kprob2,kprob3,kprob4,kprob5,kprob6,kprob7,kprob8
	if ktrig==1 then	; peg rate of update. Tables updated at this rate. If too slow, glitching will be heard in the output, particularly if random movement speed is high. If too high CPU performance will suffer.
	 reinit	UPDATE
	endif
	UPDATE:
	gihist	ftgen	1,0, iftlen, -42, i(kmin1), i(kmax1), i(kprob1),\
	                                  i(kmin2), i(kmax2), i(kprob2),\
	                                  i(kmin3), i(kmax3), i(kprob3),\
	                                  i(kmin4), i(kmax4), i(kprob4),\
	                                  i(kmin5), i(kmax5), i(kprob5),\
	                                  i(kmin6), i(kmax6), i(kprob6),\
	                                  i(kmin7), i(kmax7), i(kprob7),\
	                                  i(kmin8), i(kmax8), i(kprob8)


	rireturn

	if ktrig==1 then			; 
	 chnset	"tablenumber(1)", "table1"	; update table display	
	endif

	; TRIGGER SOME NOTES
	kNoteTrig	init	1
	krhy	trandom	kNoteTrig,0,3
	kNoteTrig	metro	gkrate*(2^int(krhy))
	krate		randomi	0.5,4,1,1
	schedkwhen	kNoteTrig*gkSynthOnOff,0,0,2,0,gkdur
endin

; SCALE FOR REFLECTION DEPENDENT UPON MIDI NOTE NUMBER
;giScal	ftgen	0,0,128, -27,  0, 0.9, 24, 0.9, 36, 0.85, 48, 0.75, 60, 0.65, 72, 0.35, 84, 0.001, 96, 0.001, 127;, 0.001
giScal	ftgen	0,0,128, -27,  0, 0.983, 24, 0.983, 36, 0.971, 48, 0.939, 60, 0.855, 72, 0.747, 84, 0.364, 96, 0.001, 127

gasendL,gasendR	init	0

instr	2
	iNote table     rnd(1),gihist,1                 ; read a random value from the function table
	aEnv  linsegr	0, 0.005, 1, p3-0.105, 1, 0.1, 0 ; amplitude envelope
	iPlk  random	0.1, 0.3                         ; point at which to pluck the string
	iDtn  random    -0.05, 0.05                      ; random detune
	irefl	table	iNote, giScal
	aSig  wgpluck2  0.58, 0.5*gklev, cpsmidinn(iNote+iDtn), iPlk, irefl    	
	kcf	expon	cpsoct(rnd(6)+6),p3,50
	aSig	clfilt	aSig, kcf, 0, 2					; butterworth lowpass filter	 
	aL,aR pan2      aSig * aEnv, rnd(0.5)+0.5        ; random panning   
	      outs      aL, aR
	gasendL	=	gasendL + aL*0.2
	gasendR	=	gasendR + aR*0.2
	                                                                             
endin

instr	99
	aL,aR	reverbsc	gasendL,gasendR,0.82,7000
		outs		aL,aR
		clear		gasendL,gasendR
endin

</CsInstruments>

<CsScore>
i 1 0 [3600*24*7]
i 99 0 [3600*24*7]
f 0 3600
</CsScore>

</CsoundSynthesizer>

<Cabbage>
form caption("Drum Pads") size(850, 430), pluginid("DPds") style("legacy")
image bounds( 10, 10, 200, 200),     colour(150,150,170), shape("rounded"), outlinecolour("white"), line(0)
image bounds(220, 10, 200, 200),     colour(150,150,170), shape("rounded"), outlinecolour("white"), line(0)
image bounds(430, 10, 200, 200),     colour(150,150,170), shape("rounded"), outlinecolour("white"), line(0)
image bounds(640, 10, 200, 200),     colour(150,150,170), shape("rounded"), outlinecolour("white"), line(0)
image bounds( 10,220, 200, 200),     colour(150,150,170), shape("rounded"), outlinecolour("white"), line(0)
image bounds(220,220, 200, 200),     colour(150,150,170), shape("rounded"), outlinecolour("white"), line(0)
image bounds(430,220, 200, 200),     colour(150,150,170), shape("rounded"), outlinecolour("white"), line(0)
image bounds(640,220, 200, 200),     colour(150,150,170), shape("rounded"), outlinecolour("white"), line(0)

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -dm0
</CsOptions>

<CsInstruments>

sr	= 	44100
ksmps	= 	16
nchnls	= 	2
0dbfs	=	1

gisine		ftgen	0,0,1024,10,1		; A SINE WAVE
gicos		ftgen	0,0,65536,9,1,1,90	; A COSINE WAVE

instr	1

 gkMOUSE_X	chnget	"MOUSE_X"
 gkMOUSE_Y	chnget	"MOUSE_Y"
 gkMOUSE_DOWN_LEFT	chnget	"MOUSE_DOWN_LEFT"

#define PAD(N'X'Y'INSTR)
 #
 ix$N	=	$X
 iy$N	=	$Y
 if (gkMOUSE_X > ix$N)  && (gkMOUSE_X < (ix$N+200))  && (gkMOUSE_Y > iy$N)  && (gkMOUSE_Y < (iy$N+200)) then
  kinside$N	=	1
 else
  kinside$N	=	0
 endif

 if kinside$N = 1 then
  gkx	=	(gkMOUSE_X - ix$N) / 200	; normalised coordinates
  gky	=	(gkMOUSE_Y - iy$N) / 200
  gky	expcurve	1-gky,8
  ktrig	trigger	gkMOUSE_DOWN_LEFT,0.5,0
  schedkwhen	ktrig,0,0,$INSTR,0,0.01,gkx,gky
 endif
 #

$PAD(1'10'10'101)
$PAD(2'220'10'102)
$PAD(3'430'10'103)
$PAD(4'640'10'104)
$PAD(5'10'220'105)
$PAD(6'220'220'106)
$PAD(7'430'220'107)
$PAD(8'640'220'108)

endin


instr	101	;BASS DRUM
	p3	=	2								;NOTE DURATION. SCALED USING GUI 'Decay' KNOB

	;SUSTAIN AND BODY OF THE SOUND
	kmul	transeg	0.2,p3*0.5,-15,0.01, p3*0.5,0,0					;PARTIAL STRENGTHS MULTIPLIER USED BY GBUZZ. DECAYS FROM A SOUND WITH OVERTONES TO A SINE TONE.
	kbend	transeg	0.5,1.2,-4, 0,1,0,0						;SLIGHT PITCH BEND AT THE START OF THE NOTE 
	asig	gbuzz	0.5,50*semitone(kbend),20,1,kmul,gicos				;GBUZZ TONE
	aenv	transeg	1,p3-0.004,-6,0							;AMPLITUDE ENVELOPE FOR SUSTAIN OF THE SOUND
	aatt	linseg	0,0.004,1							;SOFT ATTACK
	asig	=	asig*aenv*aatt

	;HARD, SHORT ATTACK OF THE SOUND
	aenv	linseg	1,0.07,0							;AMPLITUDE ENVELOPE (FAST DECAY)						
	acps	expsega	400,0.07,0.001,1,0.001						;FREQUENCY OF THE ATTACK SOUND. QUICKLY GLISSES FROM 400 Hz TO SUB-AUDIO
	aimp	oscili	aenv,acps,gisine						;CREATE ATTACK SOUND
	
	amix	=	((asig*0.5)+(aimp*0.35))*p5			;MIX SUSTAIN AND ATTACK SOUND ELEMENTS AND SCALE USING GUI 'Level' KNOB
	
	aL,aR	pan2	amix,p4							;PAN THE MONOPHONIC SOUND
		outs	aL,aR								;SEND AUDIO TO OUTPUTS
endin

instr	102	;SNARE DRUM
	;SOUND CONSISTS OF TWO SINE TONES, AN OCTAVE APART AND A NOISE SIGNAL
	ifrq  	=	342		;FREQUENCY OF THE TONES
	iNseDur	=	0.3		;DURATION OF THE NOISE COMPONENT
	iPchDur	=	0.1		;DURATION OF THE SINE TONES COMPONENT
	p3	=	iNseDur 	;p3 DURATION TAKEN FROM NOISE COMPONENT DURATION (ALWATS THE LONGEST COMPONENT)
	
	;SINE TONES COMPONENT
	aenv1	expseg	1,iPchDur,0.0001,p3-iPchDur,0.0001		;AMPLITUDE ENVELOPE
	apitch1	oscili	1,ifrq,gisine			;SINE TONE 1
	apitch2	oscili	0.25,ifrq*0.5,gisine		;SINE TONE 2 (AN OCTAVE LOWER)
	apitch	=	(apitch1+apitch2)*0.75				;MIX THE TWO SINE TONES

	;NOISE COMPONENT
	aenv2	expon	1,p3,0.0005					;AMPLITUDE ENVELOPE
	anoise	noise	0.75,0						;CREATE SOME NOISE
	anoise	butbp	anoise,10000,10000		;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,1000					;HIGHPASS FILTER THE NOISE SIGNAL
	kcf	expseg	5000,0.1,3000,p3-0.2,3000			;CUTOFF FREQUENCY FOR A LOWPASS FILTER
	anoise	butlp	anoise,kcf					;LOWPASS FILTER THE NOISE SIGNAL
	amix	=	((apitch*aenv1)+(anoise*aenv2))*p5		;MIX AUDIO SIGNALS AND SCALE ACCORDING TO GUI 'Level' CONTROL
	aL,aR	pan2	amix,p4						;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR						;SEND AUDIO TO OUTPUTS
endin

instr	103	;OPEN HIGH HAT
	kFrq1	=	296 	;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285 	
	kFrq3	=	365 	
	kFrq4	=	348 	
	kFrq5	=	420 	
	kFrq6	=	835 	
	p3	=	0.5			;DURATION OF THE NOTE
	
	;SOUND CONSISTS OF 6 PULSE OSCILLATORS MIXED WITH A NOISE COMPONENT
	;PITCHED ELEMENT
	aenv	linseg	1,p3-0.05,0.1,0.05,0		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS
	ipw	=	0.25				;PULSE WIDTH
	a1	vco2	0.5,kFrq1,2,ipw			;PULSE OSCILLATORS...
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000,5000,1		;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,5000			;HIGHPASS FILTER THE SOUND...
	amix	buthp	amix,5000			;...AND AGAIN
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	linseg	1,p3-0.05,0.1,0.05,0		;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	20000,0.7,9000,p3-0.1,9000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*p5*0.55
	aL,aR	pan2	amix,p4				;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
	kactive	active	p1+1				;CHECK NUMBER OF ACTIVE INSTANCES OF CLOSED HIGH HAT INSTRUMENT
	if kactive>0 then			;IF HIGH-HAT CLOSED IS ACTIVE...
	 turnoff				;TURN OFF THIS INSTRUMENT
	endif
endin

instr	104	;CLOSED HIGH HAT
	kFrq1	=	296		 	;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285 	
	kFrq3	=	365 	
	kFrq4	=	348 	
	kFrq5	=	420 	
	kFrq6	=	835 	
	idur	=	0.088			;DURATION OF THE NOTE
	p3	=	idur

	iactive	active	p1-1			;SENSE ACTIVITY OF PREVIOUS INSTRUMENT (OPEN HIGH HAT) 
	if iactive>0 then			;IF 'OPEN HIGH HAT' IS ACTIVE...
	 turnoff2	p1-1,0,0		;TURN IT OFF (CLOSED HIGH HAT TAKES PRESIDENCE)
	endif

	;PITCHED ELEMENT
	aenv	expsega	1,idur,0.001,1,0.001		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS
	ipw	=	0.25				;PULSE WIDTH
	a1	vco2	0.5,kFrq1,2,ipw			;PULSE OSCILLATORS...			
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000,5000,1		;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,5000			;HIGHPASS FILTER THE SOUND...
	amix	buthp	amix,5000			;...AND AGAIN
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	expsega	1,idur,0.001,1,0.001		;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	20000,0.7,9000,idur-0.1,9000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*p5*0.55
	aL,aR	pan2	amix,p4			;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
endin

instr	105	;HIGH TOM
	ifrq     	=	200				;FREQUENCY
	p3	  	=	0.5				;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise,400,800,1			;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100				;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,1000				;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*p5
	aL,aR	pan2	amix,p4					;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	106	;MID TOM
	ifrq     	=	133		 		;FREQUENCY
	p3	  	=	0.6				;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise, 400,800,1			;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100				;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,600				;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*p5
	aL,aR	pan2	amix,p4					;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	107	;LOW TOM
	ifrq     	=	90				;FREQUENCY
	p3 	 	=	0.7		 		;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise,40,800,1				;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100				;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,600				;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*p5
	aL,aR	pan2	amix,p4				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	108	;CYMBAL
	kFrq1	=	296 			;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285
	kFrq3	=	365
	kFrq4	=	348     
	kFrq5	=	420
	kFrq6	=	835
	p3	=	2			;DURATION OF THE NOTE

	;SOUND CONSISTS OF 6 PULSE OSCILLATORS MIXED WITH A NOISE COMPONENT
	;PITCHED ELEMENT
	aenv	expon	1,p3,0.0001		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS 
	ipw	=	0.25			;PULSE WIDTH      
	a1	vco2	0.5,kFrq1,2,ipw		;PULSE OSCILLATORS...  
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw                                                                   
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000,5000,1		;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,10000			;HIGHPASS FILTER THE SOUND
	amix	butlp	amix,12000			;LOWPASS FILTER THE SOUND...
	amix	butlp	amix,12000			;AND AGAIN...
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	expsega	1,0.3,0.07,p3-0.1,0.00001	;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	14000,0.7,7000,p3-0.1,5000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE            

	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*p5*0.85
	aL,aR	pan2	amix,p4			;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
endin

</CsInstruments>

<CsScore>
i 1 0 3600	;INSTRUMENT 1 PLAYS A NOTE FOR 1 HOUR (AND KEEPS REAL-TIME PERFORMANCE GOING)
</CsScore>

</CsoundSynthesizer>;  MiniPops.csd
;  Written by Iain McCurdy, 2014.
;
;  Emulation of the Korg/Univibe Mini Pops 7

; The Mini Pops 7 was an early non-programmable drum machine from the Japanese company Korg. It is perhaps most through 
; its use by Jean Michel Jarre in his early work. I have tried to retain as close a tie as possible with the original 
; design whilst making some additions and modifications for convenience.
; Preset rhythms are selected using the large black buttons. The lower row of rhythms (in red) are selected by first 
; setting the 'Lower' checkbox to 'on'.
; Additional effects are 'O.D.' - clipping distortion, 'Dec' - sample rate decimation and 'Mash' - break-beat style cut
; ups.
; The 'Rhythm' selector buttons were radio buttons (depressing one would release any others) but a popular trick was to 
; force more than one to stay depressed and to create a combination of two or more rhythms. The rhythms would combine in
; a rather enigmatic way. Unfortunately I quite figured out how this worked yet so in my implementation they simply mix.



<Cabbage>
form size(840,250), caption("Mini Pops"), pluginid("MPop"), colour(255,255,205), guirefresh(64) style("legacy")

checkbox bounds( 13,  6,   45,   44), colour("tomato"), channel("Act1"),  value(0), shape("ellipse")
checkbox bounds( 68,  6,   45,   44), colour("tomato"), channel("Act2"),  value(0), shape("ellipse")
checkbox bounds(123,  6,   45,   44), colour("tomato"), channel("Act3"),  value(0), shape("ellipse")
checkbox bounds(178,  6,   45,   44), colour("tomato"), channel("Act4"),  value(0), shape("ellipse")
checkbox bounds(233,  6,   45,   44), colour("tomato"), channel("Act5"),  value(0), shape("ellipse")
checkbox bounds(288,  6,   45,   44), colour("tomato"), channel("Act6"),  value(0), shape("ellipse")
checkbox bounds(343,  6,   45,   44), colour("tomato"), channel("Act7"),  value(0), shape("ellipse")
checkbox bounds(398,  6,   45,   44), colour("tomato"), channel("Act8"),  value(0), shape("ellipse")
checkbox bounds(453,  6,   45,   44), colour("tomato"), channel("Act9"),  value(0), shape("ellipse")
checkbox bounds(508,  6,   45,   44), colour("tomato"), channel("Act10"),  value(0), shape("ellipse")
checkbox bounds(563,  6,   45,   44), colour("tomato"), channel("Act11"),  value(0), shape("ellipse")
checkbox bounds(618,  6,   45,   44), colour("tomato"), channel("Act12"),  value(0), shape("ellipse")
checkbox bounds(673,  6,   45,   44), colour("tomato"), channel("Act13"),  value(0), shape("ellipse")
checkbox bounds(728,  6,   45,   44), colour("tomato"), channel("Act14"),  value(0), shape("ellipse")
checkbox bounds(783,  6,   45,   44), colour("tomato"), channel("Act15"),  value(0), shape("ellipse")

rslider  bounds(  5,  5, 60, 60), text("Bass Drum"),  textcolour("black"), colour(255,220,155), alpha(0.75), channel("bassdrum"),    range(0, 1, 0.6), trackercolour(white)
rslider  bounds( 60,  5, 60, 60), text("Snare 1"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("snare1"),      range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(115,  5, 60, 60), text("Snare 2"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("snare2"),      range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(170,  5, 60, 60), text("Rimshot"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("rimshot"),     range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(225,  5, 60, 60), text("Cymbal 1"),   textcolour("black"), colour(255,220,155), alpha(0.75), channel("cymbal1"),     range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(280,  5, 60, 60), text("Cymbal 2"),   textcolour("black"), colour(255,220,155), alpha(0.75), channel("cymbal2"),     range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(335,  5, 60, 60), text("Bongo 1"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("bongo1"),      range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(390,  5, 60, 60), text("Bongo 2"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("bongo2"),      range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(445,  5, 60, 60), text("Bongo 3"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("bongo3"),      range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(500,  5, 60, 60), text("Claves"),     textcolour("black"), colour(255,220,155), alpha(0.75), channel("claves"),      range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(555,  5, 60, 60), text("Cowbell"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("cowbell"),     range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(610,  5, 60, 60), text("Guiro"),      textcolour("black"), colour(255,220,155), alpha(0.75), channel("guiro"),       range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(665,  5, 60, 60), text("Maracas"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("maracas"),     range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(720,  5, 60, 60), text("Quijada"),    textcolour("black"), colour(255,220,155), alpha(0.75), channel("quijada"),     range(0, 1, 0.6), trackercolour(255,255,205)
rslider  bounds(775,  5, 60, 60), text("Tamb."),      textcolour("black"), colour(255,220,155), alpha(0.75), channel("tambourine"),  range(0, 1, 0.6), trackercolour(255,255,205)

checkbox bounds( 13, 66, 60, 10), text("mute"), channel("mute1"), fontcolour("black"), colour(red),value(0)
checkbox bounds( 13, 78, 60, 10), text("solo"), channel("solo1"), fontcolour("black"), colour(lime),value(0)
checkbox bounds( 68, 66, 60, 10), text("mute"), channel("mute2"), fontcolour("black"), colour(red),value(0)
checkbox bounds( 68, 78, 60, 10), text("solo"), channel("solo2"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(123, 66, 60, 10), text("mute"), channel("mute3"), fontcolour("black"), colour(red),value(0)
checkbox bounds(123, 78, 60, 10), text("solo"), channel("solo3"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(178, 66, 60, 10), text("mute"), channel("mute4"), fontcolour("black"), colour(red),value(0)
checkbox bounds(178, 78, 60, 10), text("solo"), channel("solo4"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(233, 66, 60, 10), text("mute"), channel("mute5"), fontcolour("black"), colour(red),value(0)
checkbox bounds(233, 78, 60, 10), text("solo"), channel("solo5"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(288, 66, 60, 10), text("mute"), channel("mute6"), fontcolour("black"), colour(red),value(0)
checkbox bounds(288, 78, 60, 10), text("solo"), channel("solo6"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(343, 66, 60, 10), text("mute"), channel("mute7"), fontcolour("black"), colour(red),value(0)
checkbox bounds(343, 78, 60, 10), text("solo"), channel("solo7"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(398, 66, 60, 10), text("mute"), channel("mute8"), fontcolour("black"), colour(red),value(0)
checkbox bounds(398, 78, 60, 10), text("solo"), channel("solo8"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(453, 66, 60, 10), text("mute"), channel("mute9"), fontcolour("black"), colour(red),value(0)
checkbox bounds(453, 78, 60, 10), text("solo"), channel("solo9"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(508, 66, 60, 10), text("mute"), channel("mute10"), fontcolour("black"), colour(red),value(0)
checkbox bounds(508, 78, 60, 10), text("solo"), channel("solo10"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(563, 66, 60, 10), text("mute"), channel("mute11"), fontcolour("black"), colour(red),value(0)
checkbox bounds(563, 78, 60, 10), text("solo"), channel("solo11"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(618, 66, 60, 10), text("mute"), channel("mute12"), fontcolour("black"), colour(red),value(0)
checkbox bounds(618, 78, 60, 10), text("solo"), channel("solo12"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(673, 66, 60, 10), text("mute"), channel("mute13"), fontcolour("black"), colour(red),value(0)
checkbox bounds(673, 78, 60, 10), text("solo"), channel("solo13"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(728, 66, 60, 10), text("mute"), channel("mute14"), fontcolour("black"), colour(red),value(0)
checkbox bounds(728, 78, 60, 10), text("solo"), channel("solo14"), fontcolour("black"), colour(lime),value(0)
checkbox bounds(783, 66, 60, 10), text("mute"), channel("mute15"), fontcolour("black"), colour(red),value(0)
checkbox bounds(783, 78, 60, 10), text("solo"), channel("solo15"), fontcolour("black"), colour(lime),value(0)

;control
image    bounds(620,100, 220,150), colour(0,0,0,0), line(0), plant("control"){
;combobox bounds( 15, 20, 60, 18), channel("UpperLower"), value(1), text("Upper", "Lower")

checkbox bounds( 15, 16, 12, 13), channel("r1") fontcolour("white") colour(yellow) value(1)
checkbox bounds( 15, 28, 12, 13), channel("r2") fontcolour("white") colour(yellow) 
label    bounds( 28, 17, 60, 12), text("Upper"), fontcolour("black"), align("left")
label    bounds( 28, 29, 60, 12), text("Lower"), fontcolour(205,0,0), align("left")


rslider  bounds( 85,  5, 60, 60), text("O.D."), textcolour("black"), colour(200,160, 80), trackercolour(120,100, 52), outlinecolour(60,50,26), channel("dist"),      range(0, 1, 0)
rslider  bounds(145,  5, 60, 60), text("Dec."), textcolour("black"), colour(200,160, 80), trackercolour(120,100, 52), outlinecolour(60,50,26), channel("fold"),      range(0, 1, 0, 0.5, 0.0001)

checkbox bounds(130,  2,  7,  7), channel("DistOn"), value(0), colour(red), shape("ellipse")
checkbox bounds(190,  2,  7,  7), channel("FoldOn"), value(0), colour(red), shape("ellipse")

checkbox bounds( 15, 45, 70, 12), channel("cutup"), text("Mash"), fontcolour("black"), colour("yellow"),value(0)

rslider  bounds(  0, 70, 70, 70), text("Volume"),     textcolour("black"), colour(200,160, 80), trackercolour(120,100, 52), outlinecolour(60,50,26), channel("volume"),      range(0, 1.00, .4)
rslider  bounds( 70, 70, 70, 70), text("Tempo"),      textcolour("black"), colour(200,160, 80), trackercolour(120,100, 52), outlinecolour(60,50,26), channel("tempo"),       range(40, 480, 115, 1, 1)
checkbox bounds(153, 77, 45, 45), channel("OnOff"), fontcolour("black"), colour("yellow"),value(1)
label    bounds(148,127, 60, 11), text("Start/Stop"),     FontColour("black"), align("left")
}

;rhythms
image bounds(  0,  100, 640, 65), colour(0,0,0,0), line(0), plant("rhythms"){
checkbox bounds( 10,  0, 60, 20), channel("but1"), colour(250,250,105), value(0), text("")
checkbox bounds( 70,  0, 60, 20), channel("but2"), colour(250,250,105), value(0), text("")
checkbox bounds(130,  0, 60, 20), channel("but3"), colour(250,250,105), value(0), text("")
checkbox bounds(190,  0, 60, 20), channel("but4"), colour(250,250,105), value(0), text("")
checkbox bounds(250,  0, 60, 20), channel("but5"), colour(250,250,105), value(0), text("")
checkbox bounds(310,  0, 60, 20), channel("but6"), colour(250,250,105), value(0), text("")
checkbox bounds(370,  0, 60, 20), channel("but7"), colour(250,250,105), value(0), text("")
checkbox bounds(430,  0, 60, 20), channel("but8"), colour(250,250,105), value(0), text("")
checkbox bounds(490,  0, 60, 20), channel("but9"), colour(250,250,105), value(0), text("")
checkbox bounds(550,  0, 60, 20), channel("but10"), colour(250,250,105), value(0), text("")

label    bounds( 10, 20, 60, 10), text("WALTZ"),     fontcolour("black"), align("centre")
label    bounds( 70, 20, 60, 10), text("SAMBA"),     fontcolour("black"), align("centre")
label    bounds(130, 20, 60, 10), text("MAMBO"),     fontcolour("black"), align("centre")
label    bounds(190, 20, 60, 10), text("RUMBA"),     fontcolour("black"), align("centre")
label    bounds(250, 20, 60, 10), text("TANGO"),     fontcolour("black"), align("centre")
label    bounds(310, 20, 60, 10), text("BOSSANOVA"), fontcolour("black"), align("centre")
label    bounds(370, 20, 60, 10), text("ROCK 1"),    fontcolour("black"), align("centre")
label    bounds(430, 20, 60, 10), text("ROCK 2"),    fontcolour("black"), align("centre")
label    bounds(490, 20, 60, 10), text("MARCH 2/4"), fontcolour("black"), align("centre")
label    bounds(550, 20, 60, 10), text("SWING"),     fontcolour("black"), align("centre")

label    bounds( 10, 30, 60, 10), text("JAZZ WALTZ"),  fontcolour(205,  0,  0), align("centre")
label    bounds( 70, 30, 60, 10), text("MERINGUE"),    fontcolour(205,  0,  0), align("centre")
label    bounds(130, 30, 60, 10), text("CHA CHA"),     fontcolour(205,  0,  0), align("centre")
label    bounds(190, 30, 60, 10), text("BEGUINE"),     fontcolour(205,  0,  0), align("centre")
label    bounds(250, 30, 60, 10), text("HABANERA"),    fontcolour(205,  0,  0), align("centre")
label    bounds(310, 30, 60, 10), text("SLOW ROCK"),   fontcolour(205,  0,  0), align("centre")
label    bounds(370, 30, 60, 10), text("ROCK 3"),      fontcolour(205,  0,  0), align("centre")
label    bounds(430, 30, 60, 10), text("ROCK 4"),      fontcolour(205,  0,  0), align("centre")
label    bounds(490, 30, 60, 10), text("MARCH 6/8"),   fontcolour(205,  0,  0), align("centre")
label    bounds(550, 30, 65, 10), text("LATIN SWING"), fontcolour(205,  0,  0), align("centre")

checkbox bounds(618, 19, 10, 10), channel("Indic1"), value(0), colour( 70,255, 70), shape("ellipse"), active(0)
checkbox bounds(618, 30, 10, 10), channel("Indic2"), value(0), colour(255, 30, 30), shape("ellipse"), active(0)
}

keyboard bounds( 10,155, 600, 80)

label   bounds(695,239, 145, 10), text("Author: Iain McCurdy |2014|"), FontColour("DarkSlateGrey"), align("left")
</Cabbage>
              
<CsoundSynthesizer>
<CsOptions>
-n -dm0 -+rtmidi=NULL -M0
</CsOptions>
<CsInstruments>
sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

massign	0,2	;MIDI notes assigned to instr 2

;UDOs---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

opcode	CabbageRadio2,k,SS			; change opcode name and number is string variable inputs
S1,S2	xin					; add string inputs for the required number of inputs 
kon		=	1
koff		=	0
ksum		=	0
ktrigsum	=	0
#define READ_CHANGES(NAME)	#
k$NAME	chnget	$NAME
ksum	=	ksum + k$NAME			; sum of values
kon$NAME	trigger	k$NAME,0.5,0		; trigger that a checkbox has been turned on
ktrigsum	=	ktrigsum + kon$NAME#	; sum of all on triggers

#define WRITE_CHANGES(NAME'COUNT)	#
if kon$NAME!=1 then
 chnset	koff,$NAME
else
 kval	=	$COUNT
endif#

#define PREVENT_ALL_OFF(NAME)	#
koff$NAME	trigger	k$NAME,0.5,1		; trigger that a checkbox has been turned on
if koff$NAME==1&&ksum==0 then
 chnset	kon,$NAME
endif#

$READ_CHANGES(S1) 
$READ_CHANGES(S2)				; add macro expansions for the required number of radio buttons

if ktrigsum>0 then
 $WRITE_CHANGES(S1'1)
 $WRITE_CHANGES(S2'2)				; add macro expansions for the required number of radio buttons
endif

$PREVENT_ALL_OFF(S1)
$PREVENT_ALL_OFF(S2)				; add macro expansions for the required number of radio buttons

kval	=	(ksum=0?0:kval)
	xout	kval
endop
;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




gisine	ftgen	0,0,131072,10,1

gasend	init	0			; global audio send variable

giOn	=	1			; ivals for on and off values
giOff	=	0


;PRESET_RHYTHMS-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

;1: WALTZ (in 3)
;				instr	strt	dur	amp
giBD01	ftgen	0,0,-12,-2,	101,	1,	1,	1,\
				101,	4,	1,	1,\
				-1,	4,	-1,	-1
				
giSn201	ftgen	0,0,-16,-2,	0,	1,	0,	1,\
				103,	2,	1,	1,\
				103,	3,	1,	1,\
				-1,	4,	-1,	-1
				
giCy201	ftgen	0,0,-12,-2,	106,	1,	1,	1,\
				106,	4,	1,	1,\
				-1,	4,	-1,	-1
				
giGu01	ftgen	0,0,-36,-2,	112,	1,	1,	0.7,\
				112,	2,	1,	0.7,\
				112,	3,	0.125,	1,\
				112,	3.5,	0.125,	1,\
				112,	4,	1,	0.7,\
				-1,	4,	-1,	-1
				
giQu01	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	3,	1,	1,\
				-1,	4,	-1,	-1                                                     

giTa01	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				-1,	4,	-1,	-1

;2: SAMBA (4/4)
;				instr	strt	dur	amp
giBD02	ftgen	0,0,-16,-2,	101,	1,	1,	1,\
				101,	3,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1
				
giBo302	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				109,	4,	1,	1,\
				-1,	5,	-1,	-1         

giCo02	ftgen	0,0,-20,-2,	111,	1,	.1,	1,\
				111,	2.5,	.1,	1,\
				111,	4,	.1,	1,\
				111,	5,	.1,	0,\
				-1,	5,	-1,	-1

				
giGu02	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu02	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         
				
giTa02	ftgen	0,0,40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1


;3: MAMBO (4/4)
;				instr	strt	dur	amp
giBD03	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2.5,	0.5,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1
				
giBo303	ftgen	0,0,16,-2,	0,	1,	0,	1,\
				109,	4,	0.5,	1,\
				109,	4.5,	0.5,	1,\
				-1,	5,	-1,	-1         

giCo03	ftgen	0,0,-24,-2,	111,	1,	.1,	1,\
				111,	2,	.1,	1,\
				111,	3,	.1,	1,\
				111,	4,	.1,	1,\
				111,	5,	.1,	1,\
				-1,	5,	-1,	-1

				
giGu03	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu03	ftgen	0,0,12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         
				
giTa03	ftgen	0,0,40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1


;4: RUMBA (4/4)
;				instr	strt	dur	amp
giBD04	ftgen	0,0,-20,-2,	101,	1,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1
				
giCy104	ftgen	0,0,-28,-2,	105,	1,	0.5,	1,\
				105,	1.75,	0.5,	1,\
				105,	2,	0.5,	1,\
				105,	3,	0.5,	1,\
				105,	4,	0.5,	1,\
				105,	5,	0.5,	1,\
				-1,	5,	-1,	-1

giBo104	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				107,	2,	0.5,	1,\
				-1,	5,	-1,	-1         

giBo204	ftgen	0,0,-20,-2,	108,	1,	0,	1,\
				108,	2.5,	0.5,	1,\
				108,	3,	0.5,	1,\
				108,	5,	0.5,	1,\
				-1,	5,	-1,	-1         


giBo304	ftgen	0,0,-16,-2,	0,	1,	0,	1,\
				109,	4,	0.5,	1,\
				109,	4.5,	0.5,	1,\
				-1,	5,	-1,	-1         

giCl04	ftgen	0,0,-16,-2,	110,	1,	.1,	1,\
				110,	3,	.1,	1,\
				110,	5,	.1,	1,\
				-1,	5,	-1,	-1
				
giGu04	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu04	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         
				
giTa04	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1


;5: TANGO (4/4)
;				instr	strt	dur	amp
giBD05	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giCy205	ftgen	0,0,-12,-2,	0,	1,	1,	1,\
				106,	4.5,	1,	1,\
				-1,	5,	-1,	-1
				
				
giGu05	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu05	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         
				
giTa05	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;6: BOSSANOVA (4/4)
;				instr	strt	dur	amp
giBD06	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2.5,	1,	1,\
				101,	3,	1,	1,\
				101,	4.5,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giRS06	ftgen	0,0,-12,-2,	104,	1,	1,	1,\
				104,	5,	1,	1,\
				-1,	5,	-1,	-1
				
				
giGu06	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu06	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         
				
giTa06	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;7: ROCK 1 (4/4)
;				instr	strt	dur	amp
giBD07	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2.5,	1,	1,\
				101,	3,	1,	1,\
				101,	4.5,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giSn107	ftgen	0,0,-12,-2,	0,	1,	1,	1,\
				102,	2,	1,	1,\
				-1,	5,	-1,	-1

giSn207	ftgen	0,0,-12,-2,	0,	1,	1,	1,\
				103,	4,	1,	1,\
				-1,	5,	-1,	-1
				
				
giGu07	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giMa07	ftgen	0,0,-40,-2,	113,	1,	0.5,	1,\
				113,	1.5,	0.5,	1,\
				113,	2,	0.5,	1,\
				113,	2.5,	0.5,	1,\
				113,	3,	0.5,	1,\
				113,	3.5,	0.5,	1,\
				113,	4,	0.5,	1,\
				113,	4.5,	0.5,	1,\
				113,	5,	0.5,	1,\
				-1,	5,	-1,	-1

giQu07	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         
				
giTa07	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;8: ROCK 2 (4/4)
;				instr	strt	dur	amp
giBD08	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2.5,	1,	1,\
				101,	3,	1,	1,\
				101,	4.5,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giSn108	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				102,	2,	1,	1,\
				102,	4,	1,	1,\
				-1,	5,	-1,	-1

giSn208	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				103,	2.75,	1,	1,\
				103,	3.25,	1,	1,\
				-1,	5,	-1,	-1
				
				
giGu08	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giMa08	ftgen	0,0,-40,-2,	113,	1,	0.5,	1,\
				113,	1.5,	0.5,	1,\
				113,	2,	0.5,	1,\
				113,	2.5,	0.5,	1,\
				113,	3,	0.5,	1,\
				113,	3.5,	0.5,	1,\
				113,	4,	0.5,	1,\
				113,	4.5,	0.5,	1,\
				113,	5,	0.5,	1,\
				-1,	5,	-1,	-1

giQu08	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         
				
giTa08	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;9: MARCH 2/4 (12/8?!)
;				instr	strt	dur	amp
giBD09	ftgen	0,0,-16,-2,	101,	1,	1,	1,\
				101,	3,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giSn209	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				103,	2,	1,	1,\
				103,	4,	1,	1,\
				-1,	5,	-1,	-1

giMa09	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.667,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.667,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.667,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.667,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1				
				
giGu09	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.667,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.667,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu09	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

;10: Swing (4/4)
;				instr	strt	dur	amp
giBD10	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giCy110	ftgen	0,0,-32,-2,	105,	1,	0.5,	1,\
				105,	2,	0.5,	1,\
				105,	2.75,	0.5,	1,\
				105,	3,	0.5,	1,\
				105,	4,	0.5,	1,\
				105,	4.75,	0.5,	1,\
				105,	5,	0.5,	1,\
				-1,	5,	-1,	-1				
				
giGu10	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.75,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.75,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu10	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

;11: Jazz Waltz (3/4)
;				instr	strt	dur	amp
giBD11	ftgen	0,0,-12,-2,	101,	1,	1,	1,\
				101,	4,	1,	1,\
				-1,	4,	-1,	-1

giSn211	ftgen	0,0,-16,-2,	0,	1,	0.5,	1,\
				103,	1.5,	0.5,	1,\
				103,	2,	0.5,	1,\
				-1,	4,	-1,	-1				

giCy211	ftgen	0,0,-12,-2,	106,	1,	1,	1,\
				106,	4,	1,	1,\
				-1,	4,	-1,	-1				

				
giGu11	ftgen	0,0,-20,-2,	112,	1,	1,	0.7,\
				112,	2.5,	0.125,	1,\
				112,	3.5,	0.125,	1,\
				112,	4,	1,	0.7,\
				-1,	4,	-1,	-1

giQu11	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	3,	1,	1,\
				-1,	4,	-1,	-1         

giTa11	ftgen	0,0,-32,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				-1,	4,	-1,	-1

;12: Meringue (4/4)
;				instr	strt	dur	amp
giBD12	ftgen	0,0,-16,-2,	101,	1,	1,	1,\
				101,	2.5,	1,	1,\
				101,	3,	1,	1,\
				-1,	5,	-1,	-1

giBo312	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				109,	4,	1,	1,\
				0,	5,	1,	1,\
				-1,	5,	-1,	-1				


giCo12	ftgen	0,0,-16,-2,	111,	1,	1,	1,\
				111,	2.5,	1,	1,\
				111,	3,	1,	1,\
				-1,	5,	-1,	-1				

				
giGu12	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu12	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

giTa12	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;13: Cha Cha (4/4)
;				instr	strt	dur	amp
giBD13	ftgen	0,0,-20,-2,	101,	1,	1,	1,\
				101,	2.5,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				-1,	5,	-1,	-1

giBo313	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				109,	4,	1,	1,\
				109,	4.5,	1,	1,\
				-1,	5,	-1,	-1				

giCo13	ftgen	0,0,-28,-2,	111,	1,	1,	1,\
				111,	2,	1,	1,\
				111,	3,	0.5,	1,\
				111,	3.5,	0.5,	1,\
				111,	4,	1,	1,\
				111,	5,	1,	1,\
				-1,	5,	-1,	-1				

giGu13	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu13	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

giTa13	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1


;14: Beguine (4/4)
;				instr	strt	dur	amp
giBD14	ftgen	0,0,-20,-2,	101,	1,	1,	1,\
				101,	2.5,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				-1,	5,	-1,	-1

giCy214	ftgen	0,0,-12,-2,	0,	1,	1,	1,\
				106,	1.5,	1,	1,\
				-1,	5,	-1,	-1

giBo114	ftgen	0,0,-24,-2,	0,	1,	1,	1,\
				107,	1.5,	1,	1,\
				107,	2.5,	1,	1,\
				107,	3.5,	1,	1,\
				107,	4.5,	1,	1,\
				-1,	5,	-1,	-1				

giBo214	ftgen	0,0,-20,-2,	108,	1,	1,	1,\
				108,	3,	1,	1,\
				108,	4,	1,	1,\
				108,	5,	1,	1,\
				-1,	5,	-1,	-1				

giBo314	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				109,	4,	0.5,	1,\
				109,	4.5,	0.5,	1,\
				-1,	5,	-1,	-1				

giGu14	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu14	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

giTa14	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;15: Habanera (4/4)
;				instr	strt	dur	amp
giBD15	ftgen	0,0,-20,-2,	101,	1,	1,	1,\
				101,	2.5,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				-1,	5,	-1,	-1

giCy215	ftgen	0,0,-12,-2,	106,	1,	1,	1,\
				106,	5,	1,	1,\
				-1,	5,	-1,	-1
				
giGu15	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu15	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

giTa15	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;16: Slow Rock (4/4)
;				instr	strt	dur	amp
giBD16	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2.667,	0.333,	1,\
				101,	3,	1,	1,\
				101,	4.667,	0.333,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giRS16	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				104,	2,	1,	1,\
				104,	4,	1,	1,\
				-1,	5,	-1,	-1


giCy216	ftgen	0,0,-12,-2,	106,	1,	1,	1,\
				106,	5,	1,	1,\
				-1,	5,	-1,	-1
				
giGu16	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu16	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

giTa16	ftgen	0,0,-(14*4),-2,	115,	1,	0.3,	1,\
				115,	1.333,	0.3,	1,\
				115,	1.667,	0.3,	1,\
				115,	2,	0.3,	1,\
				115,	2.333,	0.3,	1,\
				115,	2.667,	0.3,	1,\
				115,	3,	0.3,	1,\
				115,	3.333,	0.3,	1,\
				115,	3.667,	0.3,	1,\
				115,	4,	0.3,	1,\
				115,	4.333,	0.3,	1,\
				115,	4.667,	0.3,	1,\
				115,	5,	0.3,	1,\
				-1,	5,	-1,	-1

;17: Rock 3 (4/4)
;				instr	strt	dur	amp
giBD17	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2.5,	0.5,	1,\
				101,	3,	1,	1,\
				101,	4.5,	0.5,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giSn117	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				102,	2,	1,	1,\
				102,	3.5,	1,	1,\
				-1,	5,	-1,	-1
				
giGu17	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu17	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

giTa17	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;18: Rock 4 (4/4)
;				instr	strt	dur	amp
giBD18	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	0.5,	1,\
				101,	4.5,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giSn118	ftgen	0,0,-16,-2,	0,	1,	1,	1,\
				102,	2,	1,	1,\
				102,	3.5,	1,	1,\
				-1,	5,	-1,	-1

giSn218	ftgen	0,0,-12,-2,	0,	1,	1,	1,\
				103,	2.75,	1,	1,\
				-1,	5,	-1,	-1
				
giGu18	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu18	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

giTa18	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1


;19: March 6/8 (4/4)
;				instr	strt	dur	amp
giBD19	ftgen	0,0,-24,-2,	101,	1,	1,	1,\
				101,	2,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giCy119	ftgen	0,0,-40,-2,	105,	1,	0.3,	1,\
				105,	1.667,	0.3,	1,\
				105,	2,	0.3,	1,\
				105,	2.667,	0.3,	1,\
				105,	3,	0.3,	1,\
				105,	3.667,	0.3,	1,\
				105,	4,	0.3,	1,\
				105,	4.667,	0.3,	1,\
				105,	5,	0.3,	1,\
				-1,	5,	-1,	-1

giGu19	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.667,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.667,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu19	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         


;20: Latin Swing (4/4)
;				instr	strt	dur	amp
giBD20	ftgen	0,0,-20,-2,	101,	1,	1,	1,\
				101,	3,	1,	1,\
				101,	4,	1,	1,\
				101,	5,	1,	1,\
				-1,	5,	-1,	-1

giCy120	ftgen	0,0,-32,-2,	105,	1,	0.3,	1,\
				105,	2,	0.3,	1,\
				105,	2.75,	0.3,	1,\
				105,	3,	0.3,	1,\
				105,	4,	0.3,	1,\
				105,	4.75,	0.3,	1,\
				105,	5,	0.3,	1,\
				-1,	5,	-1,	-1

giBo120	ftgen	0,0,-12,-2,	0,	1,	0.3,	1,\
				107,	2,	0.3,	1,\
				-1,	5,	-1,	-1

giBo320	ftgen	0,0,-16,-2,	0,	1,	0.5,	1,\
				109,	4,	0.5,	1,\
				109,	4.75,	0.25,	1,\
				-1,	5,	-1,	-1

				
giGu20	ftgen	0,0,-32,-2,	112,	1,	1,	0.7,\
				112,	2,	0.125,	1,\
				112,	2.5,	0.125,	1,\
				112,	3,	1,	0.7,\
				112,	4,	0.125,	1,\
				112,	4.5,	0.125,	1,\
				112,	5,	1,	0.7,\
				-1,	5,	-1,	-1

giQu20	ftgen	0,0,-12,-2,	0,	1,	0,	1,\
				114,	4,	1,	1,\
				-1,	5,	-1,	-1         

giTa20	ftgen	0,0,-40,-2,	115,	1,	0.5,	1,\
				115,	1.5,	0.5,	1,\
				115,	2,	0.5,	1,\
				115,	2.5,	0.5,	1,\
				115,	3,	0.5,	1,\
				115,	3.5,	0.5,	1,\
				115,	4,	0.5,	1,\
				115,	4.5,	0.5,	1,\
				115,	5,	0.5,	1,\
				-1,	5,	-1,	-1

;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

instr	1	; read widgets
	gktempo		chnget	"tempo"

	; volume controls
	gkbassdrum	chnget	"bassdrum"
	gksnare1	chnget	"snare1"    
	gksnare2	chnget	"snare2"    
	gkrimshot	chnget	"rimshot"   
	gkcymbal1	chnget	"cymbal1"   
	gkcymbal2	chnget	"cymbal2"   
	gkbongo1	chnget	"bongo1"    
	gkbongo2	chnget	"bongo2"    
	gkbongo3	chnget	"bongo3"    
	gkclaves	chnget	"claves"    
	gkcowbell	chnget	"cowbell"   
	gkguiro		chnget	"guiro"     
	gkmaracas	chnget	"maracas"   
	gkquijada	chnget	"quijada"   
	gktambourine	chnget	"tambourine"

	; mute switches
	gkmute1		chnget	"mute1"
	gkmute2		chnget	"mute2"
	gkmute3		chnget	"mute3"
	gkmute4		chnget	"mute4"
	gkmute5		chnget	"mute5"
	gkmute6		chnget	"mute6"
	gkmute7		chnget	"mute7"
	gkmute8		chnget	"mute8"
	gkmute9		chnget	"mute9"
	gkmute10	chnget	"mute10"
	gkmute11	chnget	"mute11"
	gkmute12	chnget	"mute12"
	gkmute13	chnget	"mute13"
	gkmute14	chnget	"mute14"
	gkmute15	chnget	"mute15"

	; solo switches
	gksolo1		chnget	"solo1"
	gksolo2		chnget	"solo2"
	gksolo3		chnget	"solo3"
	gksolo4		chnget	"solo4"
	gksolo5		chnget	"solo5"
	gksolo6		chnget	"solo6"
	gksolo7		chnget	"solo7"
	gksolo8		chnget	"solo8"	
	gksolo9		chnget	"solo9"	
	gksolo10	chnget	"solo10"	
	gksolo11	chnget	"solo11"	
	gksolo12	chnget	"solo12"	
	gksolo13	chnget	"solo13"	
	gksolo14	chnget	"solo14"	
	gksolo15	chnget	"solo15"	

	; add up all solo switch values (if greater than '1' then a solo button must be active)
	kSoloSum	=	gksolo1+gksolo2+gksolo3+gksolo4+gksolo5+gksolo6+gksolo7+gksolo8+gksolo9+gksolo10+gksolo11+gksolo12+gksolo13+gksolo14+gksolo15

	; macro in which the play/don't play status for each instrument is defined
#define	SOLO_MUTE_STATUS(N)	
	#
	if gksolo$N==1 then			; if solo button is on...
	 gkstatus$N	=	1		; ... definitely play this instrument
	elseif kSoloSum>0 then			; otherwise if any one or more of the other solo buttons is active
	 gkstatus$N	=	0		; mute this instrument
	else					; otherwise
	 gkstatus$N	=	(1-gkmute$N)	; status defined by the inverse of the mute button value
	endif
	#
	; expand macro for each instrument
	$SOLO_MUTE_STATUS(1)
	$SOLO_MUTE_STATUS(2)
	$SOLO_MUTE_STATUS(3)
	$SOLO_MUTE_STATUS(4)
	$SOLO_MUTE_STATUS(5)
	$SOLO_MUTE_STATUS(6)
	$SOLO_MUTE_STATUS(7)
	$SOLO_MUTE_STATUS(8)
	$SOLO_MUTE_STATUS(9)
	$SOLO_MUTE_STATUS(10)
	$SOLO_MUTE_STATUS(11)
	$SOLO_MUTE_STATUS(12)
	$SOLO_MUTE_STATUS(13)
	$SOLO_MUTE_STATUS(14)
	$SOLO_MUTE_STATUS(15)
	
	; rhythm buttons
	gkbut1		chnget	"but1"
	gkbut2		chnget	"but2"
	gkbut3		chnget	"but3"
	gkbut4		chnget	"but4"
	gkbut5		chnget	"but5"
	gkbut6		chnget	"but6"
	gkbut7		chnget	"but7"
	gkbut8		chnget	"but8"
	gkbut9		chnget	"but9"
	gkbut10		chnget	"but10"

	; derive a value for upper/lower row by using the two switches (r1 and r2) as radio buttons
	gkUpperLower	CabbageRadio2	"r1","r2"	; call UDO

	; miscellaneos controls	
	gkvolume	chnget	"volume"
	gkdist		chnget	"dist"
	gkcomp		chnget	"comp"
	gkfold		chnget	"fold"
	gkOnOff		chnget	"OnOff"  
	gkcutup		chnget	"cutup"

	ktrig1	trigger	gkOnOff,0.5,0		; if on/off switch is turned 'on' generate a '1'
	ktrig2	trigger	gkcutup,0.5,0		; if 'Mash' button is turned 'on' generate a '1'

	schedkwhen	ktrig1+ktrig2,0,0,  3,0,-1	; start rhythm generater instrument (with a held note) whenever either the on/off or the 'Mash' button are turned on.

	schedkwhen	ktrig2,0,0,199,0,-1		; start bbcut instrument if Mash button is turned on.
endin


instr	2	;READ MIDI AND TRIGGER NOTES
	inum	notnum						;READ IN MIDI NOTE NUMBER
	idb	veloc	-30,0					;READ IN MIDI NOTE VELOCITY (WILL BE USED AS A DECIBEL VALUE)
	iinstr	wrap	inum,0,15				;MAP MIDI NOTE NUMBERS (RANGE: 0 - 127) TO DRUM SOUND NUMBER (0 - 14)
	if iinstr==11 then					;if this is instr 11 (guiro). i.e. sustains and responds to midi note release...
	 event_i	"i",101+iinstr,0,3600,ampdbfs(idb)	;CALL guiro INSTRUMENT AND SEND AMPLITUDE VALUE AS p4
	 krel	release						;sense not release
	 if krel==1 then					;if this note is released...
	  turnoff2	101+iinstr,0,1				;...turn off the subinstrumet
	 endif
	else							;otherwise (any instrument besides the guiro) i.e. no sustain and no midi release
	 event_i	"i",101+iinstr,0,0.956,ampdbfs(idb)	;CALL THE RELEVANT INSTRUMENT AND SEND AMPLITUDE VALUE AS p4
	endif
endin

instr	3	; rhythm sequencer instrument
	if gkOnOff==0 then	; if on/off switch is off...
	 turnoff		; turnoff this instrument
	endif
	
	if i(gkcutup)==1 then				;start bbcut instr when sequencer is started (if Mash button is on)
	 event_i	"i",199,0,-1
	endif
	
	kBPS	=	gktempo/60			;DERIVE BEATS-PER-SECOND 

	if gkcutup==1 then				;while bbcut is active...
	 ktrig	changed	gktempo				;sense for changes in the tempo button
	 if ktrig==1 then				;if the tempo has changed...
	  reinit RESTART_PHASORS			;restart the rhythm sequencer phasors
	  event	"i",199,0,-1				;restart bbcut instrument
	 endif
	 RESTART_PHASORS:
	endif
	kphase3    phasor  kBPS/3			;3/4 phasor (range 0 - 1)
	kphase3	=	kphase3 * 3			;rescale to the range 0 - 3
	kphase4    phasor  kBPS/4			;4/4 phasor (range 0 - 1)
	kphase4	=	kphase4 * 4			;rescale tot he range 0 - 4
	rireturn
	
	kphase	=	kphase4				;default phase mode (4/4)
	
	;lower buttons always take precedence so start with higher button in 'if' interrogations
	if     gkbut10==1 then
	 kphase	=	kphase4
	endif
	if     gkbut9==1 then
	 kphase	=	kphase4
	endif
	if     gkbut8==1 then
	 kphase	=	kphase4
	endif
	if     gkbut7==1 then
	 kphase	=	kphase4
	endif
	if     gkbut6==1 then
	 kphase	=	kphase4
	endif
	if     gkbut5==1 then
	 kphase	=	kphase4
	endif
	if     gkbut4==1 then
	 kphase	=	kphase4
	endif
	if     gkbut3==1 then
	 kphase	=	kphase4
	endif
	if     gkbut2==1 then
	 kphase	=	kphase4
	endif
	if     gkbut1==1 then
	 kphase	=	kphase3
	endif
	
	;initialise the p fields (timedseqs p-field outputs are also input variables)
	kpBD_1		init	0
	kpBD_2		init	0
	kpBD_3		init	0
	kpBD_4		init	0

	kpSn1_1		init	0
	kpSn1_2		init	0
	kpSn1_3		init	0
	kpSn1_4		init	0

	kpSn2_1		init	0
	kpSn2_2		init	0
	kpSn2_3		init	0
	kpSn2_4		init	0

	kpRS_1		init	0
	kpRS_2		init	0
	kpRS_3		init	0
	kpRS_4		init	0

	kpCy1_1		init	0
	kpCy1_2		init	0
	kpCy1_3		init	0
	kpCy1_4		init	0
	
	kpCy2_1		init	0
	kpCy2_2		init	0
	kpCy2_3		init	0
	kpCy2_4		init	0
	
	kpBo1_1		init	0
	kpBo1_2		init	0
	kpBo1_3		init	0
	kpBo1_4		init	0
	
	kpBo2_1		init	0
	kpBo2_2		init	0
	kpBo2_3		init	0
	kpBo2_4		init	0
	
	kpBo3_1		init	0
	kpBo3_2		init	0
	kpBo3_3		init	0
	kpBo3_4		init	0
	
	kpCl_1		init	0
	kpCl_2		init	0
	kpCl_3		init	0
	kpCl_4		init	0
	
	kpCo_1		init	0
	kpCo_2		init	0
	kpCo_3		init	0
	kpCo_4		init	0
	
	kpGu_1		init	0
	kpGu_2		init	0
	kpGu_3		init	0
	kpGu_4		init	0
	
	kpMa_1		init	0
	kpMa_2		init	0
	kpMa_3		init	0
	kpMa_4		init	0
	
	kpQu_1		init	0
	kpQu_2		init	0
	kpQu_3		init	0
	kpQu_4		init	0
	
	kpTa_1		init	0
	kpTa_2		init	0
	kpTa_3		init	0
	kpTa_4		init	0


	;initialise note triggers
	ktriggerBD	=	0
	ktriggerSn1	=	0
	ktriggerSn2	=	0
	ktriggerRS	=	0
	ktriggerCy1	=	0
	ktriggerCy2	=	0
	ktriggerBo1	=	0
	ktriggerBo2	=	0
	ktriggerBo3	=	0
	ktriggerCo	=	0
	ktriggerCl	=	0
	ktriggerMa	=	0
	ktriggerGu	=	0
	ktriggerQu	=	0
	ktriggerTa	=	0
	
	kmintim	init	0.01	;minimum allowed time between note triggering (to prevent erroneous double triggerings)
	
	; macro within which an instrument is scanned
#define	SCAN_INSTRUMENT(NAME'NUM)
	#
	ktrigger	timedseq	kphase+0.99, gi$NAME.$NUM, kp$NAME._1, kp$NAME._2,kp$NAME._3,kp$NAME._4	; read table using phasor
	ktrigger$NAME	=	ktrigger$NAME + ktrigger							; add trigger for this instrument to the accumulator for all instruments 
	#
	
	; read instrument rhythm tables
	if gkUpperLower==1 then			; upper rhythm selected

	 if gkbut1==1 then	;WALTZ
	  $SCAN_INSTRUMENT(BD'01)
	  $SCAN_INSTRUMENT(Sn2'01)
	  $SCAN_INSTRUMENT(Cy2'01)
	  $SCAN_INSTRUMENT(Gu'01)
	  $SCAN_INSTRUMENT(Qu'01)
	  $SCAN_INSTRUMENT(Ta'01)
	 endif  


	 if gkbut2==1 then	;SAMBA
	  $SCAN_INSTRUMENT(BD'02)
	  $SCAN_INSTRUMENT(Bo3'02)
	  $SCAN_INSTRUMENT(Co'02)
	  $SCAN_INSTRUMENT(Qu'02)
	  $SCAN_INSTRUMENT(Gu'02)
	  $SCAN_INSTRUMENT(Ta'02)
	 endif

	 if gkbut3==1 then	;MAMBO
	  $SCAN_INSTRUMENT(BD'03)
	  $SCAN_INSTRUMENT(Bo3'03)
	  $SCAN_INSTRUMENT(Co'03)
	  $SCAN_INSTRUMENT(Qu'03)
	  $SCAN_INSTRUMENT(Gu'03)
	  $SCAN_INSTRUMENT(Ta'03)
	 endif

	 if gkbut4==1 then	;RUMBA
	  $SCAN_INSTRUMENT(BD'04)
	  $SCAN_INSTRUMENT(Cy1'04)
	  $SCAN_INSTRUMENT(Bo1'04)
	  $SCAN_INSTRUMENT(Bo2'04)
	  $SCAN_INSTRUMENT(Bo3'04)
	  $SCAN_INSTRUMENT(Cl'04)
	  $SCAN_INSTRUMENT(Qu'04)
	  $SCAN_INSTRUMENT(Gu'04)
	  $SCAN_INSTRUMENT(Ta'04)
	 endif

	 if gkbut5==1 then	;TANGO
	  $SCAN_INSTRUMENT(BD'05)
	  $SCAN_INSTRUMENT(Cy2'05)
	  $SCAN_INSTRUMENT(Qu'04)
	  $SCAN_INSTRUMENT(Gu'04)
	  $SCAN_INSTRUMENT(Ta'05)
	 endif

 	 if gkbut6==1 then	;BOSSANOVA
	  $SCAN_INSTRUMENT(BD'06)
	  $SCAN_INSTRUMENT(RS'06)
	  $SCAN_INSTRUMENT(Qu'06)
	  $SCAN_INSTRUMENT(Gu'06)
	  $SCAN_INSTRUMENT(Ta'06)
	 endif

 	 if gkbut7==1 then	;ROCK 1
	  $SCAN_INSTRUMENT(BD'07)
	  $SCAN_INSTRUMENT(Sn1'07)
	  $SCAN_INSTRUMENT(Sn2'07)
	  $SCAN_INSTRUMENT(Ma'08)
	  $SCAN_INSTRUMENT(Qu'07)
	  $SCAN_INSTRUMENT(Gu'07)
	  $SCAN_INSTRUMENT(Ta'07)
	 endif

 	 if gkbut8==1 then	;ROCK 2
	  $SCAN_INSTRUMENT(BD'08)
	  $SCAN_INSTRUMENT(Sn1'08)
	  $SCAN_INSTRUMENT(Sn2'08)
	  $SCAN_INSTRUMENT(Ma'08)
	  $SCAN_INSTRUMENT(Qu'08)
	  $SCAN_INSTRUMENT(Gu'08)
	  $SCAN_INSTRUMENT(Ta'08)
	 endif

 	 if gkbut9==1 then	;MARCH 2/4
	  $SCAN_INSTRUMENT(BD'09)
	  $SCAN_INSTRUMENT(Sn2'09)
	  $SCAN_INSTRUMENT(Ma'09)
	  $SCAN_INSTRUMENT(Qu'09)
	  $SCAN_INSTRUMENT(Gu'09)
	 endif

 	 if gkbut10==1 then	;SWING
	  $SCAN_INSTRUMENT(BD'10)
	  $SCAN_INSTRUMENT(Cy1'10)
	  $SCAN_INSTRUMENT(Qu'10)
	  $SCAN_INSTRUMENT(Gu'10)
	 endif

	 ; START OF BAR GREEN LED INDICATOR	
  	 ktrigger	trigger	kphase,0.01,0		; indicator trigger
	 schedkwhen	ktrigger, 0, 0, 150, 0, 0	; call indicator 'on' instrument (which then calls indicator off instrument)

	else						; lower rhythm selected

	 if gkbut1==1 then	;JAZZ WALTZ
	  $SCAN_INSTRUMENT(BD'11)
	  $SCAN_INSTRUMENT(Sn2'11)
	  $SCAN_INSTRUMENT(Cy2'11)
	  $SCAN_INSTRUMENT(Gu'11)
	  $SCAN_INSTRUMENT(Qu'11)
	  $SCAN_INSTRUMENT(Ta'11)
	 endif  

	 if gkbut2==1 then	;MERINGUE
	  $SCAN_INSTRUMENT(BD'12)
	  $SCAN_INSTRUMENT(Bo3'12)
	  $SCAN_INSTRUMENT(Co'12)
	  $SCAN_INSTRUMENT(Gu'12)
	  $SCAN_INSTRUMENT(Qu'12)
	  $SCAN_INSTRUMENT(Ta'12)
	 endif  

	 if gkbut3==1 then	;CHA CHA
	  $SCAN_INSTRUMENT(BD'13)
	  $SCAN_INSTRUMENT(Bo3'13)
	  $SCAN_INSTRUMENT(Co'13)
	  $SCAN_INSTRUMENT(Gu'13)
	  $SCAN_INSTRUMENT(Qu'13)
	  $SCAN_INSTRUMENT(Ta'13)
	 endif  

	 if gkbut4==1 then	;BEGUINE
	  $SCAN_INSTRUMENT(BD'14)
	  $SCAN_INSTRUMENT(Cy2'14)
	  $SCAN_INSTRUMENT(Bo1'14)
	  $SCAN_INSTRUMENT(Bo2'14)
	  $SCAN_INSTRUMENT(Bo3'14)
	  $SCAN_INSTRUMENT(Gu'14)
	  $SCAN_INSTRUMENT(Qu'14)
	  $SCAN_INSTRUMENT(Ta'14)
	 endif  

	 if gkbut5==1 then	;HABANERA
	  $SCAN_INSTRUMENT(BD'15)
	  $SCAN_INSTRUMENT(Cy2'15)
	  $SCAN_INSTRUMENT(Gu'15)
	  $SCAN_INSTRUMENT(Qu'15)
	  $SCAN_INSTRUMENT(Ta'15)
	 endif  

	 if gkbut6==1 then	;SLOW ROCK
	  $SCAN_INSTRUMENT(BD'16)
	  $SCAN_INSTRUMENT(RS'16)
	  $SCAN_INSTRUMENT(Gu'16)
	  $SCAN_INSTRUMENT(Qu'16)
	  $SCAN_INSTRUMENT(Ta'16)
	 endif  

	 if gkbut7==1 then	;ROCK 3
	  $SCAN_INSTRUMENT(BD'17)
	  $SCAN_INSTRUMENT(Sn1'17)
	  $SCAN_INSTRUMENT(Gu'17)
	  $SCAN_INSTRUMENT(Qu'17)
	  $SCAN_INSTRUMENT(Ta'17)
	 endif  

	 if gkbut8==1 then	;ROCK 4
	  $SCAN_INSTRUMENT(BD'18)
	  $SCAN_INSTRUMENT(Sn1'18)
	  $SCAN_INSTRUMENT(Sn2'18)
	  $SCAN_INSTRUMENT(Gu'18)
	  $SCAN_INSTRUMENT(Qu'18)
	  $SCAN_INSTRUMENT(Ta'18)
	 endif  

	 if gkbut9==1 then	;MARCH 6/8
	  $SCAN_INSTRUMENT(BD'19)
	  $SCAN_INSTRUMENT(Cy1'19)
	  $SCAN_INSTRUMENT(Gu'19)
	  $SCAN_INSTRUMENT(Qu'19)
	 endif  

	 if gkbut10==1 then	;LATIN SWING
	  $SCAN_INSTRUMENT(BD'20)
	  $SCAN_INSTRUMENT(Cy1'20)
	  $SCAN_INSTRUMENT(Bo1'20)
	  $SCAN_INSTRUMENT(Bo3'20)
	  $SCAN_INSTRUMENT(Gu'20)
	  $SCAN_INSTRUMENT(Qu'20)
	  $SCAN_INSTRUMENT(Ta'20)
	 endif  


	 ; START OF BAR RED LED INDICATOR	
  	 ktrigger	trigger	kphase,0.01,0		; indicator trigger
	 schedkwhen	ktrigger, 0, 0, 160, 0, 0	; call indicator 'on' instrument (which then calls indicator off instrument)

	endif

	; play instruments according to triggers and p-fields read from the tables
	schedkwhen	ktriggerBD*kpBD_1*gkstatus1, kmintim, 0, kpBD_1, 0, 0.001,kpBD_4
	schedkwhen	ktriggerSn1*kpSn1_1*gkstatus2, kmintim, 0, kpSn1_1, 0, 0.001,kpSn1_4
	schedkwhen	ktriggerSn2*kpSn2_1*gkstatus3, kmintim, 0, kpSn2_1, 0, 0.001,kpSn2_4
	schedkwhen	ktriggerRS*kpRS_1*gkstatus4, kmintim, 0, kpRS_1, 0, 0.001,kpRS_4
	schedkwhen	ktriggerCy1*kpCy1_1*gkstatus5, kmintim, 0, kpCy1_1, 0, 0.001,kpCy1_4
	schedkwhen	ktriggerCy2*kpCy2_1*gkstatus6, kmintim, 0, kpCy2_1, 0, 0.001,kpCy2_4
	schedkwhen	ktriggerBo1*kpBo1_1*gkstatus7, kmintim, 0, kpBo1_1, 0, 0.001,kpBo1_4
	schedkwhen	ktriggerBo2*kpBo2_1*gkstatus8, kmintim, 0, kpBo2_1, 0, 0.001,kpBo2_4
	schedkwhen	ktriggerBo3*kpBo3_1*gkstatus9, kmintim, 0, kpBo3_1, 0, 0.001,kpBo3_4
	schedkwhen	ktriggerCo*kpCo_1*gkstatus10, kmintim, 0, kpCo_1, 0, 0.001,kpCo_4
	schedkwhen	ktriggerCl*kpCl_1*gkstatus11, kmintim, 0, kpCl_1, 0, 0.001,kpCl_4
	kpGu_3		limit		kpGu_3*(60/gktempo),0.04,300				;duration of guiro read from table and is also dependent upon tempo
	schedkwhen	ktriggerGu*kpGu_1*gkstatus12, kmintim, 0, kpGu_1, 0, kpGu_3,kpGu_4
	schedkwhen	ktriggerMa*kpMa_1*gkstatus13, kmintim, 0, kpMa_1, 0, 0.001,kpMa_4
	schedkwhen	ktriggerQu*kpQu_1*gkstatus14, kmintim, 0, kpQu_1, 0, 0.001,kpQu_4
	schedkwhen	ktriggerTa*kpTa_1*gkstatus15, kmintim, 0, kpTa_1, 0, 0.001,kpTa_4
endin

giFlashTime	=	0.1

instr	101	; Korg Minipops 7: Bass Drum
;	chnset	giOn,"Act1"					; turn instrument indicator on
;	scoreline_i	{{ i 201 0.1 0 "Act1"}}			; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act1"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	p3	=	0.437
	kactive active	p1					; turnoff older active notes
	;if kactive>1 then
	; turnoff
	;endif
	ifrq	=	64					; fundemantal pitch
	asig	mpulse	1,0					; generate a click impulse
	asig	reson	asig,ifrq,ifrq*0.001,2			; reson filter it
	asig	tone	asig,500				; lowpass filter it
	aenv	transeg	1,p3,-14,0				; create an amplitude envelope
	asig	=	asig * aenv * 225 * p4 * i(gkbassdrum)	; scale signal
	gasend	=	gasend + asig				; add to accumulating global audio send variable
endin

instr	102	; Korg Minipops 7: Snare 1
;	chnset	giOn,"Act2"					; turn instrument indicator on
;	scoreline_i	{{ i 201 0.1 0 "Act2"}}         	; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act2"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1					; turnoff older overlapping notes
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.387
	
	; body of the sound (duration governed by p3)
	anoise	pinkish	1					; generate some pink noise
	asig	reson	anoise,6250,9000,1			; reson filter it
	aenv	transeg	1,p3,-5,0				; create an amplitude envelope
	asig	=	asig * aenv				
	asig	buthp	asig,3000
	
	; 'crack' at the beginning of the sound (duration governed by idur)
	idur	=	0.006
	acps	transeg	800,idur,-4,60				; pitch envelope
	astrike	poscil	1,acps,gisine				; sine oscillator 'crack'
	aenv2	transeg	1,idur,-2,0				; amplitude envelope
	astrike	=	astrike * aenv2				; apply amplitude envelope
	asig	=	( ( astrike * 0.7 ) + (asig * 2 ) ) * p4 * i(gksnare1)	; balance the two sound components and scale the sound mixture
	gasend	=	gasend + asig				; add to accumulating global audio send variable
endin

instr	103	; Korg Minipops 7: Snare 2
;	chnset	giOn,"Act3"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act3"}}         ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act3"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.4
	
	anoise	pinkish	1
	;asig	reson	anoise,5200,5000,1
	asig	butbp	anoise,5000,8000
	aenv	transeg	1,p3,-8,0
	asig	=	asig * aenv*p4
	asig	buthp	asig,3000
	
	idur	=	0.005
	acps	transeg	800,idur,-4,200
	astrike	poscil	1,acps,gisine
	aenv2	transeg	1,idur,-2,0             
	astrike	=	astrike * aenv2
	asig	=	((astrike*0.5) + (asig*2.3)) * p4 * i(gksnare2)
	gasend	=	gasend + asig
endin

instr	104	;  Korg Minipops 7: Rimshot
;	chnset	giOn,"Act4"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act4"}}         ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act4"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.005
	icps	=	1700
	aenv	expon	1,p3,0.0001
	iphs	=	0.2
	asig	oscili	aenv,icps,gisine,iphs
	asig2	reson	asig,icps,1500,2
	asig	buthp	( (asig2 * 0.4 ) + asig ) * 0.3 * p4 * i(gkrimshot), 500
	gasend	=	gasend + asig
endin

instr	105	; Korg Minipops 7: Cymbal 1
;	chnset	giOn,"Act5"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act5"}}         ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act5"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.304
	aenv	transeg	1,p3,-2,0
	anoise	dust2	1, 30000			;CREATE NOISE SIGNAL	
	icf	=	6000
	asig1	reson	anoise*aenv,icf,icf*0.7,1
	asig1	butlp	asig1,14000
	asig2	buthp	(asig1+(anoise*0.001))*aenv,6000
	asig	=	asig2 * aenv * 0.5 * p4 * i(gkcymbal1)
	gasend	=	gasend + asig
endin

instr	106	; Korg Minipops 7: Cymbal 2
;	chnset	giOn,"Act6"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act6"}}         ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act6"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	1.404

	aenv	transeg	1,p3,-2,0
	anoise	dust2	1, 10000
	icf	=	5000
	asig	reson	anoise*aenv,icf,icf*0.9,1
	asig	tone	asig,12000
	asig	buthp	asig*aenv,6000
	asig	=	asig*aenv

	idur	=	0.004
	acps	transeg	1000,idur,-4,400
	astrike	poscil	1,acps,gisine
	aenv2	transeg	1,idur,-2,0
	astrike	=	astrike * aenv2

	asig	=	( (astrike * 0.2 ) + (asig * 1.5 ) ) * p4 * i(gkcymbal2)
	gasend	=	gasend + asig
endin

instr	107	; Minipops: Bongo 1
;	chnset	giOn,"Act7"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act7"}}         ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act7"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.2
	aenv	transeg	1,p3,13,0
	asig	mpulse	1,0
	icps	=	630;588
	asig	reson	asig,icps,icps*0.03,2
	asig	buthp	asig,300
	asig	butlp	asig,8000	
	asig	=	asig * 4 * aenv * p4 * i(gkbongo1)
	gasend	=	gasend + asig
endin

instr	108	; Korg Minipops 7: Bongo 2
;	chnset	giOn,"Act8"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act8"}}         ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act8"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.3
	kcps	expon	400,p3,390	; bongo 2 freq. and that of claves (body) should correspond
	aenv	transeg	1,p3-0.005,0,0.1,0.005,0, 0
	asig	mpulse	1,0
	asig	reson	asig,kcps,kcps*0.03,2
	asig	tone	asig,5000
	asig	buthp	asig,100
	asig	=	asig * 4 * aenv * p4 * i(gkbongo2)
	gasend	=	gasend + asig
endin

instr	109	; Korg Minipops 7: Bongo 3
;	chnset	giOn,"Act9"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act9"}}         ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act9"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	1.229
	icps	=	194;187
	aenv	transeg	0, 0.001, -2, 1, p3-0.001, -2, 0
	asig	mpulse	1,0
	kbw	linseg	0.05,0.01,0.008
	asig	reson	asig,icps,icps*kbw,2
	asig	butlp	asig,11000
	asig	=	asig * 5 * aenv * p4 * i(gkbongo3)
	gasend	=	gasend + asig
endin

instr	110	; Korg Minipops 7: Claves
;	chnset	giOn,"Act10"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act10"}}        ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act10"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.186
	aenv	line	1,p3,0
	asig	mpulse	1,0
	icps1	=	400;410	; body - 		; bongo 2 freq. and that of claves (body) should correspond
	asig1	reson	asig,icps1,icps1*0.025,2
	icps2	=	2180	; strike
	asig2	reson	asig,icps2,icps2*0.03,2
	asig	=	(asig1 + (asig2 * 1.3) ) * 3.2 * aenv * p4 * i(gkclaves)
	gasend	=	gasend + asig
endin

instr	111	; Korg Minipops 7: Cowbell
;	chnset	giOn,"Act11"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act11"}}        ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act11"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.3
	aenv	line	1,p3,0
	astrike	mpulse	1,0
	icps1	=	850
	asig1	reson	astrike,icps1,icps1*0.007,2	;low (body)
	icps2	=	4707
	asig2	reson	astrike,icps2,icps2*0.03,2	;high (strike)
	amix	=	asig1 + (asig2 * 0.8)
	amix	buthp	amix, 100
	asig	=	amix * aenv * p4 * i(gkcowbell) * 3
	gasend	=	gasend + asig
endin

instr	112	; Korg Minipops 7: Guiro
;	chnset	giOn,"Act12"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act12"}}        ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act12"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then        
	; turnoff
	;endif
	idur	=	(p3=3600?0.256:p3*0.9)	
	kcps	transeg	66,idur,2,77
	asig	vco2	0.1,kcps,6;,0.0005
	icf	=	2000
	asig	reson	asig,4300,3000,1
	asig	buthp	asig,1000
	aenv	linseg	0,0.001,1,p3-0.111,0.6,0.1,1,0.01,0
	asig	=	asig * 0.012 * aenv * i(gkguiro) * p4
	gasend	=	gasend + asig
endin

instr	113	; Korg Minipops 7: Maracas
;	chnset	giOn,"Act13"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act13"}}        ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act13"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.05
	asig	noise	1,0.04
	icf	=	5000
	asig	reson	asig,9000,4000,2
	asig	buthp	asig,2000
	aenv	transeg	1,p3,-4,0
	asig	=	asig * aenv * 0.35 * p4 * i(gkmaracas)
	gasend	=	gasend + asig
endin

instr	114	; Korg Minipops 7: Quijada
;	chnset	giOn,"Act14"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act14"}}        ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act14"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.817

	idur1	=	0.817
	apulse1	mpulse	1,1/22.7272
	kenv1	transeg	0.8,0.05,1, 1,idur1-0.05,-6,0
	apulse1	reson	apulse1,2727,400,1

	idur2	=	0.32
	apulse2	mpulse	1,1/13.1579
	kenv2	transeg	0.8,0.05,1, 1,idur2-0.05,-6,0
	apulse2	reson	apulse2,2727,400,1
	
	amix	=	((apulse1 * kenv1 * 4) + (apulse2 * kenv2 * 4)) * i(gkquijada) * p4
	asig	buthp	amix, 550
	gasend	=	gasend + asig
endin

instr	115	; Korg Minipops 7: Tambourine
;	chnset	giOn,"Act15"				; turn instrument indicator on                             
;	scoreline_i	{{ i 201 0.1 0 "Act15"}}        ; call instrument to turn off indicator after a short delay
	xtratim	giFlashTime
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act15"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kactive active	p1
	;if kactive>1 then
	; turnoff
	;endif
	p3	=	0.271
	aenv	transeg	1,p3,-8,0
	;aenv	linseg	1, 0.02, 1, 0.01, 0.4, p3-0.02-0.01, 0 
	anoise	noise	1,0
	asig	reson	anoise*aenv,4600, 100,2
	asig	buthp	asig+(anoise*0.1*aenv),7000
	asig	reson	asig,9000,3000,1
	asig	=	asig * aenv * 1.5 * i(gktambourine) * p4
	gasend	=	gasend + asig
endin




instr	150	; green indicator on
	chnset	giOn,"Indic1"
	event_i	"i",p1+1,0.1,0
endin

instr	151	; green indicator off
	chnset	giOff,"Indic1"
endin

instr	160	; green indicator on
	chnset	giOn,"Indic2"
	event_i	"i",p1+1,0.1,0
endin

instr	161	; green indicator off
	chnset	giOff,"Indic2"
endin

instr	199
	if gkcutup==0 then	; if 'mash' button is off...
	 turnoff		; ...turn this instrument off
	endif
	
	; input parameters for bbcut 
	;; << 4/4 >>
	isubdiv        =	8
	ibarlen        =	2 	
	iphrase        =	8 	
	irepeats       =	2 	
	istutspd       =	4 	
	istutchnc      =	1 	

	;; << 12/8 >>
	;isubdiv        =	12
	;ibarlen        =	4 	
	;iphrase        =	4 	
	;irepeats       =	3 	
	;istutspd       =	3 	
	;istutchnc      =	1 	

 	asig	bbcutm	gasend,   i(gktempo)/60, isubdiv,  ibarlen,  iphrase, irepeats, istutspd, istutchnc
	gasend	=	gasend + asig

	if gkOnOff==0 then	; if main on/off button is turned off...
	 turnoff		; ... turn this instrument off too
	endif
endin

instr	200	; output
	kon	=	1
	koff	=	0

	kporttime	linseg	0,0.001,0.05

	gasend	=	gasend * 3

	 ktrig	changed	gkdist
	 if ktrig==1 then
	  reinit RESTART_DIST
	 endif
	 RESTART_DIST:
	 if i(gkdist)>0 then
	  chnset	giOn,"DistOn"
	 else
	  chnset	giOff,"DistOn"
	 endif
	 if gkdist>0 then
	  gasend	clip		gasend,0,1-(i(gkdist)*0.99)
	  rireturn
	  gasend	dam 		gasend, 0.25,1,   1.35,   0.01, 0.01	; compress the signal (whenever distortion is on) 
	 endif
	 ;                              thr  rat1 rat2 tim1  tim2


	; foldover effect (downsampling)
	if gkfold>0 then
	 chnset	kon,"FoldOn"
	else
	 chnset	koff,"FoldOn"
	endif
	gkfold	portk	gkfold,kporttime
	if gkfold>0 then
	 gasend	fold		gasend,1+(gkfold*300)	
	endif
	ktrig	changed	gkfold

	gasend	tone		gasend,10000	; cut high frequencies
	gasend	atone		gasend,100	; cut low frequencies
	
	gasend	=	gasend * gkvolume

		outs	gasend,gasend
		clear	gasend
endin


instr	201
	Sname	=	p4
	chnset	giOff,Sname
endin


</CsInstruments>  
<CsScore>
i 1 0 [3600*24*7]	; read widgets
i 200 0 [3600*24*7]	; output
</CsScore>
</CsoundSynthesizer>; TR-808.csd
; Written by Iain McCurdy, 2012
; 
; Saving patterns saves tables as text file to the pwd. Each save to a new pattern number creates a new text file on disk for that pattern.

; Choosing 'Host Control' allows the VST plugin host to decide 'Tempo' and 'Run/Stop' status

<Cabbage>
form caption("TR-808") size(800, 400), colour("SlateGrey"), pluginid("T808"), guirefresh(32) style("legacy")

label 		bounds(  5,385,120, 12), text("Iain McCurdy |2012|"), fontcolour("black")

groupbox bounds( 0,  0,  50, 225), text("B.Drum"),fontcolour("black"), colour(192,192,192), plant(1) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act1"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"), textcolour("black"), colour(80,100,150), channel("level1"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),  textcolour("black"), colour(80,100,150), channel("tune1"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"), textcolour("black"), colour(80,100,150), channel("dur1"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),   textcolour("black"), colour(80,100,150), channel("pan1"),   range(0, 1, 0.5,1,0.01)
}
groupbox bounds(50,  0,  50, 225), text("Snare"), fontcolour("black"),colour(202,202,202), plant(2) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act2"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"), textcolour("black"), colour(80,100,150), channel("level2"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),  textcolour("black"), colour(80,100,150), channel("tune2"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"), textcolour("black"), colour(80,100,150), channel("dur2"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),   textcolour("black"), colour(80,100,150), channel("pan2"),   range(0, 1, 0.5,1,0.01)
}
groupbox bounds(100,  0,  50, 225), text("O. HH"), fontcolour("black"), colour(212,212,212), plant(3) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act3"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level3"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune3"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur3"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan3"),  range(0, 1, 0.5,1,0.01)
}                                
groupbox bounds(150,  0,  50, 225), text("Cl. HH"),fontcolour("black"),colour(222,222,222), plant(4) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act4"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level4"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune4"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur4"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan4"),  range(0, 1, 0.5,1,0.01)
}
groupbox bounds(200,  0,  50, 225), text("H. Tom"), fontcolour("black"),colour(232,232,232), plant(5) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act5"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level5"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune5"), range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur5"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan5"),  range(0, 1, 0.5,1,0.01)
}
groupbox bounds(250,  0,  50, 225), text("M. Tom"),fontcolour("black"), colour(242,242,242), plant(6) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act6"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level6"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune6"), range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur6"), range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan6"),  range(0, 1, 0.5,1,0.01)
}
groupbox bounds(300,  0,  50, 225), text("L. Tom"),fontcolour("black"), colour(232,232,232), plant(7) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act7"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level7"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune7"), range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur7"), range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan7"),  range(0, 1, 0.5,1,0.01)
}
groupbox bounds(350,  0,  50, 225), text("Cymbal"), fontcolour("black"),colour(222,222,222), plant(8) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act8"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level8"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune8"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur8"),  range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan8"),  range(0, 1, 0.5,1,0.01)
}
groupbox bounds(400,  0,  50, 225), text("Rim Shot"),fontcolour("black"), colour(212,212,212), plant(9) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act9"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),   textcolour("black"), colour(80,100,150), channel("level9"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),    textcolour("black"), colour(80,100,150), channel("tune9"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),   textcolour("black"), colour(80,100,150), channel("dur9"),  range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),     textcolour("black"), colour(80,100,150), channel("pan9"),  range(0, 1, 0.5,1,0.01)
}
groupbox bounds(450,  0,  50, 225), text("Claves"), fontcolour("black"),colour(202,202,202), plant(10) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act10"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level10"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune10"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur10"),  range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan10"), range(0, 1, 0.5,1,0.01)
}
groupbox bounds(500,  0,  50, 225), text("Cowbell"),fontcolour("black"), colour(192,192,192), plant(11) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act11"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level11"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune11"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur11"),  range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan11"), range(0, 1, 0.5,1,0.01)
}
groupbox bounds(550,  0,  50, 225), text("Clap"), fontcolour("black"),colour(182,182,182), plant(12) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act12"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"), textcolour("black"), colour(80,100,150), channel("level12"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),  textcolour("black"), colour(80,100,150), channel("tune12"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"), textcolour("black"), colour(80,100,150), channel("dur12"),  range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),   textcolour("black"), colour(80,100,150), channel("pan12"), range(0, 1, 0.5,1,0.01)
}
groupbox bounds(600,  0,  50, 225), text("Maraca"),fontcolour("black"), colour(172,172,172), plant(13) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act13"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"), textcolour("black"), colour(80,100,150), channel("level13"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),  textcolour("black"), colour(80,100,150), channel("tune13"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"), textcolour("black"), colour(80,100,150), channel("dur13"),  range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),   textcolour("black"), colour(80,100,150), channel("pan13"), range(0, 1, 0.5,1,0.01)
}
groupbox bounds(650,  0,  50, 225), text("Hi Conga"),fontcolour("black"), colour(162,162,162), plant(14) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act14"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),   textcolour("black"), colour(80,100,150), channel("level14"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),    textcolour("black"), colour(80,100,150), channel("tune14"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),   textcolour("black"), colour(80,100,150), channel("dur14"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),     textcolour("black"), colour(80,100,150), channel("pan14"), range(0, 1, 0.5,0.01)
}
groupbox bounds(700,  0,  50, 225), text("Md Cnga"),fontcolour("black"), colour(152,152,152), plant(15) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act15"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level15"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune15"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur15"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan15"), range(0, 1, 0.5,1,0.01)
}
groupbox bounds(750,  0,  50, 225), text("Lo Cnga"),fontcolour("black"), colour(142,142,142), plant(16) {
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act16"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level16"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune16"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur16"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan16"), range(0, 1, 0.5,1,0.01)
}

keyboard bounds(0, 225, 800, 80)
button   bounds( 10,315, 40, 25), fontcolour:0(50,50,50), fontcolour:1(205,255,205), colour:0(0,10,0), colour:1(0,150,0), text("Play","Play"), channel("Play"), latched(1), radiogroup(1), identchannel("PlayButton")
button   bounds( 50,315, 40, 25), fontcolour:0(50,50,50), fontcolour:1(255,205,205), colour:0(10,0,0), colour:1(150,0,0), text("Stop","Stop"), channel("Stop"), latched(1), radiogroup(1), value(1), identchannel("StopButton")


combobox bounds( 10,345, 80, 15), channel("sound"), value(1), text("Bass Drum","Snare","Open HH","Cl. HH","Hi Tom","Mid Tom","Lo Tom","Cymbal","Rimshot","Claves","Cowbell","Clap","Maraca","Hi Conga","Mid Conga","Lo Conga")
button   bounds(462,315, 80, 20), text("Clear","Clear"), channel("clear"), value(0)
button   bounds(462,338, 38, 20), text("Save","Save"), channel("save"), value(0)
button   bounds(502,338, 38, 20), text("Load","Load"), channel("load"), value(0)
label    bounds(542,328, 48, 10), text("PATTERN"), fontcolour("black")
combobox bounds(544,338, 45, 20), channel("pattern"), value(1), text("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16")
rslider  bounds(593,310, 60, 60), text("Accent"),  textcolour("black"), colour(80,100,150), channel("AccLev"), range(0, 1.00, 0.4)
rslider  bounds(643,310, 60, 60), text("Tempo"),   textcolour("black"), colour(80,100,150), channel("tempo"), range(10, 500, 70, 1, 1)
rslider  bounds(693,310, 60, 60), text("Swing"),   textcolour("black"), colour(80,100,150), channel("swing"), range(0, 0.50, 0)
rslider  bounds(743,310, 60, 60), text("Level"),   textcolour("black"), colour(80,100,150), channel("level"), range(0, 2.00, 1)

label    bounds(143,312,  6, 10), text("1"), fontcolour("black")
label    bounds(163,312,  6, 10), text("2"), fontcolour("black")
label    bounds(183,312,  6, 10), text("3"), fontcolour("black")
label    bounds(203,312,  6, 10), text("4"), fontcolour("black")
label    bounds(223,312,  6, 10), text("5"), fontcolour("black")
label    bounds(243,312,  6, 10), text("6"), fontcolour("black")
label    bounds(263,312,  6, 10), text("7"), fontcolour("black")
label    bounds(283,312,  6, 10), text("8"), fontcolour("black")
label    bounds(303,312,  6, 10), text("9"), fontcolour("black")
label    bounds(320,312, 12, 10), text("10"), fontcolour("black")
label    bounds(340,312, 12, 10), text("11"), fontcolour("black")
label    bounds(360,312, 12, 10), text("12"), fontcolour("black")
label    bounds(380,312, 12, 10), text("13"), fontcolour("black")
label    bounds(400,312, 12, 10), text("14"), fontcolour("black")
label    bounds(420,312, 12, 10), text("15"), fontcolour("black")
label    bounds(440,312, 12, 10), text("16"), fontcolour("black")

label    bounds(120, 325, 17, 12), text("On"), fontcolour("black")
checkbox bounds(140, 325, 12, 12), channel("On1"),  value(1)
checkbox bounds(160, 325, 12, 12), channel("On2"),  value(0)
checkbox bounds(180, 325, 12, 12), channel("On3"),  value(0)
checkbox bounds(200, 325, 12, 12), channel("On4"),  value(1)
checkbox bounds(220, 325, 12, 12), channel("On5"),  value(1)
checkbox bounds(240, 325, 12, 12), channel("On6"),  value(0)
checkbox bounds(260, 325, 12, 12), channel("On7"),  value(0)
checkbox bounds(280, 325, 12, 12), channel("On8"),  value(0)
checkbox bounds(300, 325, 12, 12), channel("On9"),  value(1)
checkbox bounds(320, 325, 12, 12), channel("On10"), value(0)
checkbox bounds(340, 325, 12, 12), channel("On11"), value(0)
checkbox bounds(360, 325, 12, 12), channel("On12"), value(1)
checkbox bounds(380, 325, 12, 12), channel("On13"), value(0)
checkbox bounds(400, 325, 12, 12), channel("On14"), value(1)
checkbox bounds(420, 325, 12, 12), channel("On15"), value(0)
checkbox bounds(440, 325, 12, 12), channel("On16"), value(0)

label    bounds( 98, 345, 38, 12), text("Accent"), fontcolour("black")
checkbox bounds(140, 345, 12, 12), channel("Acc1"),  value(1), colour("yellow")
checkbox bounds(160, 345, 12, 12), channel("Acc2"),  value(0), colour("yellow")
checkbox bounds(180, 345, 12, 12), channel("Acc3"),  value(0), colour("yellow")
checkbox bounds(200, 345, 12, 12), channel("Acc4"),  value(0), colour("yellow")
checkbox bounds(220, 345, 12, 12), channel("Acc5"),  value(0), colour("yellow")
checkbox bounds(240, 345, 12, 12), channel("Acc6"),  value(0), colour("yellow")
checkbox bounds(260, 345, 12, 12), channel("Acc7"),  value(0), colour("yellow")
checkbox bounds(280, 345, 12, 12), channel("Acc8"),  value(0), colour("yellow")
checkbox bounds(300, 345, 12, 12), channel("Acc9"),  value(0), colour("yellow")
checkbox bounds(320, 345, 12, 12), channel("Acc10"), value(0), colour("yellow")
checkbox bounds(340, 345, 12, 12), channel("Acc11"), value(0), colour("yellow")
checkbox bounds(360, 345, 12, 12), channel("Acc12"), value(0), colour("yellow")
checkbox bounds(380, 345, 12, 12), channel("Acc13"), value(0), colour("yellow")
checkbox bounds(400, 345, 12, 12), channel("Acc14"), value(0), colour("yellow")
checkbox bounds(420, 345, 12, 12), channel("Acc15"), value(0), colour("yellow")
checkbox bounds(440, 345, 12, 12), channel("Acc16"), value(0), colour("yellow")

button   bounds(458,362, 90, 18), text("Local Control","Host Control"), channel("control"), value(0)

</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=null -M0 -dm0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1
massign	0,2

;Author: Iain McCurdy (2012)

gisine		ftgen	0,0,1024,10,1		;A SINE WAVE
gicos		ftgen	0,0,65536,9,1,1,90	;A COSINE WAVE
gkoff	init	0
;				1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16
giOn1	ftgen	0,0,16,2,	1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0	;BD
giOn2	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0	;SN
giOn3	ftgen	0,0,16,2,	0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0  ;HHO
giOn4	ftgen	0,0,16,2,	1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1  ;HHCl
giOn5	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Hi Tom
giOn6	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Mid Tom
giOn7	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0  ;Lo Tom
giOn8	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0  ;Cym
giOn9	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Rimshot
giOn10	ftgen	0,0,16,2,	1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0  ;Claves
giOn11	ftgen	0,0,16,2,	1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1  ;Cowbell
giOn12	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0  ;Clap
giOn13	ftgen	0,0,16,2,	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0  ;Maraca
giOn14	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0  ;Hi Conga
giOn15	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0  ;Mid Conga
giOn16	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1  ;Lo Conga
giAcc1	ftgen	0,0,16,2,	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	;BD
giAcc2	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	;SN
giAcc3	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;HHO
giAcc4	ftgen	0,0,16,2,	1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0  ;HHCl
giAcc5	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Hi Tom
giAcc6	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Mid Tom
giAcc7	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0  ;Lo Tom
giAcc8	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0  ;Cym
giAcc9	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Rimshot
giAcc10	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Claves
giAcc11	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Cowbell
giAcc12	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Clap
giAcc13	ftgen	0,0,16,2,	1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0  ;Maraca
giAcc14	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0  ;Hi Conga
giAcc15	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0  ;Mid Conga
giAcc16	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0  ;Lo Conga
giblank	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;blank

instr	1	;READ IN WIDGETS, SCAN MIDI NOTES PLAYED AND RELAY TO DRUM SOUNDS 
	gkPlay		chnget	"Play"
	gkStop		chnget	"Stop"
	if trigger(gkPlay,0.5,0)==1 then
	 gkOnOff	=	1
	elseif trigger(gkStop,0.5,0)==1 then
	 gkOnOff	=	0
	endif

	;READ IN WIDGETS
	gklevel1	chnget	"level1"
	gklevel2	chnget	"level2"
	gklevel3	chnget	"level3"
	gklevel4	chnget	"level4"
	gklevel5	chnget	"level5"
	gklevel6	chnget	"level6"
	gklevel7	chnget	"level7"
	gklevel8	chnget	"level8"
	gklevel9	chnget	"level9"
	gklevel10	chnget	"level10"	
	gklevel11	chnget	"level11"	
	gklevel12	chnget	"level12"	
	gklevel13	chnget	"level13"	
	gklevel14	chnget	"level14"	
	gklevel15	chnget	"level15"	
	gklevel16	chnget	"level16"	
	gktune1		chnget	"tune1"	
	gktune2		chnget	"tune2"	
	gktune3		chnget	"tune3"	
	gktune4		chnget	"tune4"	
	gktune5		chnget	"tune5"	
	gktune6		chnget	"tune6"	
	gktune7		chnget	"tune7"	
	gktune8		chnget	"tune8"	
	gktune9		chnget	"tune9"	
	gktune10	chnget	"tune10"	
	gktune11	chnget	"tune11"	
	gktune12	chnget	"tune12"	
	gktune13	chnget	"tune13"	
	gktune14	chnget	"tune14"	
	gktune15	chnget	"tune15"	
	gktune16	chnget	"tune16"
	gkdur1	chnget	"dur1"
	gkdur2	chnget	"dur2"
	gkdur3	chnget	"dur3"
	gkdur4	chnget	"dur4"
	gkdur5	chnget	"dur5"
	gkdur6	chnget	"dur6"
	gkdur7	chnget	"dur7"
	gkdur8	chnget	"dur8"
	gkdur9	chnget	"dur9"
	gkdur10	chnget	"dur10"	
	gkdur11	chnget	"dur11"	
	gkdur12	chnget	"dur12"	
	gkdur13	chnget	"dur13"	
	gkdur14	chnget	"dur14"	
	gkdur15	chnget	"dur15"	
	gkdur16	chnget	"dur16"	
	gkpan1		chnget	"pan1"	
	gkpan2		chnget	"pan2"	
	gkpan3		chnget	"pan3"	
	gkpan4		chnget	"pan4"	
	gkpan5		chnget	"pan5"	
	gkpan6		chnget	"pan6"	
	gkpan7		chnget	"pan7"	
	gkpan8		chnget	"pan8"	
	gkpan9		chnget	"pan9"	
	gkpan10		chnget	"pan10"	
	gkpan11		chnget	"pan11"	
	gkpan12		chnget	"pan12"	
	gkpan13		chnget	"pan13"	
	gkpan14		chnget	"pan14"	
	gkpan15		chnget	"pan15"	
	gkpan16		chnget	"pan16"
	gksound		chnget	"sound"
	gkOn1		chnget	"On1"
	gkOn2		chnget	"On2"
	gkOn3		chnget	"On3"
	gkOn4		chnget	"On4"
	gkOn5		chnget	"On5"
	gkOn6		chnget	"On6"
	gkOn7		chnget	"On7"
	gkOn8		chnget	"On8"
	gkOn9		chnget	"On9"
	gkOn10		chnget	"On10"
	gkOn11		chnget	"On11"
	gkOn12		chnget	"On12"
	gkOn13		chnget	"On13"
	gkOn14		chnget	"On14"
	gkOn15		chnget	"On15"
	gkOn16		chnget	"On16"
	gkAcc1		chnget	"Acc1"
	gkAcc2		chnget	"Acc2"
	gkAcc3		chnget	"Acc3"
	gkAcc4		chnget	"Acc4"
	gkAcc5		chnget	"Acc5"
	gkAcc6		chnget	"Acc6"
	gkAcc7		chnget	"Acc7"
	gkAcc8		chnget	"Acc8"
	gkAcc9		chnget	"Acc9"
	gkAcc10		chnget	"Acc10"
	gkAcc11		chnget	"Acc11"
	gkAcc12		chnget	"Acc12"
	gkAcc13		chnget	"Acc13"
	gkAcc14		chnget	"Acc14"
	gkAcc15		chnget	"Acc15"
	gkAcc16		chnget	"Acc16"
	gkclear		chnget	"clear"
	gksave		chnget	"save"
	gkload		chnget	"load"
	gkpattern	chnget	"pattern"
	gkAccLev	chnget	"AccLev"
	gktempo		chnget	"tempo"
	gkswing		chnget	"swing"
	gklevel		chnget	"level"

	kcontrol	chnget	"control"
	if kcontrol==1 then			; host control over start stop and tempo
	 gktempo	chnget	"HOST_BPM"
	 gkOnOff	chnget	"IS_PLAYING"
	 if changed(gktempo)==1 then
	  chnset	gktempo, "tempo"
	 endif
	 if changed(gkOnOff)==1 then
	  chnset	gkOnOff, "OnOff"
	 endif
	endif
	
	;START/STOP SEQUENCER
	ktrig	changed	gkOnOff		;if Run/Stop button is changed...
	if ktrig==1 then		;
	 if gkOnOff==1 then		;...if Run/Stop has been changed to 'Run'...
	  event	"i",3,0,-1		;...start instr 3 playing a held note
	 else				;otherwise...
	  event	"i",-3,0,0		;...stop instr 3 playing
	 endif
	endif
	
	;CLEAR SEQUENCES FOR ALL DRUM SOUNDS
	ktrig changed	gkclear		
	if ktrig==1 then
	 tablecopy	giOn1,	giblank	 ;copy blank table over existing sequence for voice 1
	 tablecopy	giOn2,	giblank	 ;repeat for every other voice
	 tablecopy	giOn3,	giblank	 
	 tablecopy	giOn4,	giblank	 
	 tablecopy	giOn5,	giblank	 
	 tablecopy	giOn6,	giblank	 
	 tablecopy	giOn7,	giblank	 
	 tablecopy	giOn8,	giblank	 
	 tablecopy	giOn9,	giblank	 
	 tablecopy	giOn10,	giblank	 
	 tablecopy	giOn11,	giblank	 
	 tablecopy	giOn12,	giblank	 
	 tablecopy	giOn13,	giblank	 
	 tablecopy	giOn14,	giblank	 
	 tablecopy	giOn15,	giblank	 
	 tablecopy	giOn16,	giblank	 
	 tablecopy	giAcc1,		giblank	 
	 tablecopy	giAcc2,		giblank	 
	 tablecopy	giAcc3,		giblank	 
	 tablecopy	giAcc4,		giblank	 
	 tablecopy	giAcc5,		giblank	 
	 tablecopy	giAcc6,		giblank	 
	 tablecopy	giAcc7,		giblank	 
	 tablecopy	giAcc8,		giblank	 
	 tablecopy	giAcc9,		giblank	 
	 tablecopy	giAcc10,	giblank	 
	 tablecopy	giAcc11,	giblank	 
	 tablecopy	giAcc12,	giblank	 
	 tablecopy	giAcc13,	giblank	 
	 tablecopy	giAcc14,	giblank	 
	 tablecopy	giAcc15,	giblank	 
	 tablecopy	giAcc16,	giblank	 
	endif
	
	;STORE SEQUENCE TABLES
	ktrig changed	gksave	;if save button is toggled...
	igoto	SKIP
	if ktrig==1 then
	 reinit	SAVE_TABLES	;begin a reinitialisation pass from label (ftsave operates only at i-time)
	endif
	SAVE_TABLES:
	SFileName sprintf "TR-808_pattern.%d.txt", i(gkpattern)	;create the file name (string variable) that will be used to name the text file that will contain the pattern data
	ftsave SFileName, 1, giOn1, giOn2, giOn3, giOn4, giOn5, giOn6, giOn7, giOn8, giOn9, giOn10, giOn11, giOn12, giOn13, giOn14, giOn15, giOn16, giAcc1, giAcc2, giAcc3, giAcc4, giAcc5, giAcc6, giAcc7, giAcc8, giAcc9, giAcc10, giAcc11, giAcc12, giAcc13, giAcc14, giAcc15, giAcc16	;save all tables (on information and accents) to a text file in the pwd
	rireturn	
	SKIP:
	
	;LOAD SEQUENCE TABLES
	ktrig changed	gkload	;if load button is toggled...
	igoto	SKIP2
	if ktrig==1 then
	 reinit	LOAD_TABLES	;begin a reinitialisation pass from label (ftload operates only at i-time)
	endif
	LOAD_TABLES:
	SFileName sprintf "TR-808_pattern.%d.txt", i(gkpattern)	;create the file name (string variable) that will be the name of the file from which data will be retrieved
	ftload SFileName, 1, giOn1, giOn2, giOn3, giOn4, giOn5, giOn6, giOn7, giOn8, giOn9, giOn10, giOn11, giOn12, giOn13, giOn14, giOn15, giOn16, giAcc1, giAcc2, giAcc3, giAcc4, giAcc5, giAcc6, giAcc7, giAcc8, giAcc9, giAcc10, giAcc11, giAcc12, giAcc13, giAcc14, giAcc15, giAcc16	;load all tables (on information and accents) to a text file in the pwd
	rireturn	
	SKIP2:
	
	;UPDATE SEQUENCE DISPLAY
	ktrig	changed	gksound,gkclear,gkload
	if ktrig==1 then
#define	UPDATE_SEQUENCE(N)
	 #
	 kval	tablekt	$N-1,giOn1+gksound-1
	 chnset	kval,"On$N"
	 kval	tablekt	$N-1,giAcc1+gksound-1
	 chnset	kval,"Acc$N"
	 #
	 $UPDATE_SEQUENCE(1)
	 $UPDATE_SEQUENCE(2)
	 $UPDATE_SEQUENCE(3)
	 $UPDATE_SEQUENCE(4)
	 $UPDATE_SEQUENCE(5)
	 $UPDATE_SEQUENCE(6)
	 $UPDATE_SEQUENCE(7)
	 $UPDATE_SEQUENCE(8)
	 $UPDATE_SEQUENCE(9)
	 $UPDATE_SEQUENCE(10)
	 $UPDATE_SEQUENCE(11)
	 $UPDATE_SEQUENCE(12)
	 $UPDATE_SEQUENCE(13)
	 $UPDATE_SEQUENCE(14)
	 $UPDATE_SEQUENCE(15)
	 $UPDATE_SEQUENCE(16)
	endif
	
	;UPDATE TABLE IF SEQUENCE BUTTON CHANGED
#define	UPDATE_TABLE(N)
	#
	ktrig	changed	gkOn$N
	if ktrig==1 then
	 tablewkt	gkOn$N,$N-1,giOn1+gksound-1
	endif
	ktrig	changed	gkAcc$N
	if ktrig==1 then
	 tablewkt	gkAcc$N,$N-1,giAcc1+gksound-1
	endif
	#
	$UPDATE_TABLE(1)
	$UPDATE_TABLE(2)
	$UPDATE_TABLE(3)
	$UPDATE_TABLE(4)
	$UPDATE_TABLE(5)
	$UPDATE_TABLE(6)
	$UPDATE_TABLE(7)
	$UPDATE_TABLE(8)
	$UPDATE_TABLE(9)
	$UPDATE_TABLE(10)
	$UPDATE_TABLE(11)
	$UPDATE_TABLE(12)
	$UPDATE_TABLE(13)
	$UPDATE_TABLE(14)
	$UPDATE_TABLE(15)
	$UPDATE_TABLE(16)
endin

instr	2	;READ MIDI AND TRIGGER NOTES
	inum	notnum					;READ IN MIDI NOTE NUMBER
	idb	veloc	-30,0				;READ IN MIDI NOTE VELOCITY (WILL BE USED AS A DECIBEL VALUE)
	iinstr	wrap	inum,0,16			;MAP MIDI NOTE NUMBERS (RANGE: 0 - 127) TO DRUM SOUND NUMBER (0 - 15)
	event_i	"i",101+iinstr,0,0.001,ampdbfs(idb)	;CALL THE RELEVANT INSTRUMENT AND SEND AMPLITUDE VALUE AS p4
endin

instr	3	;PLAY SEQUENCE	
	gindx	init	0
	ktick	metro		(gktempo*4)/60
	
	;SWING
	kSwingBeat init	0
	kSwingTime	=	(kSwingBeat==1?(60*gkswing)/(gktempo*4):0)
	if ktick==1 then
	 kSwingBeat	=	abs(kSwingBeat-1)	;FLIP BETWEEN ZERO AND 1
	endif
	
		schedkwhen	ktick, 0, 0, 4, kSwingTime, 0.001
endin

instr	4	;TEST FOR NOTE ON SEQUENCE STEP
#define	VOICE(N)	
	#
	iOnOff$N	table		gindx, giOn$N
	if iOnOff$N==1 then
	 iAcc	table	gindx,giAcc$N
	 event_i	"i", 100+$N, 0, 0.001, 0.4 + (iAcc*i(gkAccLev))
	endif
	#
$VOICE(1)
$VOICE(2)
$VOICE(3)
$VOICE(4)
$VOICE(5)
$VOICE(6)
$VOICE(7)
$VOICE(8)
$VOICE(9)
$VOICE(10)
$VOICE(11)
$VOICE(12)
$VOICE(13)
$VOICE(14)
$VOICE(15)
$VOICE(16)
	gindx		wrap	gindx+1, 0, 16
			turnoff
endin

instr	101	;BASS DRUM
	xtratim	0.1
	krelease	release		;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)
	chnset	1-krelease,"Act1"	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS

	p3	=	2*i(gkdur1)							;NOTE DURATION. SCALED USING GUI 'Decay' KNOB

	;SUSTAIN AND BODY OF THE SOUND
	kmul	transeg	0.2,p3*0.5,-15,0.01, p3*0.5,0,0					;PARTIAL STRENGTHS MULTIPLIER USED BY GBUZZ. DECAYS FROM A SOUND WITH OVERTONES TO A SINE TONE.
	kbend	transeg	0.5,1.2,-4, 0,1,0,0						;SLIGHT PITCH BEND AT THE START OF THE NOTE 
	asig	gbuzz	0.5,50*octave(gktune1)*semitone(kbend),20,1,kmul,gicos		;GBUZZ TONE
	aenv	transeg	1,p3-0.004,-6,0							;AMPLITUDE ENVELOPE FOR SUSTAIN OF THE SOUND
	aatt	linseg	0,0.004,1							;SOFT ATTACK
	asig	=	asig*aenv*aatt

	;HARD, SHORT ATTACK OF THE SOUND
	aenv	linseg	1,0.07,0							;AMPLITUDE ENVELOPE (FAST DECAY)						
	acps	expsega	400,0.07,0.001,1,0.001						;FREQUENCY OF THE ATTACK SOUND. QUICKLY GLISSES FROM 400 Hz TO SUB-AUDIO
	aimp	oscili	aenv,acps*octave(gktune1*0.25),gisine				;CREATE ATTACK SOUND
	
	amix	=	((asig*0.5)+(aimp*0.35))*gklevel1*p4*gklevel			;MIX SUSTAIN AND ATTACK SOUND ELEMENTS AND SCALE USING GUI 'Level' KNOB
	
	aL,aR	pan2	amix,gkpan1							;PAN THE MONOPHONIC SOUND
		outs	aL,aR								;SEND AUDIO TO OUTPUTS
endin

instr	102	;SNARE DRUM
	xtratim	0.1
	krelease	release		;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act2"       ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	
	;SOUND CONSISTS OF TWO SINE TONES, AN OCTAVE APART AND A NOISE SIGNAL
	ifrq  	=	342		;FREQUENCY OF THE TONES
	iNseDur	=	0.3 * i(gkdur2)	;DURATION OF THE NOISE COMPONENT
	iPchDur	=	0.1 * i(gkdur2)	;DURATION OF THE SINE TONES COMPONENT
	p3	=	iNseDur 	;p3 DURATION TAKEN FROM NOISE COMPONENT DURATION (ALWATS THE LONGEST COMPONENT)
	
	;SINE TONES COMPONENT
	aenv1	expseg	1,iPchDur,0.0001,p3-iPchDur,0.0001		;AMPLITUDE ENVELOPE
	apitch1	oscili	1,ifrq*octave(gktune2),gisine			;SINE TONE 1
	apitch2	oscili	0.25,ifrq*0.5*octave(gktune2),gisine		;SINE TONE 2 (AN OCTAVE LOWER)
	apitch	=	(apitch1+apitch2)*0.75				;MIX THE TWO SINE TONES

	;NOISE COMPONENT
	aenv2	expon	1,p3,0.0005					;AMPLITUDE ENVELOPE
	anoise	noise	0.75,0						;CREATE SOME NOISE
	anoise	butbp	anoise,10000*octave(gktune2),10000		;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,1000					;HIGHPASS FILTER THE NOISE SIGNAL
	kcf	expseg	5000,0.1,3000,p3-0.2,3000			;CUTOFF FREQUENCY FOR A LOWPASS FILTER
	anoise	butlp	anoise,kcf					;LOWPASS FILTER THE NOISE SIGNAL
	amix	=	((apitch*aenv1)+(anoise*aenv2))*gklevel2*p4*gklevel	;MIX AUDIO SIGNALS AND SCALE ACCORDING TO GUI 'Level' CONTROL
	aL,aR	pan2	amix,i(gkpan2)					;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR						;SEND AUDIO TO OUTPUTS
endin

instr	103	;OPEN HIGH HAT
	xtratim	0.1
	kFrq1	=	296*octave(gktune3) 	;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285*octave(gktune3) 	
	kFrq3	=	365*octave(gktune3) 	
	kFrq4	=	348*octave(gktune3) 	
	kFrq5	=	420*octave(gktune3) 	
	kFrq6	=	835*octave(gktune3) 	
	p3	=	0.5*i(gkdur3)		;DURATION OF THE NOTE
	
	;SOUND CONSISTS OF 6 PULSE OSCILLATORS MIXED WITH A NOISE COMPONENT
	;PITCHED ELEMENT
	aenv	linseg	1,p3-0.05,0.1,0.05,0		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS
	ipw	=	0.25				;PULSE WIDTH
	a1	vco2	0.5,kFrq1,2,ipw			;PULSE OSCILLATORS...
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000*octave(gktune3),5000,1	;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,5000			;HIGHPASS FILTER THE SOUND...
	amix	buthp	amix,5000			;...AND AGAIN
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	linseg	1,p3-0.05,0.1,0.05,0		;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	20000,0.7,9000,p3-0.1,9000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*gklevel3*p4*0.55*gklevel
	aL,aR	pan2	amix,gkpan3			;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
	;kactive	active	p1+1				;CHECK NUMBER OF ACTIVE INSTANCES OF CLOSED HIGH HAT INSTRUMENT
	;if kactive>0 then			;IF HIGH-HAT CLOSED IS ACTIVE...
	; turnoff				;TURN OFF THIS INSTRUMENT
	;endif
	krelease	release			;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act3"       	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
endin

instr	104	;CLOSED HIGH HAT
	xtratim	0.1
	krelease	release			;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act4"       	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kFrq1	=	296*octave(gktune4) 	;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285*octave(gktune4) 	
	kFrq3	=	365*octave(gktune4) 	
	kFrq4	=	348*octave(gktune4) 	
	kFrq5	=	420*octave(gktune4) 	
	kFrq6	=	835*octave(gktune4) 	
	idur	=	0.088*i(gkdur4)		;DURATION OF THE NOTE
	p3	limit	idur,0.1,10		;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)

	iactive	active	p1-1			;SENSE ACTIVITY OF PREVIOUS INSTRUMENT (OPEN HIGH HAT) 
	if iactive>0 then			;IF 'OPEN HIGH HAT' IS ACTIVE...
	 turnoff2	p1-1,0,0		;TURN IT OFF (CLOSED HIGH HAT TAKES PRESIDENCE)
	 chnset	gkoff,"Act3"       	;TURN OFF ACTIVE LIGHT FOR OPEN HIGH HAT
	endif

	;PITCHED ELEMENT
	aenv	expsega	1,idur,0.001,1,0.001		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS
	ipw	=	0.25				;PULSE WIDTH
	a1	vco2	0.5,kFrq1,2,ipw			;PULSE OSCILLATORS...			
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000*octave(gktune4),5000,1	;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,5000			;HIGHPASS FILTER THE SOUND...
	amix	buthp	amix,5000			;...AND AGAIN
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	expsega	1,idur,0.001,1,0.001		;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	20000,0.7,9000,idur-0.1,9000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*gklevel4*p4*0.55*gklevel
	aL,aR	pan2	amix,gkpan4			;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
endin

instr	105	;HIGH TOM
	xtratim	0.1
	krelease	release					;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act5"       			;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq     	=	200 * octave(i(gktune5))	;FREQUENCY
	p3	  	=	0.5 * i(gkdur5)			;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise,400*octave(i(gktune5)),800,1	;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100*octave(i(gktune5))		;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,1000*octave(i(gktune5))		;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*gklevel5*p4*gklevel
	aL,aR	pan2	amix,gkpan5				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	106	;MID TOM
	xtratim	0.1
	krelease	release					;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act6"               		;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq     	=	133*octave(i(gktune6)) 		;FREQUENCY
	p3	  	=	0.6 * i(gkdur6)			;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise, 400*octave(i(gktune6)),800,1	;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100*octave(i(gktune6))		;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,600*octave(i(gktune6))		;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*gklevel6*p4*gklevel
	aL,aR	pan2	amix,i(gkpan6)				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	107	;LOW TOM
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act7"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq     	=	90 * octave(i(gktune7))	;FREQUENCY
	p3 	 	=	0.7*i(gkdur7) 		;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise,40*octave(gktune7),800,1		;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100*octave(i(gktune7))		;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,600*octave(i(gktune7))		;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*gklevel7*p4*gklevel
	aL,aR	pan2	amix,i(gkpan7)				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	108	;CYMBAL
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act8"                       ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kFrq1	=	296*octave(gktune8) 	;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285*octave(gktune8)
	kFrq3	=	365*octave(gktune8)
	kFrq4	=	348*octave(gktune8)     
	kFrq5	=	420*octave(gktune8)
	kFrq6	=	835*octave(gktune8)
	p3	=	2*i(gkdur8)		;DURATION OF THE NOTE

	;SOUND CONSISTS OF 6 PULSE OSCILLATORS MIXED WITH A NOISE COMPONENT
	;PITCHED ELEMENT
	aenv	expon	1,p3,0.0001		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS 
	ipw	=	0.25			;PULSE WIDTH      
	a1	vco2	0.5,kFrq1,2,ipw		;PULSE OSCILLATORS...  
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw                                                                   
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000 *octave(gktune8),5000,1	;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,10000			;HIGHPASS FILTER THE SOUND
	amix	butlp	amix,12000			;LOWPASS FILTER THE SOUND...
	amix	butlp	amix,12000			;AND AGAIN...
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	expsega	1,0.3,0.07,p3-0.1,0.00001	;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	14000,0.7,7000,p3-0.1,5000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE            

	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*gklevel8*p4*0.85*gklevel
	aL,aR	pan2	amix,i(gkpan8)			;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
endin

instr	109	;RIM SHOT
	xtratim	0.1
	iTR808RimShot	ftgenonce	0,0,1024,10,	0.971,0.269,0.041,0.054,0.011,0.013,0.08,0.0065,0.005,0.004,0.003,0.003,0.002,0.002,0.002,0.002,0.002,0.001,0.001,0.001,0.001,0.001,0.002,0.001,0.001	;WAVEFORM FOR TR808 RIMSHOT
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act9"                       ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	idur 	=	0.027*i(gkdur9) 		;NOTE DURATION
	p3	limit	idur,0.1,10			;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)

	;RING
	aenv1	expsega	1,idur,0.001,1,0.001		;AMPLITUDE ENVELOPE FOR SUSTAIN ELEMENT OF SOUND
	ifrq1	=	1700*octave(i(gktune9))		;FREQUENCY OF SUSTAIN ELEMENT OF SOUND
	aring	oscili	1,ifrq1,iTR808RimShot,0		;CREATE SUSTAIN ELEMENT OF SOUND	
	aring	butbp	aring,ifrq1,ifrq1*8	
	aring	=	aring*(aenv1-0.001)*0.5			;APPLY AMPLITUDE ENVELOPE

	;NOISE
	anoise	noise	1,0					;CREATE A NOISE SIGNAL
	aenv2	expsega	1, 0.002, 0.8, 0.005, 0.5, idur-0.002-0.005, 0.0001, 1, 0.0001	;CREATE AMPLITUDE ENVELOPE
	anoise	buthp	anoise,800			;HIGHPASS FILTER THE NOISE SOUND
	kcf	expseg	4000,p3,20				;CUTOFF FREQUENCY FUNCTION FOR LOWPASS FILTER
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE SOUND
	anoise	=	anoise*(aenv2-0.001)	;APPLY ENVELOPE TO NOISE SIGNAL

	;MIX
	amix	=	(aring+anoise)*gklevel9*p4*0.8*gklevel
	aL,aR	pan2	amix,gkpan9			;PAN MONOPHONIC SIGNAL  
		outs	aL,aR				;SEND TO OUTPUTS
endin

instr	110	;CLAVES
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act10"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq	=	2500*octave(i(gktune10))	;FREQUENCY OF OSCILLATOR
	idur	=	0.045 	* i(gkdur10)		;DURATION OF THE NOTE
	p3	limit	idur,0.1,10			;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)			
	aenv	expsega	1,idur,0.001,1,0.001		;AMPLITUDE ENVELOPE
	afmod	expsega	3,0.00005,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE SOUND A LITTLE MORE ATTACK.
	asig	oscili	-(aenv-0.001),ifrq*afmod,gisine,0	;AUDIO OSCILLATOR
	asig	=	asig*0.4*gklevel10*p4*gklevel		;RESCALE AMPLITUDE
	aL,aR	pan2	asig,gkpan10			;PAN MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO OUTPUTS
endin

instr	111	;COWBELL
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act11"              	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq1	=	562 * octave(i(gktune11))	;FREQUENCIES OF THE TWO OSCILLATORS
	ifrq2	=	845 * octave(i(gktune11))	;
	ipw  	=	0.5 				;PULSE WIDTH OF THE OSCILLATOR	
	idur 	=	0.7 				;NOTE DURATION
	ishp 	=	-30 	
	idur 	=	0.7 				;NOTE DURATION
	p3	=	idur*i(gkdur11)			;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)
	ishape	=	-30				;SHAPE OF THE CURVES IN THE AMPLITUDE ENVELOPE
	kenv1	transeg	1,p3*0.3,ishape,0.2, p3*0.7,ishape,0.2	;FIRST AMPLITUDE ENVELOPE - PRINCIPALLY THE ATTACK OF THE NOTE
	kenv2	expon	1,p3,0.0005				;SECOND AMPLITUDE ENVELOPE - THE SUSTAIN PORTION OF THE NOTE
	kenv	=	kenv1*kenv2			;COMBINE THE TWO ENVELOPES
	itype	=	2				;WAVEFORM FOR VCO2 (2=PULSE)
	a1	vco2	0.65,ifrq1,itype,ipw		;CREATE THE TWO OSCILLATORS
	a2	vco2	0.65,ifrq2,itype,ipw
	amix	=	a1+a2				;MIX THE TWO OSCILLATORS 
	iLPF2	=	10000				;LOWPASS FILTER RESTING FREQUENCY
	kcf	expseg	12000,0.07,iLPF2,1,iLPF2	;LOWPASS FILTER CUTOFF FREQUENCY ENVELOPE
	alpf	butlp	amix,kcf			;LOWPASS FILTER THE MIX OF THE TWO OSCILLATORS (CREATE A NEW SIGNAL)
	abpf	reson	amix, ifrq2, 25			;BANDPASS FILTER THE MIX OF THE TWO OSCILLATORS (CREATE A NEW SIGNAL)
	amix	dcblock2	(abpf*0.06*kenv1)+(alpf*0.5)+(amix*0.9)	;MIX ALL SIGNALS AND BLOCK DC OFFSET
	amix	buthp	amix,700			;HIGHPASS FILTER THE MIX OF ALL SIGNALS
	amix	=	amix*0.07*kenv*p4*gklevel11*gklevel	;RESCALE AMPLITUDE
	aL,aR	pan2	amix,i(gkpan11)			;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO OUTPUTS
endin

instr	112	;CLAP
	;;xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act12"              	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	iTimGap	=	0.01				;GAP BETWEEN EVENTS DURING ATTACK PORTION OF CLAP
	idur1  	=	0.02				;DURING OF THE THREE INITIAL 'CLAPS'
	idur2  	=	2*i(gkdur12)			;DURATION OF THE FOURTH, MAIN, CLAP
	idens  	=	8000				;DENSITY OF THE NOISE SIGNAL USED TO FORM THE CLAPS
	iamp1  	=	0.5				;AMPLITUDE OF AUDIO BEFORE BANDPASS FILTER IN OUTPUT
	iamp2  	=	1				;AMPLITUDE OF AUDIO AFTER BANDPASS FILTER IN OUTPUT
	if frac(p1)==0 then				;IF THIS IS THE INITIAL NOTE (p1 WILL BE AN INTEGER)
	 ;	        del.  dur  env.shape
	 event_i	"i", p1+0.1, 0,          idur1, p4	;CALL THIS INSTRUMENT 4 TIMES. ADD A FRACTION ONTO p1 TO BE ABLE TO DIFFERENTIATE THESE SUBSEQUENT NOTES
	 event_i	"i", p1+0.1, iTimGap,    idur1, p4
	 event_i	"i", p1+0.1, iTimGap*2,  idur1, p4
	 event_i	"i", p1+0.1, iTimGap*3,  idur2, p4
	else
	 kenv	transeg	1,p3,-25,0				;AMPLITUDE ENVELOPE
	 iamp	random	0.7,1					;SLIGHT RANDOMISATION OF AMPLITUDE	
	 anoise	dust2	kenv*iamp, idens			;CREATE NOISE SIGNAL
	
	 iBPF   	=	1100*octave(i(gktune12))	;FREQUENCY OF THE BANDPASS FILTER
	 ibw    	=	2000*octave(i(gktune12))	;BANDWIDTH OF THE BANDPASS FILTER
	 iHPF   	=	1000				;FREQUENCY OF A HIGHPASS FILTER
	 iLPF   	=	1				;SCALER FOR FREQUENCY OF A LOWPASS FILTER
	 kcf	expseg	8000,0.07,1700,1,800,2,500,1,500	;CREATE CUTOFF FREQUENCY ENVELOPE
	 asig	butlp	anoise,kcf*iLPF				;LOWPASS FILTER THE SOUND
	 asig	buthp	asig,iHPF				;HIGHPASS FILTER THE SOUND
	 ares	reson	asig,iBPF,ibw,1				;BANDPASS FILTER THE SOUND (CREATE A NEW SIGNAL)
	 asig	dcblock2	(asig*iamp1)+(ares*iamp2)	;MIX BANDPASS FILTERED AND NON-BANDPASS FILTERED SOUND ELEMENTS
	 asig	=	asig*p4*i(gklevel12)*1.75*gklevel	;SCALE AMPLITUDE
	 aL,aR	pan2	asig,i(gkpan12)				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
	endif
endin

instr	113	;MARACA
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act13"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	idur	=	0.07*i(gkdur13)				;DURATION 3
	p3	limit	idur,0.1,10				;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)
	iHPF 	limit	6000*octave(i(gktune13)),20,sr/2	;HIGHPASS FILTER FREQUENCY	
	iLPF 	limit	12000*octave(i(gktune13)),20,sr/3	;LOWPASS FILTER FREQUENCY. (LIMIT MAXIMUM TO PREVENT OUT OF RANGE VALUES)
	;AMPLITUDE ENVELOPE
	iBP1 	=	0.4					;BREAK-POINT 1
	iDur1	=	0.014*i(gkdur13) 			;DURATION 1
	iBP2 	=	1					;BREAKPOINT 2
	iDur2	=	0.01 *i(gkdur13)			;DURATION 2
	iBP3 	=	0.05 					;BREAKPOINT 3
	p3	limit	idur,0.1,10				;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)
	aenv	expsega	iBP1,iDur1,iBP2,iDur2,iBP3		;CREATE AMPLITUDE ENVELOPE
	anoise	noise	0.75,0					;CREATE A NOISE SIGNAL
	anoise	buthp	anoise,iHPF				;HIGHPASS FILTER THE SOUND
	anoise	butlp	anoise,iLPF				;LOWPASS FILTER THE SOUND
	anoise	=	anoise*aenv*p4*gklevel13*gklevel	;SCALE THE AMPLITUDE
	aL,aR	pan2	anoise,i(gkpan13)			;PAN THE MONOPONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	114	;HIGH CONGA
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act14"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq  	=	420*octave(i(gktune14))		;FREQUENCY OF NOTE
	p3  	=	0.22*i(gkdur14)			;DURATION OF NOTE
	aenv	transeg	0.7,1/ifrq,1,1,p3,-6,0.001	;AMPLITUDE ENVELOPE
	afrq	expsega	ifrq*3,0.25/ifrq,ifrq,1,ifrq	;FREQUENCY ENVELOPE (CREATE A SHARPER ATTACK)
	asig	oscili	-aenv*0.25,afrq,gisine		;CREATE THE AUDIO OSCILLATOR
	asig	=	asig*p4*gklevel14*gklevel	;SCALE THE AMPLITUDE
	aL,aR	pan2	asig,gkpan14			;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO THE OUTPUTS
endin

instr	115	;MID CONGA
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act15"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq   	=	310*octave(i(gktune15))		;FREQUENCY OF NOTE
	p3   	=	0.33*i(gkdur15)			;DURATION OF NOTE
	aenv	transeg	0.7,1/ifrq,1,1,p3,-6,0.001	;AMPLITUDE ENVELOPE	
	afrq	expsega	ifrq*3,0.25/ifrq,ifrq,1,ifrq	;FREQUENCY ENVELOPE (CREATE A SHARPER ATTACK)
	asig	oscili	-aenv*0.25,afrq,gisine		;CREATE THE AUDIO OSCILLATOR
	asig	=	asig*p4*gklevel15*gklevel		;SCALE THE AMPLITUDE
	aL,aR	pan2	asig,gkpan15			;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO THE OUTPUTS
endin

instr	116	;LOW CONGA
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act16"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq   	=	227*octave(i(gktune16))		;FREQUENCY OF NOTE
	p3   	=	0.41*i(gkdur16)			;DURATION OF NOTE 	
	aenv	transeg	0.7,1/ifrq,1,1,p3,-6,0.001	;AMPLITUDE ENVELOPE	
	afrq	expsega	ifrq*3,0.25/ifrq,ifrq,1,ifrq	;FREQUENCY ENVELOPE (CREATE A SHARPER ATTACK)
	asig	oscili	-aenv*0.25,afrq,gisine		;CREATE THE AUDIO OSCILLATOR
	asig	=	asig*p4*gklevel16*gklevel	;SCALE THE AMPLITUDE
	aL,aR	pan2	asig,gkpan16			;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO THE OUTPUTS
endin

</CsInstruments>

<CsScore>
f 0 [3600*24*7]
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer> ; TR-808.csd
; Written by Iain McCurdy, 2012
; 
; Saving patterns saves tables as text file to the pwd. Each save to a new pattern number creates a new text file on disk for that pattern.

; Choosing 'Host Control' allows the VST plugin host to decide 'Tempo' and 'Run/Stop' status

<Cabbage>
form caption("TR-808") size(800, 400), colour("SlateGrey"), pluginid("808B"), guirefresh(32) style("legacy")

label 		bounds(  5,385,120, 12), text("Iain McCurdy |2012|"), fontcolour("black")

groupbox bounds( 0,  0,  50, 225), text("B.Drum"),FontColour("black"), colour(192,192,192)
checkbox bounds(10, 24,   5,   5), colour("yellow"), channel("Act1"),  value(0), shape("ellipse"), active(0)
rslider  bounds( 5, 25,  45,  45), text("Level"), textcolour("black"), colour(80,100,150), channel("level1"), range(0, 2, 1,1,0.01)
rslider  bounds( 5, 75,  45,  45), text("Tune"),  textcolour("black"), colour(80,100,150), channel("tune1"),  range(-2, 2, 0,1,0.01)
rslider  bounds( 5,125,  45,  45), text("Decay"), textcolour("black"), colour(80,100,150), channel("dur1"),   range(0.25, 2, 1, 0.8)
rslider  bounds( 5,175,  45,  45), text("Pan"),   textcolour("black"), colour(80,100,150), channel("pan1"),   range(0, 1, 0.5,1,0.01)

groupbox bounds(50,  0,  50, 225), text("Snare"), FontColour("black"),colour(202,202,202)
checkbox bounds(60, 24,   5,   5), colour("yellow"), channel("Act2"),  value(0), shape("ellipse"), active(0)
rslider  bounds(55, 25,  45,  45), text("Level"), textcolour("black"), colour(80,100,150), channel("level2"), range(0, 2, 1,1,0.01)
rslider  bounds(55, 75,  45,  45), text("Tune"),  textcolour("black"), colour(80,100,150), channel("tune2"),  range(-2, 2, 0,1,0.01)
rslider  bounds(55,125,  45,  45), text("Decay"), textcolour("black"), colour(80,100,150), channel("dur2"),   range(0.25, 2, 1, 0.8)
rslider  bounds(55,175,  45,  45), text("Pan"),   textcolour("black"), colour(80,100,150), channel("pan2"),   range(0, 1, 0.5,1,0.01)

groupbox bounds(100,  0,  50, 225), text("Open HH"), FontColour("black"), colour(212,212,212)
checkbox bounds(110, 24,   5,   5), colour("yellow"), channel("Act3"),  value(0), shape("ellipse"), active(0)
rslider  bounds(105, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level3"), range(0, 2, 1,1,0.01)
rslider  bounds(105, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune3"),  range(-2, 2, 0,1,0.01)
rslider  bounds(105,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur3"),   range(0.25, 2, 1, 0.8)
rslider  bounds(105,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan3"),  range(0, 1, 0.5,1,0.01)
<<<<<<< HEAD
                                
=======

>>>>>>> audio_graph
groupbox bounds(150,  0,  50, 225), text("Cl. HH"),FontColour("black"),colour(222,222,222)
checkbox bounds(160, 24,   5,   5), colour("yellow"), channel("Act4"),  value(0), shape("ellipse"), active(0)
rslider  bounds(155, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level4"), range(0, 2, 1,1,0.01)
rslider  bounds(155, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune4"),  range(-2, 2, 0,1,0.01)
rslider  bounds(155,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur4"),   range(0.25, 2, 1, 0.8)
rslider  bounds(155,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan4"),  range(0, 1, 0.5,1,0.01)

groupbox bounds(200,  0,  50, 225), text("Hi Tom"), FontColour("black"),colour(232,232,232)
checkbox bounds(210, 24,   5,   5), colour("yellow"), channel("Act5"),  value(0), shape("ellipse"), active(0)
rslider  bounds(205, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level5"), range(0, 2, 1,1,0.01)
rslider  bounds(205, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune5"), range(-2, 2, 0,1,0.01)
rslider  bounds(205,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur5"),   range(0.25, 2, 1, 0.8)
rslider  bounds(205,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan5"),  range(0, 1, 0.5,1,0.01)

groupbox bounds(250,  0,  50, 225), text("Mid Tom"),FontColour("black"), colour(242,242,242)
checkbox bounds(260, 24,   5,   5), colour("yellow"), channel("Act6"),  value(0), shape("ellipse"), active(0)
rslider  bounds(255, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level6"), range(0, 2, 1,1,0.01)
rslider  bounds(255, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune6"), range(-2, 2, 0,1,0.01)
rslider  bounds(255,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur6"), range(0.25, 2, 1, 0.8)
rslider  bounds(255,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan6"),  range(0, 1, 0.5,1,0.01)

groupbox bounds(300,  0,  50, 225), text("Low Tom"),FontColour("black"), colour(232,232,232)
checkbox bounds(310, 24,   5,   5), colour("yellow"), channel("Act7"),  value(0), shape("ellipse"), active(0)
rslider  bounds(305, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level7"), range(0, 2, 1,1,0.01)
rslider  bounds(305, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune7"), range(-2, 2, 0,1,0.01)
rslider  bounds(305,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur7"), range(0.25, 2, 1, 0.8)
rslider  bounds(305,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan7"),  range(0, 1, 0.5,1,0.01)

groupbox bounds(350,  0,  50, 225), text("Cymbal"), FontColour("black"),colour(222,222,222)
checkbox bounds(360, 24,   5,   5), colour("yellow"), channel("Act8"),  value(0), shape("ellipse"), active(0)
rslider  bounds(355, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level8"), range(0, 2, 1,1,0.01)
rslider  bounds(355, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune8"),  range(-2, 2, 0,1,0.01)
rslider  bounds(355,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur8"),  range(0.25, 2, 1, 0.8)
rslider  bounds(355,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan8"),  range(0, 1, 0.5,1,0.01)

groupbox bounds(400,  0,  50, 225), text("Rim Shot"),FontColour("black"), colour(212,212,212)
checkbox bounds(410, 24,   5,   5), colour("yellow"), channel("Act9"),  value(0), shape("ellipse"), active(0)
rslider  bounds(405, 25,  45,  45), text("Level"),   textcolour("black"), colour(80,100,150), channel("level9"), range(0, 2, 1,1,0.01)
rslider  bounds(405, 75,  45,  45), text("Tune"),    textcolour("black"), colour(80,100,150), channel("tune9"),  range(-2, 2, 0,1,0.01)
rslider  bounds(405,125,  45,  45), text("Decay"),   textcolour("black"), colour(80,100,150), channel("dur9"),  range(0.25, 2, 1, 0.8)
rslider  bounds(405,175,  45,  45), text("Pan"),     textcolour("black"), colour(80,100,150), channel("pan9"),  range(0, 1, 0.5,1,0.01)

groupbox bounds(450,  0,  50, 225), text("Claves"), FontColour("black"),colour(202,202,202)
checkbox bounds(460, 24,   5,   5), colour("yellow"), channel("Act10"),  value(0), shape("ellipse"), active(0)
rslider  bounds(455, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level10"), range(0, 2, 1,1,0.01)
rslider  bounds(455, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune10"),  range(-2, 2, 0,1,0.01)
rslider  bounds(455,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur10"),  range(0.25, 2, 1, 0.8)
rslider  bounds(455,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan10"), range(0, 1, 0.5,1,0.01)

groupbox bounds(500,  0,  50, 225), text("Cowbell"),FontColour("black"), colour(192,192,192)
checkbox bounds(510, 24,   5,   5), colour("yellow"), channel("Act11"),  value(0), shape("ellipse"), active(0)
rslider  bounds(505, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level11"), range(0, 2, 1,1,0.01)
rslider  bounds(505, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune11"),  range(-2, 2, 0,1,0.01)
rslider  bounds(505,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur11"),  range(0.25, 2, 1, 0.8)
rslider  bounds(505,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan11"), range(0, 1, 0.5,1,0.01)

groupbox bounds(550,  0,  50, 225), text("Clap"), FontColour("black"),colour(182,182,182)
checkbox bounds(560, 24,   5,   5), colour("yellow"), channel("Act12"),  value(0), shape("ellipse"), active(0)
rslider  bounds(555, 25,  45,  45), text("Level"), textcolour("black"), colour(80,100,150), channel("level12"), range(0, 2, 1,1,0.01)
rslider  bounds(555, 75,  45,  45), text("Tune"),  textcolour("black"), colour(80,100,150), channel("tune12"),  range(-2, 2, 0,1,0.01)
rslider  bounds(555,125,  45,  45), text("Decay"), textcolour("black"), colour(80,100,150), channel("dur12"),  range(0.25, 2, 1, 0.8)
rslider  bounds(555,175,  45,  45), text("Pan"),   textcolour("black"), colour(80,100,150), channel("pan12"), range(0, 1, 0.5,1,0.01)

groupbox bounds(600,  0,  50, 225), text("Maraca"),FontColour("black"), colour(172,172,172)
checkbox bounds(610, 24,   5,   5), colour("yellow"), channel("Act13"),  value(0), shape("ellipse"), active(0)
rslider  bounds(605, 25,  45,  45), text("Level"), textcolour("black"), colour(80,100,150), channel("level13"), range(0, 2, 1,1,0.01)
rslider  bounds(605, 75,  45,  45), text("Tune"),  textcolour("black"), colour(80,100,150), channel("tune13"),  range(-2, 2, 0,1,0.01)
rslider  bounds(605,125,  45,  45), text("Decay"), textcolour("black"), colour(80,100,150), channel("dur13"),  range(0.25, 2, 1, 0.8)
rslider  bounds(605,175,  45,  45), text("Pan"),   textcolour("black"), colour(80,100,150), channel("pan13"), range(0, 1, 0.5,1,0.01)

groupbox bounds(650,  0,  50, 225), text("Hi Conga"),FontColour("black"), colour(162,162,162)
checkbox bounds(660, 24,   5,   5), colour("yellow"), channel("Act14"),  value(0), shape("ellipse"), active(0)
rslider  bounds(655, 25,  45,  45), text("Level"),   textcolour("black"), colour(80,100,150), channel("level14"), range(0, 2, 1,1,0.01)
rslider  bounds(655, 75,  45,  45), text("Tune"),    textcolour("black"), colour(80,100,150), channel("tune14"),  range(-2, 2, 0,1,0.01)
rslider  bounds(655,125,  45,  45), text("Decay"),   textcolour("black"), colour(80,100,150), channel("dur14"),   range(0.25, 2, 1, 0.8)
rslider  bounds(655,175,  45,  45), text("Pan"),     textcolour("black"), colour(80,100,150), channel("pan14"), range(0, 1, 0.5,0.01)

groupbox bounds(700,  0,  50, 225), text("Md Cnga"),FontColour("black"), colour(152,152,152)
checkbox bounds(710, 24,   5,   5), colour("yellow"), channel("Act15"),  value(0), shape("ellipse"), active(0)
rslider  bounds(705, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level15"), range(0, 2, 1,1,0.01)
rslider  bounds(705, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune15"),  range(-2, 2, 0,1,0.01)
rslider  bounds(705,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur15"),   range(0.25, 2, 1, 0.8)
rslider  bounds(705,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan15"), range(0, 1, 0.5,1,0.01)

groupbox bounds(750,  0,  50, 225), text("Lo Cnga"),FontColour("black"), colour(142,142,142)
checkbox bounds(760, 24,   5,   5), colour("yellow"), channel("Act16"),  value(0), shape("ellipse"), active(0)
rslider  bounds(755, 25,  45,  45), text("Level"),  textcolour("black"), colour(80,100,150), channel("level16"), range(0, 2, 1,1,0.01)
rslider  bounds(755, 75,  45,  45), text("Tune"),   textcolour("black"), colour(80,100,150), channel("tune16"),  range(-2, 2, 0,1,0.01)
rslider  bounds(755,125,  45,  45), text("Decay"),  textcolour("black"), colour(80,100,150), channel("dur16"),   range(0.25, 2, 1, 0.8)
rslider  bounds(755,175,  45,  45), text("Pan"),    textcolour("black"), colour(80,100,150), channel("pan16"), range(0, 1, 0.5,1,0.01)


keyboard pos(0, 225), size(800, 80)
button   bounds( 10,315, 40, 25), fontcolour:0(50,50,50), fontcolour:1(205,255,205), colour:0(0,10,0), colour:1(0,150,0), text("Play","Play"), channel("Play"), latched(1), radiogroup(1), identchannel("PlayButton")
button   bounds( 50,315, 40, 25), fontcolour:0(50,50,50), fontcolour:1(255,205,205), colour:0(10,0,0), colour:1(150,0,0), text("Stop","Stop"), channel("Stop"), latched(1), radiogroup(1), value(1), identchannel("StopButton")


combobox bounds( 10,345, 80, 15), channel("sound"), value(1), text("Bass Drum","Snare","Open HH","Cl. HH","Hi Tom","Mid Tom","Lo Tom","Cymbal","Rimshot","Claves","Cowbell","Clap","Maraca","Hi Conga","Mid Conga","Lo Conga")
button   bounds(462,315, 80, 20), text("Clear","Clear"), channel("clear"), value(0)
button   bounds(462,338, 38, 20), text("Save","Save"), channel("save"), value(0)
button   bounds(502,338, 38, 20), text("Load","Load"), channel("load"), value(0)
label    bounds(542,328, 48, 10), text("PATTERN"), FontColour("black")
combobox bounds(544,338, 45, 20), channel("pattern"), value(1), text("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16")
rslider  bounds(593,310, 60, 60), text("Accent"),  textcolour("black"), colour(80,100,150), channel("AccLev"), range(0, 1.00, 0.4)
rslider  bounds(643,310, 60, 60), text("Tempo"),   textcolour("black"), colour(80,100,150), channel("tempo"), range(10, 500, 70, 1, 1)
rslider  bounds(693,310, 60, 60), text("Swing"),   textcolour("black"), colour(80,100,150), channel("swing"), range(0, 0.50, 0)
rslider  bounds(743,310, 60, 60), text("Level"),   textcolour("black"), colour(80,100,150), channel("level"), range(0, 2.00, 1)

label    bounds(143,312,  6, 10), text("1"), FontColour("black")
label    bounds(163,312,  6, 10), text("2"), FontColour("black")
label    bounds(183,312,  6, 10), text("3"), FontColour("black")
label    bounds(203,312,  6, 10), text("4"), FontColour("black")
label    bounds(223,312,  6, 10), text("5"), FontColour("black")
label    bounds(243,312,  6, 10), text("6"), FontColour("black")
label    bounds(263,312,  6, 10), text("7"), FontColour("black")
label    bounds(283,312,  6, 10), text("8"), FontColour("black")
label    bounds(303,312,  6, 10), text("9"), FontColour("black")
label    bounds(320,312, 12, 10), text("10"), FontColour("black")
label    bounds(340,312, 12, 10), text("11"), FontColour("black")
label    bounds(360,312, 12, 10), text("12"), FontColour("black")
label    bounds(380,312, 12, 10), text("13"), FontColour("black")
label    bounds(400,312, 12, 10), text("14"), FontColour("black")
label    bounds(420,312, 12, 10), text("15"), FontColour("black")
label    bounds(440,312, 12, 10), text("16"), FontColour("black")

label    bounds(120, 325, 17, 12), text("On"), FontColour("black")
checkbox bounds(140, 325, 12, 12), channel("On1"),  value(1)
checkbox bounds(160, 325, 12, 12), channel("On2"),  value(0)
checkbox bounds(180, 325, 12, 12), channel("On3"),  value(0)
checkbox bounds(200, 325, 12, 12), channel("On4"),  value(1)
checkbox bounds(220, 325, 12, 12), channel("On5"),  value(1)
checkbox bounds(240, 325, 12, 12), channel("On6"),  value(0)
checkbox bounds(260, 325, 12, 12), channel("On7"),  value(0)
checkbox bounds(280, 325, 12, 12), channel("On8"),  value(0)
checkbox bounds(300, 325, 12, 12), channel("On9"),  value(1)
checkbox bounds(320, 325, 12, 12), channel("On10"), value(0)
checkbox bounds(340, 325, 12, 12), channel("On11"), value(0)
checkbox bounds(360, 325, 12, 12), channel("On12"), value(1)
checkbox bounds(380, 325, 12, 12), channel("On13"), value(0)
checkbox bounds(400, 325, 12, 12), channel("On14"), value(1)
checkbox bounds(420, 325, 12, 12), channel("On15"), value(0)
checkbox bounds(440, 325, 12, 12), channel("On16"), value(0)

label    bounds( 98, 345, 38, 12), text("Accent"), FontColour("black")
checkbox bounds(140, 345, 12, 12), channel("Acc1"),  value(1), colour("yellow")
checkbox bounds(160, 345, 12, 12), channel("Acc2"),  value(0), colour("yellow")
checkbox bounds(180, 345, 12, 12), channel("Acc3"),  value(0), colour("yellow")
checkbox bounds(200, 345, 12, 12), channel("Acc4"),  value(0), colour("yellow")
checkbox bounds(220, 345, 12, 12), channel("Acc5"),  value(0), colour("yellow")
checkbox bounds(240, 345, 12, 12), channel("Acc6"),  value(0), colour("yellow")
checkbox bounds(260, 345, 12, 12), channel("Acc7"),  value(0), colour("yellow")
checkbox bounds(280, 345, 12, 12), channel("Acc8"),  value(0), colour("yellow")
checkbox bounds(300, 345, 12, 12), channel("Acc9"),  value(0), colour("yellow")
checkbox bounds(320, 345, 12, 12), channel("Acc10"), value(0), colour("yellow")
checkbox bounds(340, 345, 12, 12), channel("Acc11"), value(0), colour("yellow")
checkbox bounds(360, 345, 12, 12), channel("Acc12"), value(0), colour("yellow")
checkbox bounds(380, 345, 12, 12), channel("Acc13"), value(0), colour("yellow")
checkbox bounds(400, 345, 12, 12), channel("Acc14"), value(0), colour("yellow")
checkbox bounds(420, 345, 12, 12), channel("Acc15"), value(0), colour("yellow")
checkbox bounds(440, 345, 12, 12), channel("Acc16"), value(0), colour("yellow")

button   bounds(458,362, 90, 18), text("Local Control","Host Control"), channel("control"), value(0)


</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-n -+rtmidi=null -M0 -dm0
</CsOptions>

<CsInstruments>

sr 		= 	44100	;SAMPLE RATE
ksmps 		= 	32	;NUMBER OF AUDIO SAMPLES IN EACH CONTROL CYCLE
nchnls 		= 	2	;NUMBER OF CHANNELS (2=STEREO)
0dbfs		=	1
massign	0,2

;Author: Iain McCurdy (2012)

gisine		ftgen	0,0,1024,10,1		;A SINE WAVE
gicos		ftgen	0,0,65536,9,1,1,90	;A COSINE WAVE
gkoff	init	0
;				1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16
giOn1	ftgen	0,0,16,2,	1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0	;BD
giOn2	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0	;SN
giOn3	ftgen	0,0,16,2,	0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0  ;HHO
giOn4	ftgen	0,0,16,2,	1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1  ;HHCl
giOn5	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Hi Tom
giOn6	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Mid Tom
giOn7	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0  ;Lo Tom
giOn8	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0  ;Cym
giOn9	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Rimshot
giOn10	ftgen	0,0,16,2,	1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0  ;Claves
giOn11	ftgen	0,0,16,2,	1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1  ;Cowbell
giOn12	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0  ;Clap
giOn13	ftgen	0,0,16,2,	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0  ;Maraca
giOn14	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0  ;Hi Conga
giOn15	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0  ;Mid Conga
giOn16	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1  ;Lo Conga
giAcc1	ftgen	0,0,16,2,	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	;BD
giAcc2	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	;SN
giAcc3	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;HHO
giAcc4	ftgen	0,0,16,2,	1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0  ;HHCl
giAcc5	ftgen	0,0,16,2,	0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Hi Tom
giAcc6	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Mid Tom
giAcc7	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0  ;Lo Tom
giAcc8	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0  ;Cym
giAcc9	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Rimshot
giAcc10	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Claves
giAcc11	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Cowbell
giAcc12	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;Clap
giAcc13	ftgen	0,0,16,2,	1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0  ;Maraca
giAcc14	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0  ;Hi Conga
giAcc15	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0  ;Mid Conga
giAcc16	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0  ;Lo Conga
giblank	ftgen	0,0,16,2,	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;blank

instr	1	;READ IN WIDGETS, SCAN MIDI NOTES PLAYED AND RELAY TO DRUM SOUNDS 
	gkPlay		chnget	"Play"
	gkStop		chnget	"Stop"
	if trigger(gkPlay,0.5,0)==1 then
	 gkOnOff	=	1
	elseif trigger(gkStop,0.5,0)==1 then
	 gkOnOff	=	0
	endif

	;READ IN WIDGETS
	gklevel1	chnget	"level1"
	gklevel2	chnget	"level2"
	gklevel3	chnget	"level3"
	gklevel4	chnget	"level4"
	gklevel5	chnget	"level5"
	gklevel6	chnget	"level6"
	gklevel7	chnget	"level7"
	gklevel8	chnget	"level8"
	gklevel9	chnget	"level9"
	gklevel10	chnget	"level10"	
	gklevel11	chnget	"level11"	
	gklevel12	chnget	"level12"	
	gklevel13	chnget	"level13"	
	gklevel14	chnget	"level14"	
	gklevel15	chnget	"level15"	
	gklevel16	chnget	"level16"	
	gktune1		chnget	"tune1"	
	gktune2		chnget	"tune2"	
	gktune3		chnget	"tune3"	
	gktune4		chnget	"tune4"	
	gktune5		chnget	"tune5"	
	gktune6		chnget	"tune6"	
	gktune7		chnget	"tune7"	
	gktune8		chnget	"tune8"	
	gktune9		chnget	"tune9"	
	gktune10	chnget	"tune10"	
	gktune11	chnget	"tune11"	
	gktune12	chnget	"tune12"	
	gktune13	chnget	"tune13"	
	gktune14	chnget	"tune14"	
	gktune15	chnget	"tune15"	
	gktune16	chnget	"tune16"
	gkdur1	chnget	"dur1"
	gkdur2	chnget	"dur2"
	gkdur3	chnget	"dur3"
	gkdur4	chnget	"dur4"
	gkdur5	chnget	"dur5"
	gkdur6	chnget	"dur6"
	gkdur7	chnget	"dur7"
	gkdur8	chnget	"dur8"
	gkdur9	chnget	"dur9"
	gkdur10	chnget	"dur10"	
	gkdur11	chnget	"dur11"	
	gkdur12	chnget	"dur12"	
	gkdur13	chnget	"dur13"	
	gkdur14	chnget	"dur14"	
	gkdur15	chnget	"dur15"	
	gkdur16	chnget	"dur16"	
	gkpan1		chnget	"pan1"	
	gkpan2		chnget	"pan2"	
	gkpan3		chnget	"pan3"	
	gkpan4		chnget	"pan4"	
	gkpan5		chnget	"pan5"	
	gkpan6		chnget	"pan6"	
	gkpan7		chnget	"pan7"	
	gkpan8		chnget	"pan8"	
	gkpan9		chnget	"pan9"	
	gkpan10		chnget	"pan10"	
	gkpan11		chnget	"pan11"	
	gkpan12		chnget	"pan12"	
	gkpan13		chnget	"pan13"	
	gkpan14		chnget	"pan14"	
	gkpan15		chnget	"pan15"	
	gkpan16		chnget	"pan16"
	gksound		chnget	"sound"
	gkOn1		chnget	"On1"
	gkOn2		chnget	"On2"
	gkOn3		chnget	"On3"
	gkOn4		chnget	"On4"
	gkOn5		chnget	"On5"
	gkOn6		chnget	"On6"
	gkOn7		chnget	"On7"
	gkOn8		chnget	"On8"
	gkOn9		chnget	"On9"
	gkOn10		chnget	"On10"
	gkOn11		chnget	"On11"
	gkOn12		chnget	"On12"
	gkOn13		chnget	"On13"
	gkOn14		chnget	"On14"
	gkOn15		chnget	"On15"
	gkOn16		chnget	"On16"
	gkAcc1		chnget	"Acc1"
	gkAcc2		chnget	"Acc2"
	gkAcc3		chnget	"Acc3"
	gkAcc4		chnget	"Acc4"
	gkAcc5		chnget	"Acc5"
	gkAcc6		chnget	"Acc6"
	gkAcc7		chnget	"Acc7"
	gkAcc8		chnget	"Acc8"
	gkAcc9		chnget	"Acc9"
	gkAcc10		chnget	"Acc10"
	gkAcc11		chnget	"Acc11"
	gkAcc12		chnget	"Acc12"
	gkAcc13		chnget	"Acc13"
	gkAcc14		chnget	"Acc14"
	gkAcc15		chnget	"Acc15"
	gkAcc16		chnget	"Acc16"
	gkclear		chnget	"clear"
	gksave		chnget	"save"
	gkload		chnget	"load"
	gkpattern	chnget	"pattern"
	gkAccLev	chnget	"AccLev"
	gktempo		chnget	"tempo"
	gkswing		chnget	"swing"
	gklevel		chnget	"level"

	kcontrol	chnget	"control"
	if kcontrol==1 then			; host control over start stop and tempo
	 gktempo	chnget	"HOST_BPM"
	 gkOnOff	chnget	"IS_PLAYING"
	 if changed(gktempo)==1 then
	  chnset	gktempo, "tempo"
	 endif
	 if changed(gkOnOff)==1 then
	  chnset	gkOnOff, "OnOff"
	 endif
	endif
	
	;START/STOP SEQUENCER
	ktrig	changed	gkOnOff		;if Run/Stop button is changed...
	if ktrig==1 then		;
	 if gkOnOff==1 then		;...if Run/Stop has been changed to 'Run'...
	  event	"i",3,0,-1		;...start instr 3 playing a held note
	 else				;otherwise...
	  event	"i",-3,0,0		;...stop instr 3 playing
	 endif
	endif
	
	;CLEAR SEQUENCES FOR ALL DRUM SOUNDS
	ktrig changed	gkclear		
	if ktrig==1 then
	 tablecopy	giOn1,	giblank	 ;copy blank table over existing sequence for voice 1
	 tablecopy	giOn2,	giblank	 ;repeat for every other voice
	 tablecopy	giOn3,	giblank	 
	 tablecopy	giOn4,	giblank	 
	 tablecopy	giOn5,	giblank	 
	 tablecopy	giOn6,	giblank	 
	 tablecopy	giOn7,	giblank	 
	 tablecopy	giOn8,	giblank	 
	 tablecopy	giOn9,	giblank	 
	 tablecopy	giOn10,	giblank	 
	 tablecopy	giOn11,	giblank	 
	 tablecopy	giOn12,	giblank	 
	 tablecopy	giOn13,	giblank	 
	 tablecopy	giOn14,	giblank	 
	 tablecopy	giOn15,	giblank	 
	 tablecopy	giOn16,	giblank	 
	 tablecopy	giAcc1,		giblank	 
	 tablecopy	giAcc2,		giblank	 
	 tablecopy	giAcc3,		giblank	 
	 tablecopy	giAcc4,		giblank	 
	 tablecopy	giAcc5,		giblank	 
	 tablecopy	giAcc6,		giblank	 
	 tablecopy	giAcc7,		giblank	 
	 tablecopy	giAcc8,		giblank	 
	 tablecopy	giAcc9,		giblank	 
	 tablecopy	giAcc10,	giblank	 
	 tablecopy	giAcc11,	giblank	 
	 tablecopy	giAcc12,	giblank	 
	 tablecopy	giAcc13,	giblank	 
	 tablecopy	giAcc14,	giblank	 
	 tablecopy	giAcc15,	giblank	 
	 tablecopy	giAcc16,	giblank	 
	endif
	
	;STORE SEQUENCE TABLES
	ktrig changed	gksave	;if save button is toggled...
	igoto	SKIP
	if ktrig==1 then
	 reinit	SAVE_TABLES	;begin a reinitialisation pass from label (ftsave operates only at i-time)
	endif
	SAVE_TABLES:
	SFileName sprintf "TR-808_pattern.%d.txt", i(gkpattern)	;create the file name (string variable) that will be used to name the text file that will contain the pattern data
	ftsave SFileName, 1, giOn1, giOn2, giOn3, giOn4, giOn5, giOn6, giOn7, giOn8, giOn9, giOn10, giOn11, giOn12, giOn13, giOn14, giOn15, giOn16, giAcc1, giAcc2, giAcc3, giAcc4, giAcc5, giAcc6, giAcc7, giAcc8, giAcc9, giAcc10, giAcc11, giAcc12, giAcc13, giAcc14, giAcc15, giAcc16	;save all tables (on information and accents) to a text file in the pwd
	rireturn	
	SKIP:
	
	;LOAD SEQUENCE TABLES
	ktrig changed	gkload	;if load button is toggled...
	igoto	SKIP2
	if ktrig==1 then
	 reinit	LOAD_TABLES	;begin a reinitialisation pass from label (ftload operates only at i-time)
	endif
	LOAD_TABLES:
	SFileName sprintf "TR-808_pattern.%d.txt", i(gkpattern)	;create the file name (string variable) that will be the name of the file from which data will be retrieved
	ftload SFileName, 1, giOn1, giOn2, giOn3, giOn4, giOn5, giOn6, giOn7, giOn8, giOn9, giOn10, giOn11, giOn12, giOn13, giOn14, giOn15, giOn16, giAcc1, giAcc2, giAcc3, giAcc4, giAcc5, giAcc6, giAcc7, giAcc8, giAcc9, giAcc10, giAcc11, giAcc12, giAcc13, giAcc14, giAcc15, giAcc16	;load all tables (on information and accents) to a text file in the pwd
	rireturn	
	SKIP2:
	
	;UPDATE SEQUENCE DISPLAY
	ktrig	changed	gksound,gkclear,gkload
	if ktrig==1 then
#define	UPDATE_SEQUENCE(N)
	 #
	 kval	tablekt	$N-1,giOn1+gksound-1
	 chnset	kval,"On$N"
	 kval	tablekt	$N-1,giAcc1+gksound-1
	 chnset	kval,"Acc$N"
	 #
	 $UPDATE_SEQUENCE(1)
	 $UPDATE_SEQUENCE(2)
	 $UPDATE_SEQUENCE(3)
	 $UPDATE_SEQUENCE(4)
	 $UPDATE_SEQUENCE(5)
	 $UPDATE_SEQUENCE(6)
	 $UPDATE_SEQUENCE(7)
	 $UPDATE_SEQUENCE(8)
	 $UPDATE_SEQUENCE(9)
	 $UPDATE_SEQUENCE(10)
	 $UPDATE_SEQUENCE(11)
	 $UPDATE_SEQUENCE(12)
	 $UPDATE_SEQUENCE(13)
	 $UPDATE_SEQUENCE(14)
	 $UPDATE_SEQUENCE(15)
	 $UPDATE_SEQUENCE(16)
	endif
	
	;UPDATE TABLE IF SEQUENCE BUTTON CHANGED
#define	UPDATE_TABLE(N)
	#
	ktrig	changed	gkOn$N
	if ktrig==1 then
	 tablewkt	gkOn$N,$N-1,giOn1+gksound-1
	endif
	ktrig	changed	gkAcc$N
	if ktrig==1 then
	 tablewkt	gkAcc$N,$N-1,giAcc1+gksound-1
	endif
	#
	$UPDATE_TABLE(1)
	$UPDATE_TABLE(2)
	$UPDATE_TABLE(3)
	$UPDATE_TABLE(4)
	$UPDATE_TABLE(5)
	$UPDATE_TABLE(6)
	$UPDATE_TABLE(7)
	$UPDATE_TABLE(8)
	$UPDATE_TABLE(9)
	$UPDATE_TABLE(10)
	$UPDATE_TABLE(11)
	$UPDATE_TABLE(12)
	$UPDATE_TABLE(13)
	$UPDATE_TABLE(14)
	$UPDATE_TABLE(15)
	$UPDATE_TABLE(16)
endin

instr	2	;READ MIDI AND TRIGGER NOTES
	inum	notnum					;READ IN MIDI NOTE NUMBER
	idb	veloc	-30,0				;READ IN MIDI NOTE VELOCITY (WILL BE USED AS A DECIBEL VALUE)
	iinstr	wrap	inum,0,16			;MAP MIDI NOTE NUMBERS (RANGE: 0 - 127) TO DRUM SOUND NUMBER (0 - 15)
	event_i	"i",101+iinstr,0,0.001,ampdbfs(idb)	;CALL THE RELEVANT INSTRUMENT AND SEND AMPLITUDE VALUE AS p4
endin

instr	3	;PLAY SEQUENCE	
	gindx	init	0
	ktick	metro		(gktempo*4)/60
	
	;SWING
	kSwingBeat init	0
	kSwingTime	=	(kSwingBeat==1?(60*gkswing)/(gktempo*4):0)
	if ktick==1 then
	 kSwingBeat	=	abs(kSwingBeat-1)	;FLIP BETWEEN ZERO AND 1
	endif
	
		schedkwhen	ktick, 0, 0, 4, kSwingTime, 0.001
endin

instr	4	;TEST FOR NOTE ON SEQUENCE STEP
#define	VOICE(N)	
	#
	iOnOff$N	table		gindx, giOn$N
	if iOnOff$N==1 then
	 iAcc	table	gindx,giAcc$N
	 event_i	"i", 100+$N, 0, 0.001, 0.4 + (iAcc*i(gkAccLev))
	endif
	#
$VOICE(1)
$VOICE(2)
$VOICE(3)
$VOICE(4)
$VOICE(5)
$VOICE(6)
$VOICE(7)
$VOICE(8)
$VOICE(9)
$VOICE(10)
$VOICE(11)
$VOICE(12)
$VOICE(13)
$VOICE(14)
$VOICE(15)
$VOICE(16)
	gindx		wrap	gindx+1, 0, 16
			turnoff
endin

instr	101	;BASS DRUM
	xtratim	0.1
	krelease	release		;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)
	chnset	1-krelease,"Act1"	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS

	p3	=	2*i(gkdur1)							;NOTE DURATION. SCALED USING GUI 'Decay' KNOB

	;SUSTAIN AND BODY OF THE SOUND
	kmul	transeg	0.2,p3*0.5,-15,0.01, p3*0.5,0,0					;PARTIAL STRENGTHS MULTIPLIER USED BY GBUZZ. DECAYS FROM A SOUND WITH OVERTONES TO A SINE TONE.
	kbend	transeg	0.5,1.2,-4, 0,1,0,0						;SLIGHT PITCH BEND AT THE START OF THE NOTE 
	asig	gbuzz	0.5,50*octave(gktune1)*semitone(kbend),20,1,kmul,gicos		;GBUZZ TONE
	aenv	transeg	1,p3-0.004,-6,0							;AMPLITUDE ENVELOPE FOR SUSTAIN OF THE SOUND
	aatt	linseg	0,0.004,1							;SOFT ATTACK
	asig	=	asig*aenv*aatt

	;HARD, SHORT ATTACK OF THE SOUND
	aenv	linseg	1,0.07,0							;AMPLITUDE ENVELOPE (FAST DECAY)						
	acps	expsega	400,0.07,0.001,1,0.001						;FREQUENCY OF THE ATTACK SOUND. QUICKLY GLISSES FROM 400 Hz TO SUB-AUDIO
	aimp	oscili	aenv,acps*octave(gktune1*0.25),gisine				;CREATE ATTACK SOUND
	
	amix	=	((asig*0.5)+(aimp*0.35))*gklevel1*p4*gklevel			;MIX SUSTAIN AND ATTACK SOUND ELEMENTS AND SCALE USING GUI 'Level' KNOB
	
	aL,aR	pan2	amix,gkpan1							;PAN THE MONOPHONIC SOUND
		outs	aL,aR								;SEND AUDIO TO OUTPUTS
endin

instr	102	;SNARE DRUM
	xtratim	0.1
	krelease	release		;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act2"       ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	
	;SOUND CONSISTS OF TWO SINE TONES, AN OCTAVE APART AND A NOISE SIGNAL
	ifrq  	=	342		;FREQUENCY OF THE TONES
	iNseDur	=	0.3 * i(gkdur2)	;DURATION OF THE NOISE COMPONENT
	iPchDur	=	0.1 * i(gkdur2)	;DURATION OF THE SINE TONES COMPONENT
	p3	=	iNseDur 	;p3 DURATION TAKEN FROM NOISE COMPONENT DURATION (ALWATS THE LONGEST COMPONENT)
	
	;SINE TONES COMPONENT
	aenv1	expseg	1,iPchDur,0.0001,p3-iPchDur,0.0001		;AMPLITUDE ENVELOPE
	apitch1	oscili	1,ifrq*octave(gktune2),gisine			;SINE TONE 1
	apitch2	oscili	0.25,ifrq*0.5*octave(gktune2),gisine		;SINE TONE 2 (AN OCTAVE LOWER)
	apitch	=	(apitch1+apitch2)*0.75				;MIX THE TWO SINE TONES

	;NOISE COMPONENT
	aenv2	expon	1,p3,0.0005					;AMPLITUDE ENVELOPE
	anoise	noise	0.75,0						;CREATE SOME NOISE
	anoise	butbp	anoise,10000*octave(gktune2),10000		;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,1000					;HIGHPASS FILTER THE NOISE SIGNAL
	kcf	expseg	5000,0.1,3000,p3-0.2,3000			;CUTOFF FREQUENCY FOR A LOWPASS FILTER
	anoise	butlp	anoise,kcf					;LOWPASS FILTER THE NOISE SIGNAL
	amix	=	((apitch*aenv1)+(anoise*aenv2))*gklevel2*p4*gklevel	;MIX AUDIO SIGNALS AND SCALE ACCORDING TO GUI 'Level' CONTROL
	aL,aR	pan2	amix,i(gkpan2)					;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR						;SEND AUDIO TO OUTPUTS
endin

instr	103	;OPEN HIGH HAT
	xtratim	0.1
	kFrq1	=	296*octave(gktune3) 	;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285*octave(gktune3) 	
	kFrq3	=	365*octave(gktune3) 	
	kFrq4	=	348*octave(gktune3) 	
	kFrq5	=	420*octave(gktune3) 	
	kFrq6	=	835*octave(gktune3) 	
	p3	=	0.5*i(gkdur3)		;DURATION OF THE NOTE
	
	;SOUND CONSISTS OF 6 PULSE OSCILLATORS MIXED WITH A NOISE COMPONENT
	;PITCHED ELEMENT
	aenv	linseg	1,p3-0.05,0.1,0.05,0		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS
	ipw	=	0.25				;PULSE WIDTH
	a1	vco2	0.5,kFrq1,2,ipw			;PULSE OSCILLATORS...
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000*octave(gktune3),5000,1	;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,5000			;HIGHPASS FILTER THE SOUND...
	amix	buthp	amix,5000			;...AND AGAIN
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	linseg	1,p3-0.05,0.1,0.05,0		;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	20000,0.7,9000,p3-0.1,9000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*gklevel3*p4*0.55*gklevel
	aL,aR	pan2	amix,gkpan3			;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
	;kactive	active	p1+1				;CHECK NUMBER OF ACTIVE INSTANCES OF CLOSED HIGH HAT INSTRUMENT
	;if kactive>0 then			;IF HIGH-HAT CLOSED IS ACTIVE...
	; turnoff				;TURN OFF THIS INSTRUMENT
	;endif
	krelease	release			;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act3"       	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
endin

instr	104	;CLOSED HIGH HAT
	xtratim	0.1
	krelease	release			;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act4"       	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kFrq1	=	296*octave(gktune4) 	;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285*octave(gktune4) 	
	kFrq3	=	365*octave(gktune4) 	
	kFrq4	=	348*octave(gktune4) 	
	kFrq5	=	420*octave(gktune4) 	
	kFrq6	=	835*octave(gktune4) 	
	idur	=	0.088*i(gkdur4)		;DURATION OF THE NOTE
	p3	limit	idur,0.1,10		;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)

	iactive	active	p1-1			;SENSE ACTIVITY OF PREVIOUS INSTRUMENT (OPEN HIGH HAT) 
	if iactive>0 then			;IF 'OPEN HIGH HAT' IS ACTIVE...
	 turnoff2	p1-1,0,0		;TURN IT OFF (CLOSED HIGH HAT TAKES PRESIDENCE)
	 chnset	gkoff,"Act3"       	;TURN OFF ACTIVE LIGHT FOR OPEN HIGH HAT
	endif

	;PITCHED ELEMENT
	aenv	expsega	1,idur,0.001,1,0.001		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS
	ipw	=	0.25				;PULSE WIDTH
	a1	vco2	0.5,kFrq1,2,ipw			;PULSE OSCILLATORS...			
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000*octave(gktune4),5000,1	;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,5000			;HIGHPASS FILTER THE SOUND...
	amix	buthp	amix,5000			;...AND AGAIN
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	expsega	1,idur,0.001,1,0.001		;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	20000,0.7,9000,idur-0.1,9000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*gklevel4*p4*0.55*gklevel
	aL,aR	pan2	amix,gkpan4			;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
endin

instr	105	;HIGH TOM
	xtratim	0.1
	krelease	release					;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act5"       			;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq     	=	200 * octave(i(gktune5))	;FREQUENCY
	p3	  	=	0.5 * i(gkdur5)			;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise,400*octave(i(gktune5)),800,1	;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100*octave(i(gktune5))		;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,1000*octave(i(gktune5))		;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*gklevel5*p4*gklevel
	aL,aR	pan2	amix,gkpan5				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	106	;MID TOM
	xtratim	0.1
	krelease	release					;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act6"               		;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq     	=	133*octave(i(gktune6)) 		;FREQUENCY
	p3	  	=	0.6 * i(gkdur6)			;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise, 400*octave(i(gktune6)),800,1	;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100*octave(i(gktune6))		;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,600*octave(i(gktune6))		;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*gklevel6*p4*gklevel
	aL,aR	pan2	amix,i(gkpan6)				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	107	;LOW TOM
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act7"               	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq     	=	90 * octave(i(gktune7))	;FREQUENCY
	p3 	 	=	0.7*i(gkdur7) 		;DURATION OF THIS NOTE

	;SINE TONE SIGNAL
	aAmpEnv	transeg	1,p3,-10,0.001				;AMPLITUDE ENVELOPE FOR SINE TONE SIGNAL
	afmod	expsega	5,0.125/ifrq,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE TONE MORE OF AN ATTACK.
	asig	oscili	-aAmpEnv*0.6,ifrq*afmod,gisine		;SINE TONE SIGNAL

	;NOISE SIGNAL
	aEnvNse	transeg	1,p3,-6,0.001				;AMPLITUDE ENVELOPE FOR NOISE SIGNAL
	anoise	dust2	0.4, 8000				;GENERATE NOISE SIGNAL
	anoise	reson	anoise,40*octave(gktune7),800,1		;BANDPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,100*octave(i(gktune7))		;HIGHPASS FILTER THE NOSIE SIGNAL
	anoise	butlp	anoise,600*octave(i(gktune7))		;LOWPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise * aEnvNse			;SCALE NOISE SIGNAL WITH AMPLITUDE ENVELOPE
	
	;MIX THE TWO SOUND COMPONENTS
	amix	=	(asig + anoise)*gklevel7*p4*gklevel
	aL,aR	pan2	amix,i(gkpan7)				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	108	;CYMBAL
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act8"                       ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	kFrq1	=	296*octave(gktune8) 	;FREQUENCIES OF THE 6 OSCILLATORS
	kFrq2	=	285*octave(gktune8)
	kFrq3	=	365*octave(gktune8)
	kFrq4	=	348*octave(gktune8)     
	kFrq5	=	420*octave(gktune8)
	kFrq6	=	835*octave(gktune8)
	p3	=	2*i(gkdur8)		;DURATION OF THE NOTE

	;SOUND CONSISTS OF 6 PULSE OSCILLATORS MIXED WITH A NOISE COMPONENT
	;PITCHED ELEMENT
	aenv	expon	1,p3,0.0001		;AMPLITUDE ENVELOPE FOR THE PULSE OSCILLATORS 
	ipw	=	0.25			;PULSE WIDTH      
	a1	vco2	0.5,kFrq1,2,ipw		;PULSE OSCILLATORS...  
	a2	vco2	0.5,kFrq2,2,ipw
	a3	vco2	0.5,kFrq3,2,ipw
	a4	vco2	0.5,kFrq4,2,ipw
	a5	vco2	0.5,kFrq5,2,ipw                                                                   
	a6	vco2	0.5,kFrq6,2,ipw
	amix	sum	a1,a2,a3,a4,a5,a6		;MIX THE PULSE OSCILLATORS
	amix	reson	amix,5000 *octave(gktune8),5000,1	;BANDPASS FILTER THE MIXTURE
	amix	buthp	amix,10000			;HIGHPASS FILTER THE SOUND
	amix	butlp	amix,12000			;LOWPASS FILTER THE SOUND...
	amix	butlp	amix,12000			;AND AGAIN...
	amix	=	amix*aenv			;APPLY THE AMPLITUDE ENVELOPE
	
	;NOISE ELEMENT
	anoise	noise	0.8,0				;GENERATE SOME WHITE NOISE
	aenv	expsega	1,0.3,0.07,p3-0.1,0.00001	;CREATE AN AMPLITUDE ENVELOPE
	kcf	expseg	14000,0.7,7000,p3-0.1,5000	;CREATE A CUTOFF FREQ. ENVELOPE
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE NOISE SIGNAL
	anoise	buthp	anoise,8000			;HIGHPASS FILTER THE NOISE SIGNAL
	anoise	=	anoise*aenv			;APPLY THE AMPLITUDE ENVELOPE            

	;MIX PULSE OSCILLATOR AND NOISE COMPONENTS
	amix	=	(amix+anoise)*gklevel8*p4*0.85*gklevel
	aL,aR	pan2	amix,i(gkpan8)			;PAN MONOPHONIC SIGNAL
		outs	aL,aR				;SEND TO OUTPUTS
endin

instr	109	;RIM SHOT
	xtratim	0.1
	iTR808RimShot	ftgenonce	0,0,1024,10,	0.971,0.269,0.041,0.054,0.011,0.013,0.08,0.0065,0.005,0.004,0.003,0.003,0.002,0.002,0.002,0.002,0.002,0.001,0.001,0.001,0.001,0.001,0.002,0.001,0.001	;WAVEFORM FOR TR808 RIMSHOT
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act9"                       ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	idur 	=	0.027*i(gkdur9) 		;NOTE DURATION
	p3	limit	idur,0.1,10			;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)

	;RING
	aenv1	expsega	1,idur,0.001,1,0.001		;AMPLITUDE ENVELOPE FOR SUSTAIN ELEMENT OF SOUND
	ifrq1	=	1700*octave(i(gktune9))		;FREQUENCY OF SUSTAIN ELEMENT OF SOUND
	aring	oscili	1,ifrq1,iTR808RimShot,0		;CREATE SUSTAIN ELEMENT OF SOUND	
	aring	butbp	aring,ifrq1,ifrq1*8	
	aring	=	aring*(aenv1-0.001)*0.5			;APPLY AMPLITUDE ENVELOPE

	;NOISE
	anoise	noise	1,0					;CREATE A NOISE SIGNAL
	aenv2	expsega	1, 0.002, 0.8, 0.005, 0.5, idur-0.002-0.005, 0.0001, 1, 0.0001	;CREATE AMPLITUDE ENVELOPE
	anoise	buthp	anoise,800			;HIGHPASS FILTER THE NOISE SOUND
	kcf	expseg	4000,p3,20				;CUTOFF FREQUENCY FUNCTION FOR LOWPASS FILTER
	anoise	butlp	anoise,kcf			;LOWPASS FILTER THE SOUND
	anoise	=	anoise*(aenv2-0.001)	;APPLY ENVELOPE TO NOISE SIGNAL

	;MIX
	amix	=	(aring+anoise)*gklevel9*p4*0.8*gklevel
	aL,aR	pan2	amix,gkpan9			;PAN MONOPHONIC SIGNAL  
		outs	aL,aR				;SEND TO OUTPUTS
endin

instr	110	;CLAVES
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act10"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq	=	2500*octave(i(gktune10))	;FREQUENCY OF OSCILLATOR
	idur	=	0.045 	* i(gkdur10)		;DURATION OF THE NOTE
	p3	limit	idur,0.1,10			;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)			
	aenv	expsega	1,idur,0.001,1,0.001		;AMPLITUDE ENVELOPE
	afmod	expsega	3,0.00005,1,1,1			;FREQUENCY MODULATION ENVELOPE. GIVES THE SOUND A LITTLE MORE ATTACK.
	asig	oscili	-(aenv-0.001),ifrq*afmod,gisine,0	;AUDIO OSCILLATOR
	asig	=	asig*0.4*gklevel10*p4*gklevel		;RESCALE AMPLITUDE
	aL,aR	pan2	asig,gkpan10			;PAN MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO OUTPUTS
endin

instr	111	;COWBELL
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act11"              	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq1	=	562 * octave(i(gktune11))	;FREQUENCIES OF THE TWO OSCILLATORS
	ifrq2	=	845 * octave(i(gktune11))	;
	ipw  	=	0.5 				;PULSE WIDTH OF THE OSCILLATOR	
	idur 	=	0.7 				;NOTE DURATION
	ishp 	=	-30 	
	idur 	=	0.7 				;NOTE DURATION
	p3	=	idur*i(gkdur11)			;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)
	ishape	=	-30				;SHAPE OF THE CURVES IN THE AMPLITUDE ENVELOPE
	kenv1	transeg	1,p3*0.3,ishape,0.2, p3*0.7,ishape,0.2	;FIRST AMPLITUDE ENVELOPE - PRINCIPALLY THE ATTACK OF THE NOTE
	kenv2	expon	1,p3,0.0005				;SECOND AMPLITUDE ENVELOPE - THE SUSTAIN PORTION OF THE NOTE
	kenv	=	kenv1*kenv2			;COMBINE THE TWO ENVELOPES
	itype	=	2				;WAVEFORM FOR VCO2 (2=PULSE)
	a1	vco2	0.65,ifrq1,itype,ipw		;CREATE THE TWO OSCILLATORS
	a2	vco2	0.65,ifrq2,itype,ipw
	amix	=	a1+a2				;MIX THE TWO OSCILLATORS 
	iLPF2	=	10000				;LOWPASS FILTER RESTING FREQUENCY
	kcf	expseg	12000,0.07,iLPF2,1,iLPF2	;LOWPASS FILTER CUTOFF FREQUENCY ENVELOPE
	alpf	butlp	amix,kcf			;LOWPASS FILTER THE MIX OF THE TWO OSCILLATORS (CREATE A NEW SIGNAL)
	abpf	reson	amix, ifrq2, 25			;BANDPASS FILTER THE MIX OF THE TWO OSCILLATORS (CREATE A NEW SIGNAL)
	amix	dcblock2	(abpf*0.06*kenv1)+(alpf*0.5)+(amix*0.9)	;MIX ALL SIGNALS AND BLOCK DC OFFSET
	amix	buthp	amix,700			;HIGHPASS FILTER THE MIX OF ALL SIGNALS
	amix	=	amix*0.07*kenv*p4*gklevel11*gklevel	;RESCALE AMPLITUDE
	aL,aR	pan2	amix,i(gkpan11)			;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO OUTPUTS
endin

instr	112	;CLAP
	;;xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act12"              	;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	iTimGap	=	0.01				;GAP BETWEEN EVENTS DURING ATTACK PORTION OF CLAP
	idur1  	=	0.02				;DURING OF THE THREE INITIAL 'CLAPS'
	idur2  	=	2*i(gkdur12)			;DURATION OF THE FOURTH, MAIN, CLAP
	idens  	=	8000				;DENSITY OF THE NOISE SIGNAL USED TO FORM THE CLAPS
	iamp1  	=	0.5				;AMPLITUDE OF AUDIO BEFORE BANDPASS FILTER IN OUTPUT
	iamp2  	=	1				;AMPLITUDE OF AUDIO AFTER BANDPASS FILTER IN OUTPUT
	if frac(p1)==0 then				;IF THIS IS THE INITIAL NOTE (p1 WILL BE AN INTEGER)
	 ;	        del.  dur  env.shape
	 event_i	"i", p1+0.1, 0,          idur1, p4	;CALL THIS INSTRUMENT 4 TIMES. ADD A FRACTION ONTO p1 TO BE ABLE TO DIFFERENTIATE THESE SUBSEQUENT NOTES
	 event_i	"i", p1+0.1, iTimGap,    idur1, p4
	 event_i	"i", p1+0.1, iTimGap*2,  idur1, p4
	 event_i	"i", p1+0.1, iTimGap*3,  idur2, p4
	else
	 kenv	transeg	1,p3,-25,0				;AMPLITUDE ENVELOPE
	 iamp	random	0.7,1					;SLIGHT RANDOMISATION OF AMPLITUDE	
	 anoise	dust2	kenv*iamp, idens			;CREATE NOISE SIGNAL
	
	 iBPF   	=	1100*octave(i(gktune12))	;FREQUENCY OF THE BANDPASS FILTER
	 ibw    	=	2000*octave(i(gktune12))	;BANDWIDTH OF THE BANDPASS FILTER
	 iHPF   	=	1000				;FREQUENCY OF A HIGHPASS FILTER
	 iLPF   	=	1				;SCALER FOR FREQUENCY OF A LOWPASS FILTER
	 kcf	expseg	8000,0.07,1700,1,800,2,500,1,500	;CREATE CUTOFF FREQUENCY ENVELOPE
	 asig	butlp	anoise,kcf*iLPF				;LOWPASS FILTER THE SOUND
	 asig	buthp	asig,iHPF				;HIGHPASS FILTER THE SOUND
	 ares	reson	asig,iBPF,ibw,1				;BANDPASS FILTER THE SOUND (CREATE A NEW SIGNAL)
	 asig	dcblock2	(asig*iamp1)+(ares*iamp2)	;MIX BANDPASS FILTERED AND NON-BANDPASS FILTERED SOUND ELEMENTS
	 asig	=	asig*p4*i(gklevel12)*1.75*gklevel	;SCALE AMPLITUDE
	 aL,aR	pan2	asig,i(gkpan12)				;PAN MONOPHONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
	endif
endin

instr	113	;MARACA
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act13"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	idur	=	0.07*i(gkdur13)				;DURATION 3
	p3	limit	idur,0.1,10				;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)
	iHPF 	limit	6000*octave(i(gktune13)),20,sr/2	;HIGHPASS FILTER FREQUENCY	
	iLPF 	limit	12000*octave(i(gktune13)),20,sr/3	;LOWPASS FILTER FREQUENCY. (LIMIT MAXIMUM TO PREVENT OUT OF RANGE VALUES)
	;AMPLITUDE ENVELOPE
	iBP1 	=	0.4					;BREAK-POINT 1
	iDur1	=	0.014*i(gkdur13) 			;DURATION 1
	iBP2 	=	1					;BREAKPOINT 2
	iDur2	=	0.01 *i(gkdur13)			;DURATION 2
	iBP3 	=	0.05 					;BREAKPOINT 3
	p3	limit	idur,0.1,10				;LIMIT THE MINIMUM DURATION OF THE NOTE (VERY SHORT NOTES CAN RESULT IN THE INDICATOR LIGHT ON-OFF NOTE BEING TO0 SHORT)
	aenv	expsega	iBP1,iDur1,iBP2,iDur2,iBP3		;CREATE AMPLITUDE ENVELOPE
	anoise	noise	0.75,0					;CREATE A NOISE SIGNAL
	anoise	buthp	anoise,iHPF				;HIGHPASS FILTER THE SOUND
	anoise	butlp	anoise,iLPF				;LOWPASS FILTER THE SOUND
	anoise	=	anoise*aenv*p4*gklevel13*gklevel	;SCALE THE AMPLITUDE
	aL,aR	pan2	anoise,i(gkpan13)			;PAN THE MONOPONIC SIGNAL
		outs	aL,aR					;SEND AUDIO TO OUTPUTS
endin

instr	114	;HIGH CONGA
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act14"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq  	=	420*octave(i(gktune14))		;FREQUENCY OF NOTE
	p3  	=	0.22*i(gkdur14)			;DURATION OF NOTE
	aenv	transeg	0.7,1/ifrq,1,1,p3,-6,0.001	;AMPLITUDE ENVELOPE
	afrq	expsega	ifrq*3,0.25/ifrq,ifrq,1,ifrq	;FREQUENCY ENVELOPE (CREATE A SHARPER ATTACK)
	asig	oscili	-aenv*0.25,afrq,gisine		;CREATE THE AUDIO OSCILLATOR
	asig	=	asig*p4*gklevel14*gklevel	;SCALE THE AMPLITUDE
	aL,aR	pan2	asig,gkpan14			;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO THE OUTPUTS
endin

instr	115	;MID CONGA
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act15"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq   	=	310*octave(i(gktune15))		;FREQUENCY OF NOTE
	p3   	=	0.33*i(gkdur15)			;DURATION OF NOTE
	aenv	transeg	0.7,1/ifrq,1,1,p3,-6,0.001	;AMPLITUDE ENVELOPE	
	afrq	expsega	ifrq*3,0.25/ifrq,ifrq,1,ifrq	;FREQUENCY ENVELOPE (CREATE A SHARPER ATTACK)
	asig	oscili	-aenv*0.25,afrq,gisine		;CREATE THE AUDIO OSCILLATOR
	asig	=	asig*p4*gklevel15*gklevel		;SCALE THE AMPLITUDE
	aL,aR	pan2	asig,gkpan15			;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO THE OUTPUTS
endin

instr	116	;LOW CONGA
	xtratim	0.1
	krelease	release				;SENSE RELEASE OF THIS NOTE ('1' WHEN RELEASED, OTHERWISE ZERO)   
	chnset	1-krelease,"Act16"                      ;TURN ON ACTIVE LIGHT WHEN NOTE STARTS, TURN IT OFF WHEN NOTE ENDS
	ifrq   	=	227*octave(i(gktune16))		;FREQUENCY OF NOTE
	p3   	=	0.41*i(gkdur16)			;DURATION OF NOTE 	
	aenv	transeg	0.7,1/ifrq,1,1,p3,-6,0.001	;AMPLITUDE ENVELOPE	
	afrq	expsega	ifrq*3,0.25/ifrq,ifrq,1,ifrq	;FREQUENCY ENVELOPE (CREATE A SHARPER ATTACK)
	asig	oscili	-aenv*0.25,afrq,gisine		;CREATE THE AUDIO OSCILLATOR
	asig	=	asig*p4*gklevel16*gklevel	;SCALE THE AMPLITUDE
	aL,aR	pan2	asig,gkpan16			;PAN THE MONOPHONIC AUDIO SIGNAL
		outs	aL,aR				;SEND AUDIO TO THE OUTPUTS
endin

</CsInstruments>

<CsScore>
f 0 [3600*24*7]
i 1 0 [3600*24*7]
</CsScore>

</CsoundSynthesizer>
Dust.csd
Written by Iain McCurdy, 2013.

A simple encapsulation of the 'dust' opcode.
Added features are stereo panning (spread) of the dust, a random tonal variation (lowpass filter with jumping cutoff frequency) and constant low and highpass filters.


<Cabbage>
form caption("Dust"), size(410, 10), pluginid("dust") style("legacy")
image    bounds(  0,  0,410, 80), colour(155, 50, 50), shape("sharp"), outlinecolour("white"), outlinethickness(2) 
checkbox bounds( 10, 10, 80, 15), text("On/Off"), channel("onoff"), value(0), fontcolour("white")
rslider  bounds( 70, 10, 60, 60), text("Amplitude"), channel("amp"),     range(0, 1.00, 0.5, 0.5, 0.001),   textcolour("white"), colour(105, 20, 20), outlinecolour(155,100,100), trackercolour(220,160,160)
rslider  bounds(125, 10, 60, 60), text("Freq."),     channel("freq"),    range(0.1, 20000, 500, 0.5, 0.01), textcolour("white"), colour(105, 20, 20), outlinecolour(155,100,100), trackercolour(220,160,160)
rslider  bounds(180, 10, 60, 60), text("Spread"),    channel("spread"),  range(0, 1.00, 1),                 textcolour("white"), colour(105, 20, 20), outlinecolour(155,100,100), trackercolour(220,160,160)
rslider  bounds(235, 10, 60, 60), text("Tone Var."), channel("ToneVar"), range(0, 1.00, 0),                 textcolour("white"), colour(105, 20, 20), outlinecolour(155,100,100), trackercolour(220,160,160)
rslider  bounds(290, 10, 60, 60), text("Lowpass"),   channel("LPF"),     range(20,20000,20000,0.5),         textcolour("white"), colour(105, 20, 20), outlinecolour(155,100,100), trackercolour(220,160,160)
rslider  bounds(345, 10, 60, 60), text("Highpass"),  channel("HPF"),     range(20,20000,20,0.5),            textcolour("white"), colour(105, 20, 20), outlinecolour(155,100,100), trackercolour(220,160,160)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE
massign	0,0

instr	1
	konoff	chnget	"onoff"		;read in on/off switch widget value
	if konoff==0 goto SKIP		;if on/off switch is off jump to 'SKIP' label
	kamp	chnget	"amp"
	kfreq	chnget	"freq"
	kspread	chnget	"spread"
	asig	dust2	kamp, kfreq	;GENERATE 'dust2' IMPULSES

	; tone variation
	kToneVar	chnget	"ToneVar"
	if(kToneVar>0) then
 	 kcfoct	random		14-(kToneVar*10),14
	 asig	tonex		asig,cpsoct(kcfoct),1
	endif

	kpan	random	0.5-(kspread*0.5), 0.5+(kspread*0.5)
	asigL,asigR	pan2	asig,kpan

	kporttime	linseg	0,0.001,0.05

	; Lowpass Filter
	kLPF	chnget	"LPF"
	if kLPF<20000 then
	 kLPF	portk	kLPF,kporttime
	 asigL	clfilt	asigL,kLPF,0,2
	 asigR	clfilt	asigR,kLPF,0,2
	endif
	
	; Highpass Filter
	kHPF	chnget	"HPF"
	if kHPF>20 then
	 kHPF	limit	kHPF,20,kLPF
	 kHPF	portk	kHPF,kporttime
	 asigL	clfilt	asigL,kHPF,1,2
	 asigR	clfilt	asigR,kHPF,1,2
	endif

		outs	asigL,asigR	;SEND AUDIO SIGNAL TO OUTPUT
	SKIP:				;A label. Skip to here is on/off switch is off 
endin


</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]	;instrument that reads in widget data
</CsScore>

</CsoundSynthesizer>; FractalNoise.csd
; Written by Iain McCurdy, 2015

; GUI colour indicates noise type: 'white' - 'pink' - 'brown'

<Cabbage>
form caption("Fractal Noise"), size(290,275), pluginid("fnse"), guirefresh(32) style("legacy")
image bounds(  0,  0,290,275), colour("white"), shape("sharp"), , identchannel(BackgroundColour)
checkbox bounds( 20, 10, 15, 15), channel("onoff"), value(0), fontcolour("black"), colour("yellow")
label    bounds( 37, 11, 50, 13), text("On/Off"), fontcolour(30,30,30), identchannel("label1")
rslider  bounds(100, 10, 50, 50), channel("amp"),     range(0, 2, 0.2, 0.5, 0.001), textcolour("black"), trackercolour("yellow"), colour(30,30,30)
label    bounds(100, 60, 50, 13), text("Amp."), fontcolour(30,30,30), identchannel("label2")
rslider  bounds(160, 10, 50, 50), channel("beta"),    range(-2, 5, 0, 1, 0.001),    textcolour("black"), trackercolour("yellow"), colour(30,30,30)
label    bounds(160, 60, 50, 13), text("Beta"), fontcolour(30,30,30), identchannel("label3")
rslider  bounds(220, 10, 50, 50), channel("width"),   range(0,0.05, 0, 0.5, 0.0001),    textcolour("black"), trackercolour("yellow"), colour(30,30,30)
label    bounds(220, 60, 50, 13), text("Width"), fontcolour(30,30,30), identchannel("label4")
gentable bounds(  5, 85 ,280, 90), tablenumber(10), amprange(-1,1,1), identchannel("table"),zoom(-1)
label    bounds(  7, 85, 100, 11), text("Amp.Waveform"), fontcolour(255,255,255,150), align(left)
gentable bounds(  5,180 ,280, 90), tablenumber(11), identchannel("FFT"), amprange(0,1,-1), outlinethickness(0), samplerange(0, 128), tablecolour("yellow"), zoom(-1)
label    bounds(  7,180, 100, 11), text("FFT Spectrum"), fontcolour(255,255,255,150), align(left)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	16
nchnls 		= 	2
0dbfs		=	1

ginoise		ftgen	10,0,128,10,1
giFFT		ftgen	11,0,256,10,1

giFracScal	ftgen	1,0,-700,-27, 0,1.1, 100,1.1, 200,1.1, 300,0.42, 400,0.08, 500,0.008, 600,0.001, 700,0.0002 
;			              white    white     pink     brown     black
giR		ftgen	2,0,-700,-27,  0,255, 200,255,  300,255, 400,80,   700,1 
giG		ftgen	3,0,-700,-27,  0,255, 200,255,  300,130, 400,40,   700,1 
giB		ftgen	4,0,-700,-27,  0,255, 200,255,  300,130, 400,0 ,   700,1 



instr	1
	konoff	chnget	"onoff"		;read in on/off switch widget value
	kamp		chnget	"amp"
	kamp		port	kamp,0.01
	kbeta		chnget	"beta"
	kbeta		port	kbeta,0.1
	kbeta		init	0
	kwidth		chnget	"width"
	kwidth		portk	kwidth,0.05
	kscal		table	(kbeta+2)/7,giFracScal,1
	aL	fractalnoise	kscal*0.5*konoff, kbeta
	if kwidth>0.0001 then
	 aR	vdelay		aL,kwidth*1000,100
	else
	 aR	=	aL
	endif
		outs	aL*kamp, aR*kamp

	kptr	init	0
		tabw k(aL), kptr, 10
	kptr	=	(kptr + 1) % 128

	if metro(16)==1 then
	 if changed(kbeta)==1 then
	  kR	tab	(kbeta+2)/7,giR,1
	  kG	tab	(kbeta+2)/7,giG,1
	  kB	tab	(kbeta+2)/7,giB,1
	  kR	init	255
	  kG	init	255
	  kB	init	255
	  Smsg	sprintfk	"colour(%d,%d,%d)",kR,kG,kB
	  	chnset		Smsg,"BackgroundColour"
	 endif

		chnset	"tablenumbers(10)","table"

	endif

	
	kFlickOn	trigger	kbeta,2,0
	kFlickOff	trigger	kbeta,2,1
	if kFlickOn==1 then
	  	chnset		"fontcolour(255,255,255)","label1"
	  	chnset		"fontcolour(255,255,255)","label2"
	  	chnset		"fontcolour(255,255,255)","label3"
	  	chnset		"fontcolour(255,255,255)","label4"
	elseif kFlickOff==1 then
	  	chnset		"fontcolour(0,0,0)","label1"
	  	chnset		"fontcolour(0,0,0)","label2"
	  	chnset		"fontcolour(0,0,0)","label3"
	  	chnset		"fontcolour(0,0,0)","label4"
	endif
	
	fsig	pvsanal	aL*3, 256,64,256,1
  	kflag	pvsftw fsig, 11
 	if kflag==1 then
 	 chnset	"tablenumber(11)", "FFT"
 	endif

endin


</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]	;instrument that reads in widget data
</CsScore>

</CsoundSynthesizer>GaussianDust.csd
Iain McCurdy [2013]

A simple encapsulation of the 'gausstrig' opcode.
Added features are stereo panning (spread) of the dust, a random tonal variation (lowpass filter with jumping cutoff frequency) and constant low and highpass filters.

<Cabbage>
form caption("Gaussian Dust"), size(490, 350), pluginid("gaus") style("legacy")
image                  bounds(0, 0, 490, 350), colour("DarkSlateGrey"), shape("sharp"), outlinecolour("white"), outlinethickness(4) 
checkbox bounds( 15, 10, 80, 15), text("On/Off"), channel("onoff"), value(1), fontcolour("white")
combobox bounds( 10, 40, 70, 20), channel("mode"), value(2), text("Held", "Reinit")
xypad bounds(  5, 78, 240, 260), text("Freq./Deviation"), channel("freq", "dev"), rangex(0.1, 10000, 10), rangey(0, 10.00, 0)
xypad bounds(245, 78, 240, 260), text("LPF./HPF."), channel("LPF", "HPF"), rangex(20, 20000, 20000), rangey(20, 20000,20)

rslider  bounds(90, 10, 60, 60),  text("Amplitude"), channel("amp"),     range(0, 1, 0.5, 0.5, 0.001),      fontcolour("white"), colour(50,60,70), trackercolour(150,160,170), outlinecolour("SlateGrey")
rslider  bounds(150, 10, 60, 60), text("Freq."),     channel("freq"),    range(0.1, 10000, 10, 0.25, 0.01), fontcolour("white"), colour(50,60,70), trackercolour(150,160,170), outlinecolour("SlateGrey")
rslider  bounds(205, 10, 60, 60), text("Deviation"), channel("dev"),     range(0, 10, 1),                   fontcolour("white"), colour(50,60,70), trackercolour(150,160,170), outlinecolour("SlateGrey")
rslider  bounds(260, 10, 60, 60), text("Spread"),    channel("spread"),  range(0, 1, 1),                    fontcolour("white"), colour(50,60,70), trackercolour(150,160,170), outlinecolour("SlateGrey")
rslider  bounds(315, 10, 60, 60), text("Tone Var."), channel("ToneVar"), range(0, 1.00, 0),                 fontcolour("white"), colour(50,60,70), trackercolour(150,160,170), outlinecolour("SlateGrey")
rslider  bounds(370, 10, 60, 60), text("Lowpass"),   channel("LPF"),     range(20,20000,20000,0.5),         fontcolour("white"), colour(50,60,70), trackercolour(150,160,170), outlinecolour("SlateGrey")
rslider  bounds(425, 10, 60, 60), text("Highpass"),  channel("HPF"),     range(20,20000,20,0.5),            fontcolour("white"), colour(50,60,70), trackercolour(150,160,170), outlinecolour("SlateGrey")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1

instr	1
	konoff	chnget	"onoff"		;read in on/off switch widget value
	if konoff==0 goto SKIP		;if on/off switch is off jump to skip label
	kamp	chnget	"amp"
	kfreq	chnget	"freq"
	kdev	chnget	"dev"
	kporttime	linseg	0,0.01,0.1
	kdev	portk	kdev,kporttime
	kmode	chnget	"mode"
	kmode	=	kmode - 1
	kspread	chnget	"spread"
	ktrig	changed		kmode		;IF gkmode COUNTER IS CHANGED GENERATE A MOMENTARY '1' IMPULSE
	if ktrig==1 then			;THEREFORE IF gkmode HAS BEEN CHANGED...
	 reinit	UPDATE				;BEGIN A REINITIALISATION PASS AT LABEL 'UPDATE'
	endif					;END OF CONDITIONAL BRANCH
	UPDATE:					;LABEL 'UPDATE'. REINITIALISATION BEGINS FROM HERE.
	asig	gausstrig	kamp, kfreq, kdev, i(kmode), 1	;GENERATE GAUSSIAN TRIGGERS
	kpan	random	0.5-(kspread*0.5), 0.5+(kspread*0.5)
	asigL,asigR	pan2	asig,kpan
	rireturn				;RETURN FROM REINITIALISATION PASS


	; tone variation
	kToneVar	chnget	"ToneVar"
	if(kToneVar>0) then
 	 kcfoct	random		14-(kToneVar*10),14
	 asig	tonex		asig,cpsoct(kcfoct),1
	endif

	kpan	random	0.5-(kspread*0.5), 0.5+(kspread*0.5)
	asigL,asigR	pan2	asig,kpan

	kporttime	linseg	0,0.001,0.05

	; Lowpass Filter
	kLPF	chnget	"LPF"
	if kLPF<20000 then
	 kLPF	portk	kLPF,kporttime
	 asigL	clfilt	asigL,kLPF,0,2
	 asigR	clfilt	asigR,kLPF,0,2
	endif
	
	; Highpass Filter
	kHPF	chnget	"HPF"
	if kHPF>20 then
	 kHPF	limit	kHPF,20,kLPF
	 kHPF	portk	kHPF,kporttime
	 asigL	clfilt	asigL,kHPF,1,2
	 asigR	clfilt	asigR,kHPF,1,2
	endif

		outs	asigL,asigR		;SEND AUDIO SIGNAL TO OUTPUT
	SKIP:					;A label. Skip to here is on/off switch is off 
endin


</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]	;instrument plays for a week
</CsScore>

</CsoundSynthesizer>; PinkNoise.csd
; Written by Iain McCurdy, 2012

<Cabbage>
form caption("Pink Noise"), size(230, 80), pluginid("pnse") style("legacy")
image bounds(  0,  0,230, 80), colour("pink"), shape("rounded"), outlinecolour("red"), outlinethickness(4) 
checkbox bounds( 20, 10, 80, 15), text("On/Off"), channel("onoff"), value(0), fontcolour("black"), colour("yellow")
combobox bounds( 20, 40, 70, 20), channel("method"), value(1), text("Gardner", "Kellet", "Kellet 2")
rslider  bounds(100, 10, 60, 60), text("Amplitude"), channel("amp"),      range(0, 1, 0.5, 0.5, 0.001), textcolour("black"), trackercolour(255,100,100), colour(255,100,100)
rslider  bounds(160, 10, 60, 60), text("N.Bands"),   channel("numbands"), range(4, 32, 20, 1, 1),       textcolour("black"), trackercolour(255,100,100), colour(255,100,100)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE
massign	0,0

instr	1
	konoff	chnget	"onoff"		;read in on/off switch widget value
	if konoff==0 goto SKIP		;if on/off switch is off jump to skip label
	kmethod		chnget	"method"
	kmethod	=	kmethod - 1
	knumbands	chnget	"numbands"
	kamp		chnget	"amp"
	ktrig	changed	kmethod, knumbands				;GENERATE BANG (A MOMENTARY '1') IF ANY OF THE INPUT VARIABLES CHANGE
	if ktrig==1 then						;IF AN I-RATE VARIABLE HAS CHANGED
	 reinit UPDATE							;BEGIN A REINITIALISATION PASS FROM LABEL 'UPDATE'
	endif								;END OF CONDITIONAL BRANCH
	UPDATE:								;LABEL CALLED 'UPDATE'
	if kmethod=0 then						;IF GARDNER METHOD HAS BEEN CHOSEN...
		asigL	pinkish	kamp, i(kmethod), i(knumbands)		;GENERATE PINK NOISE
		asigR	pinkish	kamp, i(kmethod), i(knumbands)		;GENERATE PINK NOISE
	else								;OTHERWISE (I.E. 2ND OR 3RD METHOD HAS BEEN CHOSEN)
		anoise	unirand	2					;WHITE NOISE BETWEEN ZERO AND 2
		anoise	=	(anoise-1)				;OFFSET TO RANGE BETWEEN -1 AND 1
		asigL	pinkish anoise, i(kmethod)   			;GENERATE PINK NOISE
		asigR	pinkish anoise, i(kmethod)   			;GENERATE PINK NOISE
		asigL	=	asigL * kamp				;RESCALE AMPLITUDE WITH gkpinkamp
		asigR	=	asigR * kamp				;RESCALE AMPLITUDE WITH gkpinkamp
	endif								;END OF CONDITIONAL
	rireturn							;RETURN FROM REINITIALISATION PASS
		outs	asigL,asigR	;SEND AUDIO SIGNAL TO OUTPUT
	SKIP:				;A label. Skip to here is on/off switch is off 
endin


</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]	;instrument that reads in widget data
</CsScore>

</CsoundSynthesizer><Cabbage>
form caption("White Noise"), size(230, 90), pluginid("wnse") style("legacy")
image bounds(  0,  0,230, 90), colour("white"), shape("rounded"), outlinecolour("black"), outlinethickness(4) 
checkbox bounds( 20, 10, 80, 15), text("On/Off"), channel("onoff"), value(0), fontcolour("black")
rslider  bounds( 80, 10, 70, 70), text("Amplitude"), channel("amp"),  outlinecolour("DarkGrey"), colour("black"), range(0, 1, 0.1, 0.5, 0.001),   textcolour("black"), trackercolour("grey")
rslider  bounds(150, 10, 70, 70), text("Beta"),      channel("beta"), outlinecolour("DarkGrey"), colour("black"), range(-0.999, 0.999,0,1,0.001), textcolour("black"), trackercolour("grey")
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE
massign	0,0

instr	1
	kporttime	linseg	0,0.001,0.05
	konoff	chnget	"onoff"		;read in on/off switch widget value
	if konoff==0 goto SKIP		;if on/off switch is off jump to skip label
	kamp	chnget	"amp"		;read in widgets...
	kamp	portk	kamp,kporttime
	kbeta	chnget	"beta"		;
	asigL 	noise 	kamp, kbeta	;GENERATE WHITE NOISE
	asigR 	noise 	kamp, kbeta	;GENERATE WHITE NOISE
		outs	asigL,asigR	;SEND AUDIO SIGNAL TO OUTPUT
	SKIP:				;A label. Skip to here is on/off switch is off 
endin


</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]	;instrument that reads in widget data
</CsScore>

</CsoundSynthesizer>; BarModel.csd
; Original physical model code by Stefan Bilbao, ported to Csound by John ffitch
; Example written by Iain McCurdy, 2015
; 
; Uses barmodel physical model of a struck bar
; Note that some tuning anomalies may exist. These are due to rounding errors in the algorithm and are largely unresolvable.
; On account of this instrument being based upon a fairly complex physical modelling algorithm, it will be unreasonable 
; to expect massive polyphony in realtime. For this reason a polyphony control mechanism is implemented to provide a means 
; to prevent underruns in realtime performance.

; CONTROLS:
; ---------
; Boundary Conditions	-	this combobox selection determines the nature of how the bar is fixed at either end 
; 				(clamped/pivoting/free)
; 				For simplification and safety, only the valid options are offered.
; 				Nonetheless care must be taken is if 'Clamped-Free' is chosen: if 'Decay' and 'Damping' 
; 				are high in combination with this choice this can lead to the fundemental building in 
; 				amplitude dangerously.
;                               The boundary conditions in general affect how stretched out the partials become, the partials
;                               are most compressed with clamped-free, next is clamped-pivoted, next clamped-clamped and finally
;                               the partials are most stretched out if pivoted-pivoted is chosen. It is also interesting to
;                               note that with a clamped-free bar model, an additional partial beneath the fundemental
;                               emerges somewhere around E3 and above. This sub-partial is roughly 2 octaves + a minor 6th
;                               below the fundemental.
;				When 'Clamped-Free' is selected the fundemental partial is unaffected by 'Damping'. 
; Keyboard Scaling  -    when active, damping, attack time, decay time and release times are influenced by the note played 
;                           with higher notes attacking and decaying quicker, and therefore reflecting real-world physics.
; Decay			-	This is the time it will take for the amplitude to decay by 30dB from its initial level.
; HOLD (button)		-	If this is active, the value for decay will be a large number and the value of the slider will be ignored. 
;				This feature can be used to create 'sustained' notes but bear in mind that a note's ability
;				to sustain will also be dependent upon the value of 'Damping'. For a sustaining timbre, 
;				'Damping' should be zero.
; Release		-	Amplitude release time once a note is released. (This can be over-ridden if polyphony limit is exceeded.
; Damping		-	High frequency damping. Larger value imply increased damping. A value of zero implies no damping.
; Polyphony		-	Polyphony limit. If this is exceeded (including notes in their release stage) 
; 				then the oldest note will be removed quickly. Amplitudes will be ramped to prevent clicks
; 				upon note removal. If zero, this mechanism is bypassed and polyphony is not limited.
; Width			-	Width of strike. Higher notes may demand a higher value for 'Width'. 
;				Higher values for Width will also result in a 'darker' tone being produced.
;				On account of the amplitude level changes that will result from changing this parameter, it should be used in conjunction with the 'Level' control.
; Attack:Time		-	Duration of the attack envelope. If zero, this envelope is bypassed.
; Attack:Amount		-	Amount of attack envelope to be applied. Basically the initial value of the attack envelope before ramping up to '1'.
; 				This envelope affects both amplitude and tone (LPF) 
; Presets		-	Some hard-wired presets to help the user get orientated. 
; Reverb:Mix		-	Dry/Wet reverb mix (100% dry - 100% wet). If mix is zero the reverb is bypassed to improve efficiency and to remove the need for an on/off switch. 
; Reverb:Size		-	Reverb size
; Level			-	Output amplitude level
; 
; Velocity Mappings: how note velocity maps to various parameters. 
; Velocity is on the x-axis, low velocitys (left hand side of the graph) being on the left side of the graph.
; Click and drag on the graphs. These should normally be single straight line graphs.
; ----------------------------------------------------------------------------------------------------------------------------------------------------
; Strike Position	-	how velocity maps to strike position across the length of the bar
; 				Note that for some Boundary Condition setting it may be more appropriate to limit the range of this graph 
; 				from zero to 0.5 (or from 0.5 to 1).
; 				For a fixed strike position, design this graph as horizontal line.
; Tone			-	velocity to tone (LPF)
; Amplitude		-	velocity to amplitude
; 
; Modulation: modulation of the scanning position of the bar. This produces spectral variation.
; ---------------------------------------------------------------------------------------------
; Mix	-	mix between an unmodulated and a modulated barmodel.
; 		Note that if this value is anything other than zero or '1' then each note played will activate 2 instances 
; 		of the barmodel opcode, effectively doubling the CPU draw.
; Rate	-	Rate of modulation. This is a fixed value (in hertz) but the rate of modulation can also be influenced 
; 		by an envelope and splinic random variation.
; x 100 (button)	-	If this button is active the value of the 'Rate' slider will be multiplied by 100. 
;				Note that very fast scanning position modulations will result in quantisation artefacts being produced.
; Envelope	-	An envelope which influences modulation rate. It will be multiplied to the value of 'Rate'.
; Duration	-	The time it will take for the above mentioned envelope to complete.
; Random:Amount	-	Amount of random splinic modulation. This function will be added to 'Rate' and 'Envelope'.
; Random:Rate	-	Rate of random splinic modulation.
; Panning	-	Width of panning modulation. The shape of this modulation will follow that of the scanning modulation.
;			To remove all modulation from the sound produced bring this slider to to zero as well as the 'Mix' slider.


<Cabbage>
form caption("Bar Model"), size(955,340), pluginid("BaMo"), colour(0,0,0), guirefresh(128) style("legacy")
label     bounds( 10, 15,150, 15), text("Boundary Conditions")
combobox  bounds( 10, 32,150, 20), channel("bc"), value(2), text("Clamped-Clamped","Clamped-Pivoted","Pivoted-Pivoted","Clamped-Free")
checkbox  bounds( 10, 70,150, 15), channel("KybdScal"), text("Keyboard Scaling") value(0)
rslider   bounds(160,  5, 80, 80), text("Decay"), channel("T30"), valuetextbox(1), textbox(1), range(0.01,30,5.5,0.5,0.01), trackercolour("yellow")
button    bounds(175, 90, 50, 15), text("HOLD","HOLD"), channel("T30_Hold"), fontcolour:0(30,30,30), fontcolour:1(255,255,100)
rslider   bounds(220,  5, 80, 80), text("Release"), channel("rel"), valuetextbox(1), textbox(1), range(0.01,30,5.5,0.5,0.01), trackercolour("yellow")
rslider   bounds(280,  5, 80, 80), text("Damping"), channel("b"), valuetextbox(1), textbox(1), range(0, 9.999,0.4,0.5,0.001), trackercolour("yellow")
rslider   bounds(350,  5, 80, 80), text("Polyphony"), channel("PolyLimit"), valuetextbox(1), textbox(1), range(0, 20,5,1,1), trackercolour("yellow")
;rslider   bounds(420,  5, 80, 80), text(""), channel(""), valuetextbox(1), range(0, 1,0.5,1,0.001), trackercolour("yellow")
rslider   bounds(420,  5, 80, 80), text("Width"), channel("wid"), valuetextbox(1), textbox(1), range(0.01, 1,0.5,1,0.01), trackercolour("yellow")
;line      bounds(505, 15, 90,  1)
image     bounds(505, 15, 90,  1), colour(30,30,30), identchannel("AttackLine")
label     bounds(525,  9, 50, 12), text("Attack"), colour(0,0,0), fontcolour(30,30,30), identchannel("AttackLabel")
rslider   bounds(490, 25, 61, 61), text("Time"), channel("AttTim"), range(0,3,0,0.5,0.001), trackercolour("yellow")
rslider   bounds(550, 25, 61, 61), text("Amount"), channel("AttAmt"), range(0, 1, 0,1,0.001), trackercolour("yellow")
label     bounds(615, 15,150, 15), text("Presets")
combobox  bounds(615, 32,140, 20), channel("preset"), value(1), text("Xylobar","Scan Envelope","Soft Sustain","Rhodes","Good Vibes","Bad Vibes","Hard Beater","Stacking Plates","Bowed Plank","Interference","Ride Cymbal","Tubular Bell", "Discord Bar")
;line      bounds(775, 15, 90,  1)
image     bounds(775, 15, 90,  1), colour(30,30,30), identchannel("ReverbLine")
label     bounds(795,  9, 50, 12), text("Reverb"), colour(0,0,0), fontcolour(30,30,30), identchannel("ReverbLabel")
rslider   bounds(760, 25, 61, 61), text("Mix"), channel("RvbMix"), range(0, 1, 0,1,0.01), trackercolour("yellow")
rslider   bounds(820, 25, 61, 61), text("Size"), channel("RvbSize"), range(0.5,0.99,0.8,1,0.01), trackercolour("yellow")
rslider   bounds(870,  5, 80, 80), text("Level"), channel("OutAmp"), valuetextbox(1), textbox(1), range(0,9.999,0.8,0.5,0.001), trackercolour("yellow")

groupbox  bounds(  5,115,400,140), text("Velocity Mappings"), colour(0,0,0,60), shape("sharp"), plant("VelocityMappings"){
label     bounds(  5, 25,120, 10), text("Strike Position")
gentable  bounds(  5, 37,120, 90), tablenumber(2), identchannel(table2), amprange(0,1,2), zoom(-1), tablecolour(turquoise), active(1), fill(0)
label     bounds(135, 25,120, 10), text("Tone")
gentable  bounds(135, 37,120, 90), tablenumber(3), identchannel(table3), amprange(0,1,3), zoom(-1), tablecolour(turquoise), active(1), fill(0)
label     bounds(265, 25,120, 10), text("Amplitude")
gentable  bounds(265, 37,120, 90), tablenumber(4), identchannel(table4), amprange(0.01,1,4), zoom(-1), tablecolour(turquoise), active(1), fill(0)
}

; MODULATION
groupbox  bounds(410,115,540,140), text("Modulation"), colour(0,0,0,60), shape("sharp"), plant("modulation"){
rslider   bounds(  5, 25, 80, 80), text("Mix"), channel("ScanMix"), valuetextbox(1), textbox(1), range(0, 1, 0,1,0.001), trackercolour("yellow")
rslider   bounds( 65, 25, 80, 80), text("Rate"), channel("scan"), valuetextbox(1), textbox(1), range(0, 1, 0.1,0.5,0.001), trackercolour("yellow")
button    bounds( 80,110, 50, 15), text("x 100","x 100"), channel("scan_x100"), fontcolour:0(30,30,30), fontcolour:1(255,255,100)
label     bounds(150, 25,120, 10), text("Envelope")
gentable  bounds(150, 37,120, 90), tablenumber(5), identchannel(table5), amprange(0.01,2,-1), zoom(-1), tablecolour(yellow), active(1), fill(0)
rslider   bounds(280, 25, 80, 80), text("Duration"), channel("ModEnvDur"), valuetextbox(1), textbox(1), range(0.1, 10, 1,0.5,0.01), trackercolour("yellow")
line      bounds(365, 35, 90,  1)
label     bounds(385, 29, 50, 12), text("Random"), colour(0,0,0)
rslider   bounds(350, 45, 61, 61), text("Amount"), channel("RndModAmt"), range(0, 1, 0,1,0.001), trackercolour("yellow")
rslider   bounds(410, 45, 61, 61), text("Rate"), channel("RndModRte"), range(0.01,10,0.1,0.5,0.001), trackercolour("yellow")
rslider   bounds(460, 25, 80, 80), text("Panning"), channel("PanDepth"), valuetextbox(1), textbox(1), range(0, 0.5, 0,1,0.001), trackercolour("yellow")
label bounds(440, 120,98,10),text("Iain McCurdy 2015")
}

keyboard bounds(4, 254, 945, 80) mouseoeverkeycolour(255, 255, 0, 128) 

;;TUNING
;image     bounds(  0,350,955,170), plant("tuning"), colour(0,0,0,0) {
;nslider bounds(  0, 15,160, 70), caption("Note Number"), channel("note"), range(0,128,0,1,1)
;nslider bounds(260, 15,160, 70), caption("Output"), channel("output"), range(0,8000,0,1,0.001)
;button    bounds(160,  0,100, 15), text("ZERO","ZERO"), channel("ZeroOffset"), fontcolour:0(30,30,30), fontcolour:1(255,255,100), latched(0)
;nslider bounds(160, 15,100, 70), caption("Offset"), channel("offset"), range(-100,100,0,1,0.01)
;checkbox  bounds(425, 15,100, 20), text("Test Tone"), channel("TestTone"), value(0)
;hslider   bounds(425, 40,120, 15), channel("TestVol"), range(0, 0.2, 0.05, 0.5,0.001), trackercolour("yellow")
;csoundoutput bounds(545,0,400,170)
;}
</Cabbage>
                    
<CsoundSynthesizer>

<CsOptions>   
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	4
nchnls 		= 	2
0dbfs		=	1

massign	0,2

; MAPPING FUNCTIONS: NOTE->STIFFNESS (C="CLAMPED" P="PIVOTING" F="FREE")
giCC	ftgen	0, 0, 128, -17, 0,5.887,			17,5.887,	18,6.236,	19,6.593,	20,7.01,	21,7.421,	22,7.8,		23,8.223,	24,8.773,	25,9.282,	26,9.736,	27,10.4013,	28,10.993,	29,11.52,	30,12.298,	31,12.795,	32,13.77,	33,14.57,	34,15.27,	35,16.297,	36,17.142,	37,18.21,	38,19.2,	39,20.41,	40,21.53,	41,22.710,	42,24.11,	43,25.382,	44,26.938,	45,28.385,	46,30.04,	47,31.937,	48,33.182,	49,35.13,	50,37.574,	51,39.418,	52,42.06,	53,43.962,	54,46.598,	55,49.301,	56,52.274,	57,55.16,	58,58.325,	59,61.089,	60,64.91,	61,68.63,	62,72.491,	63,76.2975,	64,80.792,	65,84.786,	66,90.089,	67,95.632,	68,99.023,	69,104.895,	70,110.928,	71,116.307,	72,122.731,	73,130.473,	74,137.982,	75,145.78,	76,153.124,	77,161.277,	78,171.217,	79,180.8015,	80,186.41,	81,198.914,	82,210.724,	83,220.499,	84,230.52,	85,244.06,	86,258.55,	87,271.361,	88,280.53,	89,297.311,	90,318.36,	91,333.471,	92,344.54,	93,358.38,	94,379.586,	95,401.92,	96,425.373,	97,449.656,	98,450,		99,473.94,	100,505.217,	101,534.021,	102,565.833,	103,599.109,	104,612.474,	105,620.586,	106,655,	107,692.93,	108,732.94,	109,775.11,	110,819.52,	111,866.25,	112,881.99,	113,882.901,	114,921.2,	115,972.4,	116,1025.96,	117,1081.92,	118,1140.28,	119,1201,	120,1264.03
giCP	ftgen	0, 0, 128, -17, 0,8.198,	16,8.198,	17,8.738,	18,9.26,	19,9.6,		20,10.37,	21,10.8889,	22,11.606,	23,12.18,	24,13.006,	25,13.681,	26,14.44,	27,15.27,	28,16.08,	29,17.026,	30,18.111,	31,19.103,	32,20.264,	33,21.4893,	34,22.68,	35,24.08,	36,25.43,	37,27.02,	38,28.5,	39,30.19,	40,32.08,	41,34.19,	42,35.98,	43,38.18,	44,40.3,	45,42.73,	46,45.32,	47,47.82,	48,50.6,	49,53.56,	50,56.6,	51,59.97,	52,63.4,	53,67.16,	54,71.11,	55,75.34,	56,79.550,	57,84.11,	58,88.870,	59,94.176,	60,99.42,	61,104.96,	62,111.51,	63,117.550,	64,124.382,	65,131.000,	66,138.704,	67,147.070,	68,154.617,	69,163.690,	70,173.640,	71,182.280,	72,193.050,	73,204.560,	74,216.790,	75,227.133,	76,240.660,	77,254.910,	78,270.080,	79,282.358,	80,299.040,	81,316.880,	82,335.660,	83,349.750,	84,370.420,	85,392.452,	86,415.640,	87,440.386,	88,456.274,	89,483.374,	90,511.980,	91,542.431,	92,574.379,	93,608.550,	94,626.050,	95,662.920,	96,702.160,	97,743.397,	98,787.520,	99,838.16,	100,881.300,	101,899.350,	102,958.290,	103,1010.900,	104,1067.740,	105,1126.700,	106,1198.630,	107,1267.480,	108,1340.940,	109,1378.15,	110,1440,	111,1521.86,	112,1608.16,	113,1608.16,	114,1794,	115,1893.7,	116,1998,	117,2107,	118,2220.7,	119,2338.9
giPP	ftgen	0, 0, 128, -17, 0,21.3,																23,21.3,	24,22.15,	25,23.1,	26,24.1259,	27,25.2,	28,26.35,	29,27.85,	30,29.5,	31,31.5,	32,33.4,	33,35.00,	34,37.5,	35,38.86,	36,41.87,	37,44.46,	38,47.15,	39,49.89,	40,52.550,	41,55.690,	42,58.950,	43,62.580,	44,66.310,	45,70.350,	46,74.280,	47,78.560,	48,83.590,	49,88.57,	50,93.83,	51,99.45,	52,105.37,	53,111.63,	54,118.35,	55,125.4,	56,132.95,	57,140.86,	58,149.24,	59,158.3,	60,167.7,	61,177.7,	62,188.5,	63,199.7,	64,211.6,	65,224.6,	66,237.94,	67,252.1,	68,267.06,	69,283.7,	70,300.56,	71,318.5,	72,337.35,	73,358.9,	74,380.14,	75,402.73,	76,426.7,	77,454.8,	78,481.8,	79,510.4,	80,540.72,	81,572.9,	82,606.9,	83,649.4,	84,687.94,	85,728.77,	86,772.01,	87,817.8,	88,866.3,	89,934.92,	90,990.31,	91,1049,	92,1111.05,	93,1176.78,	94,1246.35,	95,1319.99,	96,1455.78,	97,1541.65,	98,1632.488,	99,1728.6,	100,1830.17,	101,1937.6,	102,2051.15,	103,2171.14,	104,2297.9,	105,2735.71,	106,2894.65,	107,3062.34,	108,3239.16,	109,3425.51,	110,3621.76,	111,3828.29,	112,4045.44,	113,4273.54,	114,4512.87,	115,4763.67,	116,5026.14,	117,5300.32
giCF	ftgen	0, 0, 128, -17, 0,7.37,										20,7.37,	21,7.7,		22,8.2,		23,8.67,	24,9.2,		25,9.83,	26,10.3,	27,11,		28,11.5,	29,12.19,	30,12.92,	31,13.703,	32,14.547,	33,15.392,	34,16.368,	35,17.28,	36,18.211,	37,19.6,	38,20.8,	39,21.88,	40,23.24,	41,24.67,	42,26.111,	43,27.41,	44,29.6,	45,31.34,	46,33.2,	47,35.181,	48,37.27,	49,39.484,	50,41.828,	51,44.315,	52,46.945,	53,49.737,	54,52.69,	55,55.815,	56,59.133,	57,62.64,	58,66.365,	59,70.30,	60,74.48,	61,78.89,	62,83.58,	63,88.528,	64,93.792,	65,99.34,	66,105.245,	67,111.501,	68,118.087,	69,125.108,	70,132.486,	71,140.362,	72,148.704,	73,157.46,	74,166.81,	75,176.727,	76,187.098,	77,198.22,	78,209.991,	79,222.27,	80,235.47,	81,249.454,	82,264.266,	83,279.634,	84,296.24,	85,313.812,	86,332.43,	87,351.63,	88,372.48,	89,394.56,	90,417.93,	91,442.69,	92,468.04,	93,495.72,	94,525.03,	95,556.05,	96,588.88,	97,622.53,	98,659.21,	99,698.01,	100,739.04,	101,782.414,	102,828.27,	103,876.72,	104,928.98,	105,983.1,	106,1040.21,	107,1100.47,	108,1164.01,	109,1230.98,	110,1308.040,	111,1380.110,	112,1467.360,	113,1562.151,	114,1661.6,	115,1753.94,	116,1850.58,	117,1951.524,	118,2056.79,	119,2166.31,	120,2280,	121,2397.64
; NOTE RANGES FOR THE FOUR BOUNDARY CONDITIONS OPTIONS
giNoteRanges[]	fillarray 	17,120, 16,119, 23,117, 20,121

; POLYPHONY CONTROL
gkActiveNotes	init	0		; active notes (notes in release stage are disregarded)
giNoteTable	ftgen	0,0,128,-2,0	; note table indicating on/off status. Note number denoted by table index.
giPolyLimit	init	5

giVelFunc	ftgen	0,0,128,-16,.1,128,-1,1			; map note number to barmodel strike-velocity parameter
giWidFunc	ftgen	0,0,128,-16,0.7,128,8,8			; map note number to barmodel strike-width parameter to compensate for loss of power in higher notes
giWidVelScal	ftgen	0,0,128,-16,30000,128,-4,1000		; scaling of strike velocity according to strike width value. Strike velocity needs to be boosted if strike width is low.
; GUI GEN TABLES
giVelToPos	ftgen	2,0,128,-7,0.5,128,0			; map MIDI velocity to barmodel strike position parameter
giVelToTone	ftgen	3,0,128,-7,0.5,128,1			; map MIDI velocity to tone (LPF)
giVelToAmp	ftgen	4,0,128,-5,0.01,128,1			; map MIDI velocity to amplitude
giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope

giInterruptTime	init	0.2					; time it will take for amplitude to ramp down if a note is stopped on account of a polyphony limit violation

gisine		ftgen	0,0,4096,10,10

gasendL,gasendR	init	0

gkNoteTable[]	init	128

; UDO for an i-rate version of the 'scale' opcode
opcode	scale_i,i,iii
 ival,imax,imin	xin
 ival	=	(ival * (imax-imin)) + imin
	xout	ival
endop

; barmodel demands a high kr for high quality results whenever kscan>0, therefore it is embedded in a UDO which can dictate its own kr
opcode barmodel_ksmps,a,iiiikiiii
 ibcL, ibcR, iK, ib, kscan, iT30, ipos, iStrk, iwid	xin
 setksmps	1		; experiment with this value. Powers of 2 closer to 1 will result in higher quality results at the expense of CPU
 asig 	barmodel 	ibcL, ibcR, iK, ib,     kscan, iT30, ipos, iStrk, iwid 
 	xout		asig
endop

opcode pan2_ksmps,aa,aa
 asig,apan	xin
 setksmps	1		; experiment with this value. Powers of 2 closer to 1 will result in higher quality results at the expense of CPU
 kpan	downsamp	apan
 aL,aR	pan2	asig,kpan
	xout	aL,aR
endop


instr	1	; always on instrument. Read in widgets that will be used as global variables.
 kporttime	linseg	0,0.001,0.05
 gkscan		chnget	"scan"		
 kscan_x100	chnget	"scan_x100"
 if kscan_x100==1 then
  gkscan	*=	100
 endif
 gkScanMix	chnget	"ScanMix" 
 gkOutAmp	chnget	"OutAmp"
 gkOutAmp	portk	gkOutAmp,kporttime
 gkRndModAmt	chnget	"RndModAmt"
 gkRndModRte	chnget	"RndModRte"
 gkPanDepth	chnget	"PanDepth"
 gkRvbMix	chnget	"RvbMix"
 gkRvbSize	chnget	"RvbSize"
 gkDry		limit	(1-gkRvbMix)*2,0,1
 gkWet		limit	gkRvbMix*2,0,1
 gkKybdScal chnget  "KybdScal"
 
; ; TUNING
; ; TEST TONE
; gknote	init	60						; (used for diagnostics and tuning)
; gktrans	chnget	"trans"						; (used for diagnostics and tuning)
; kTestTone	chnget	"TestTone"					; (used for diagnostics and tuning)
; if kTestTone==1 then							; (used for diagnostics and tuning)
;  kTestVol	chnget	"TestVol"					; (used for diagnostics and tuning)
;  atest	poscil	kTestVol,cpsmidinn(gknote)*octave(gktrans),-1	; (used for diagnostics and tuning)
;  	outs	atest,atest						; (used for diagnostics and tuning)
; endif									; (used for diagnostics and tuning)
; 
; ; MIDI CONTROL OF OFFSET
; kup	ctrl7	1,1,0,10						; (used for diagnostics and tuning)
; kdn	ctrl7	1,2,0,10						; (used for diagnostics and tuning)
; kincr	=	0.0005 							; (used for diagnostics and tuning)
; gkoffset	chnget	"offset"					; (used for diagnostics and tuning)
; if kup>0 then								; (used for diagnostics and tuning)
;  chnset	gkoffset+(kincr*kup),"offset"				; (used for diagnostics and tuning)
; elseif kdn>0 then							; (used for diagnostics and tuning)
;  chnset	gkoffset-(kincr*kdn),"offset"				; (used for diagnostics and tuning)
; endif									; (used for diagnostics and tuning)
; 
; ; ZERO OFFSET
; kZeroOffset	chnget	"ZeroOffset"					; (used for diagnostics and tuning)
; ktrig	trigger	kZeroOffset,0.5,0					; (used for diagnostics and tuning)
; ktrig2	changed	gknote						; (used for diagnostics and tuning)
; if ktrig==1||ktrig2==1 then						; (used for diagnostics and tuning)
;  kzero		=	0					; (used for diagnostics and tuning)
;  chnset	kzero,"offset"						; (used for diagnostics and tuning)
; endif									; (used for diagnostics and tuning)
 
endin



instr	2	; receive midi note ons and offs
 inote	notnum								; midi note number
 ivel	veloc	0,1							; key velocity (0 to 1)
 ibc		chnget	"bc"						; Boundary Conditions selection (1,2,3 or 4)
 iNoteMin	=	giNoteRanges[(ibc*2)-2]				; minimum note number which has a corresponding mapping value for this boundary condition algorithm
 iNoteMax	=	giNoteRanges[(ibc*2)-1]				; maximum note number which has a corresponding mapping value for this boundary condition algorithm
 if inote>=iNoteMin && inote<=iNoteMax then
  	event_i	"i",3+(inote*0.001),0,3600,inote,ivel
  	;tableiw	1,inote,giNoteTable					; add note to the active notes table
	gkNoteTable[inote]	=	1
  giPolyLimit	chnget	"PolyLimit"
  
  kactive	active	p1			; scan active instances of this instrument
  if kactive>giPolyLimit&&giPolyLimit>0 then	; if polyphony limit has been exceeded...
   tablew	0,inote,giNoteTable		; remove this note number from the notes table
   turnoff2	3,1,1				; ...turn off the oldest note and allow it to release (interrupt release)
   turnoff2	p1,1,0				; turn off the oldest version of this instrument immediately
  endif
  
  krel	release					; scan for this note's MIDI release. 0 = active, 1 = released
  if (krel==1) then				; If this note has been released...
   ;tablew	0,inote,giNoteTable		; remove this note number from the notes table
	gkNoteTable[inote]	=	0
  endif
  
  if giPolyLimit>0 then				; bypass polyphony control if its value is zero
   gkActiveNotes	init	i(gkActiveNotes) + 1	; increment active notes counter at note start
   if gkActiveNotes>giPolyLimit then		; if the addition of this new note results in exceeding the polyphony limit...
    turnoff2	3,1,1				; ...turn off the oldest note and allow it to release (interrupt release)
    gkActiveNotes	limit	gkActiveNotes - 1,0,127	; decrement active notes counter
   endif
  else
   gkActiveNotes	=	0			; if no polyphony limit is being used (slider is set to zero) then leave ActiveNotes at zero 
  endif
 endif
 
endin



instr	3	; Sound producing instrument. Triggered from instrument 2.
 inote	=	p4
 ivel	=	p5
 ;kactive	table	inote,giNoteTable	; Read active value for this note from the table 1 = midi note down, 0 = midi note released
 kactive	=	gkNoteTable[p4]	
; ; TUNING
; ; REINIT
; kmetro	metro	8			; (used for diagnostics and tuning)
; if kmetro==1 then				; (used for diagnostics and tuning)
;  kchanged	changed	gkoffset		; (used for diagnostics and tuning)
;  if kchanged==1 then				; (used for diagnostics and tuning)
;   reinit RESTART				; (used for diagnostics and tuning)
;  endif					; (used for diagnostics and tuning)
; RESTART:					; (used for diagnostics and tuning)
; endif						; (used for diagnostics and tuning)
; 	chnset	inote,"note"			; (used for diagnostics and tuning)
; gknote	init	inote			; (used for diagnostics and tuning)

 iDurRatio  =       i(gkKybdScal) == 1 ? cpsmidinn(60)/cpsmidinn(inote) : 1     ; turn on or off keyboard scaling
 
 ib		    chnget	"b"			    ; damping
 ib         /=      iDurRatio
 irel		chnget	"rel"			; release time
 iT30		chnget	"T30"			; 30dB decay time
 iT30       *=      iDurRatio
 iT30_Hold	chnget	"T30_Hold"		; over-ride decay slider value (HOLD button)
 iT30		=	iT30_Hold == 1 ? 3600 : iT30	; if 'HOLD' button is active set T30 value to 3600 and ignore slider value
 ibc		chnget	"bc"			; boundary conditions selection (1,2,3 or 4)
 iwid		chnget	"wid"			; strike width
 ipos		tablei	ivel,giVelToPos,1	; map midi key velocity to strike position parameter
 itone		tablei	ivel,giVelToTone,1	; map midi key velocity to LPF cutoff frequency
 itone		scale_i	itone,14,4		; rescale 0 - 1 to 4 - 14 (oct format)
 iStrk		tablei	ivel,giVelToAmp,1	; map midi key velocity to strike velocity parameter

 ; STIFFNESS / PITCH
 if ibc==1 then		; if Clamped-Clamped
  ibcL	=	1
  ibcR	=	1 
  itab	=	giCC
 elseif ibc==2 then	; if Clamped-Pivoting
  ibcL	=	1
  ibcR	=	2
  itab	=	giCP
 elseif ibc==3 then	; if Pivoting-Pivoting
  ibcL	=	2
  ibcR	=	2
  itab	=	giPP
 elseif ibc==4 then	; if Clamped-Free
  ibcL	=	1
  ibcR	=	3
  itab	=	giCF  
 endif
 iK	table	inote,itab		; read note to stiffness mapping from the appropriate function table
 ;ioffset	chnget	"offset"	; (used for diagnostics and tuning)
 ;iK	=	iK + ioffset		; (used for diagnostics and tuning)
 chnset	iK,"output"
 
 ; VELOCITY SCALING (ACCORDING TO NOTE PLAYED). Lower notes need to have an attenuated velocity value
 iVelScal	table	inote,giVelFunc

 ; STRIKE WIDTH SCALING (ACCORDING TO NOTE PLAYED). Higher notes need to have an increased strike width value
 iWidScal	table	inote,giWidFunc
 iwid		=	iwid * iWidScal

 ; SCALE STRIKE VELOCITY ACCORDING TO STRIKE WIDTH 
 ivel	table	iwid,giWidVelScal,1
 
 ; MODULATION ENVELOPE
 iModEnvDur	chnget	"ModEnvDur"	; envelope duration
 kndx	linseg	0,iModEnvDur,1		; envelope reading index
 kModEnv	tablei	kndx,giModEnv,1	; read function
 kscan	=	gkscan * (kModEnv-0.01)	; multiply 'Rate' slider and 'Envelope'
 kporttime	linseg	0,0.05,0.1	; portamento time function
 kscan	portk	kscan, kporttime	; apply portamento smoothing (without this a click can sometimes result if scanning rate changes abruptly)
 
 ; RANDOM MODULATION
 kRandScan	rspline	0,gkRndModAmt,gkRndModRte,gkRndModRte*2	; splinic random modulation
 kscan	limit	kscan + kRandScan,0.01,10000			; added to the modulation rate value so far (and limited)
 
 ; BARMODELS
 if gkScanMix==0 then											; mix = 0
  asig 	barmodel_ksmps 	ibcL, ibcR, iK, ib,     0, iT30, ipos, ivel*iVelScal*iStrk, iwid 		; only one barmodel
 elseif gkScanMix>0 && (gkscan>0 || gkRndModAmt>0) then							; 0 < mix < 1
  asig 	barmodel_ksmps 	ibcL, ibcR, iK, ib,     0, iT30, ipos, ivel*iVelScal*iStrk, iwid 		; mix two barmodels
  asig2 	barmodel_ksmps 	ibcL, ibcR, iK, ib, kscan, iT30, ipos, ivel*iVelScal*iStrk, iwid	
  asig	ntrpol		asig, asig2, gkScanMix
 elseif gkScanMix==1 then										; mix = 1
  asig 	barmodel_ksmps 	ibcL, ibcR, iK, ib, kscan, iT30, ipos, ivel*iVelScal*iStrk, iwid 		; only one barmodel
 endif
 
 ; AMPLITUDE ATTACK ENVELOPE
 iAttAmt	chnget	"AttAmt"		; attack amount
 iAttTim	chnget	"AttTim"		; attack time
 aatt	init	1
 if iAttTim>0 then				; only create attack envelope if 'Time' is greater than zero 
  aatt	linseg		1-iAttAmt,iAttTim*iDurRatio,1
 endif
 asig	=	asig * aatt * gkOutAmp

 ; AMPLITUDE RELEASE ENVELOPE
 arel	init	1
 if kactive==0 then			; if the midi key that started this note has been released...
  arel	transeg	1,irel*iDurRatio,-4,0		; create a release envelope
  asig	=	asig * arel		; apply envelope
 endif
 kOffTrig	trigger	kactive,0.5,1	; sense when note key has been released
 kOffTrig	delayk	kOffTrig,irel	; kill note trigger delayed by normal release time to allow release segment to complete
 if kOffTrig==1 then			; when kill note trigger is finally received...
  turnoff				; turn note off
  if giPolyLimit>0 then			; ...if greater than zero
   gkActiveNotes	limit	gkActiveNotes - 1,0,127	; decrement active notes counter
  endif
 endif

 ; POLYPHONY INTERRUPT
 aInterrupt	linsegr	1,giInterruptTime,0		; if the note is forced to interrupt (due to polyphony limit violation) then this envelope will be triggered
 asig	=	asig * aInterrupt

 ; TONE CONTROL (LPF)
 aToneEnv	=	aatt*aInterrupt*arel		; cutoff frequency will follow attack, release and interrupt envelopes
 ahp,alp,abp,abr statevar asig, cpsoct(itone) * aToneEnv, 1
 asig	=	alp
 
 ; PANNING
 ;kpan	oscili	gkPanDepth,kscan*2,gisine		; panning follows scanning function (frequency doubled)
 ;aL,aR	pan2	asig, 0.5 + kpan
 apan	oscili	gkPanDepth,kscan*2,gisine		; panning follows scanning function (frequency doubled)
 aL,aR	pan2_ksmps	asig, 0.5 + apan
 
 if gkRvbMix>0 then
  gasendL	+=	aL * gkWet
  gasendR	+=	aR * gkWet
 endif
 
 	outs		aL*gkDry,aR*gkDry
endin



instr	80	; reverb
 if gkRvbMix>0 then		; if mix is zero, bypass reverb for efficiency
  aL,aR	reverbsc	gasendL,gasendR,gkRvbSize,4000
	outs		aL,aR
 	clear		gasendL,gasendR
 endif

 ; TURN LABELS ON OR OFF
 kOnTrig	trigger	gkRvbMix,0.005,0
 kOffTrig	trigger	gkRvbMix,0.005,1
 if kOnTrig==1 then
  chnset	"fontcolour(170,170,170)","ReverbLabel"
  chnset	"colour(170,170,170)","ReverbLine"
 elseif kOffTrig==1 then
  chnset	"fontcolour(30,30,30)","ReverbLabel" 
  chnset	"colour(30,30,30)","ReverbLine" 
 endif

 gkAttTim	chnget	"AttTim"
 kOnTrig	trigger	gkAttTim,0.0005,0
 kOffTrig	trigger	gkAttTim,0.0005,1
 if kOnTrig==1 then
  chnset	"fontcolour(170,170,170)","AttackLabel"
  chnset	"colour(170,170,170)","AttackLine"
 elseif kOffTrig==1 then
  chnset	"fontcolour(30,30,30)","AttackLabel" 
  chnset	"colour(30,30,30)","AttackLine" 
 endif

endin


instr	99
 kpreset	chnget	"preset"
 kpreset	init	1
 if changed(kpreset)==1 then
  reinit SET_PRESET
  SET_PRESET:
  ipreset	init	i(kpreset)
  if ipreset==1 then	; xylobar
   giVelToPos	ftgen	2,0,128,-7,0.5,128,0			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0.5,128,1			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.01,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	2, "bc"
		chnset	5.5, "T30"
		chnset	0, "T30_Hold"
		chnset	5.5, "rel"
   		chnset	0.4, "b"
		chnset	5, "PolyLimit"
		chnset	0.5, "wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	0.8, "OutAmp"
   		chnset	0,"ScanMix"
    		chnset	0.1,"scan"
  		chnset	0,"scan_x100"
		chnset	1, "ModEnvDur"
		chnset	0, "RndModAmt"
		chnset	0.1, "RndModRte"
		chnset	0, "PanDepth"

  elseif ipreset==2 then	; Scan Envelope
   giVelToPos	ftgen	2,0,128,-7,0,128,0.5			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0.5,128,1			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.5,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,2,512,0.01			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	1, "bc"
		chnset	7.4, "T30"
		chnset	0, "T30_Hold"
		chnset	0.32, "rel"
   		chnset	0.006, "b"
		chnset	2, "PolyLimit"
		chnset	0.5, "wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0, "RvbMix"
		chnset	0.8, "RvbSize"
   		chnset	0.2, "OutAmp"
		chnset	1,"ScanMix"
   		chnset	0.033,"scan"   		
   		chnset	1,"scan_x100"
		chnset	0.3, "ModEnvDur"
		chnset	0, "ModRndAmt"
		chnset	0, "ModRndRte"
		chnset	0, "PanDepth"

  elseif ipreset==3 then	; Soft Sustain
   giVelToPos	ftgen	2,0,128,-7,0.9,128,0.9			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0.5,128,0.9			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.5,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	3, "bc"
		chnset	7.4, "T30"
		chnset	1, "T30_Hold"
		chnset	2.50, "rel"
   		chnset	0.000, "b"
		chnset	5, "PolyLimit"
		chnset	0.5, "wid"
		chnset  1, "AttTim"
		chnset  1, "AttAmt"
		chnset	0.4, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	0.218, "OutAmp"
   		chnset	0.5,"ScanMix"
   		chnset	0.113,"scan"
   		chnset	0,"scan_x100"   		  		
		chnset	0.2, "RndModAmt"
		chnset	0.4, "RndModRte"
		chnset	0.5, "PanDepth"
		
  elseif ipreset==4 then	; Rhodes
   giVelToPos	ftgen	2,0,128,-7,0.5,128,0.9			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0.5,128,0.7			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.1,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	3, "bc"
		chnset	11.6, "T30"
		chnset	0, "T30_Hold"
		chnset	0.08, "rel"
   		chnset	0.038, "b"
		chnset	5, "PolyLimit"
		chnset	0.98 ,"wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	0.4, "OutAmp"
   		chnset	0,"ScanMix"
   		chnset	0.014,"scan"
   		chnset	1,"scan_x100"   		  		
		chnset	0, "RndModAmt"
		chnset	0.1, "RndModRte"
		chnset	0.420, "PanDepth"

  elseif ipreset==5 then	; Good Vibes
   giVelToPos	ftgen	2,0,128,-7,0.4,128,0.5			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0.5,128,0.7			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.5,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,0.8			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	3, "bc"
		chnset	16.6, "T30"
		chnset	0, "T30_Hold"
		chnset	0.3, "rel"
   		chnset	0.038, "b"
		chnset	5, "PolyLimit"
		chnset	0.54 ,"wid"
		chnset  0.005, "AttTim"
		chnset  1, "AttAmt"
		chnset	0, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	0.323, "OutAmp"
   		chnset	0.548,"ScanMix"
   		chnset	0.014,"scan"
   		chnset	1,"scan_x100"   		  		
		chnset	8.84, "ModEnvDur"
		chnset	0, "RndModAmt"
		chnset	0.1, "RndModRte"
		chnset	0.420, "PanDepth"

  elseif ipreset==6 then	; Bad Vibes
   giVelToPos	ftgen	2,0,128,-7,0,128,0.5			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,1,128,1			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.5,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,0.8			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	4, "bc"
		chnset	16.6, "T30"
		chnset	1, "T30_Hold"
		chnset	0.08, "rel"
   		chnset	0.038, "b"
		chnset	5, "PolyLimit"
		chnset	0.54 ,"wid"
		chnset  0.012, "AttTim"
		chnset  1, "AttAmt"
		chnset	0.21, "RvbMix"
		chnset	0.65, "RvbSize"
		chnset	0.058, "OutAmp"
   		chnset	1,"ScanMix"
   		chnset	0.007,"scan"
   		chnset	1,"scan_x100"   		  		
		chnset	8.84, "ModEnvDur"
		chnset	0.272, "RndModAmt"
		chnset	1.313, "RndModRte"
		chnset	0.420, "PanDepth"

  elseif ipreset==7 then	; Hard Beater
   giVelToPos	ftgen	2,0,128,-7,0.3,128,0			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0.5,128,1			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.01,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	1, "bc"
		chnset	3.0, "T30"
		chnset	0, "T30_Hold"
		chnset	3.00, "rel"
   		chnset	0.365, "b"
		chnset	4, "PolyLimit"
		chnset	0.47 ,"wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0, "RvbMix"
		chnset	0.25, "RvbSize"
		chnset	1.8, "OutAmp"
   		chnset	0,"ScanMix"
   		chnset	0.01,"scan"
   		chnset	0,"scan_x100"   		  		
		chnset	0.1, "ModEnvDur"
		chnset	0.0, "RndModAmt"
		chnset	0.01, "RndModRte"
		chnset	0.0, "PanDepth"

  elseif ipreset==8 then	; Stacking Plates
   giVelToPos	ftgen	2,0,128,-7,0.3,128,0			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,1,128,1			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.01,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	4, "bc"
		chnset	0.11, "T30"
		chnset	0, "T30_Hold"
		chnset	0.11, "rel"
   		chnset	0.269, "b"
		chnset	0, "PolyLimit"
		chnset	0.26 ,"wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	2.5, "OutAmp"
   		chnset	0,"ScanMix"
   		chnset	0.01,"scan"
   		chnset	0,"scan_x100"   		  		
		chnset	0.1, "ModEnvDur"
		chnset	0.0, "RndModAmt"
		chnset	0.01, "RndModRte"
		chnset	0.0, "PanDepth"

  elseif ipreset==9 then	; Bowed Plank
   giVelToPos	ftgen	2,0,128,-7,0.3,128,0			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,1,128,1			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.01,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	2, "bc"
		chnset	6, "T30"
		chnset	0, "T30_Hold"
		chnset	6, "rel"
   		chnset	0.144, "b"
		chnset	5, "PolyLimit"
		chnset	0.47 ,"wid"
		chnset  0.19, "AttTim"
		chnset  1, "AttAmt"
		chnset	0, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	2.1, "OutAmp"
   		chnset	0,"ScanMix"
   		chnset	0.01,"scan"
   		chnset	0,"scan_x100"   		  		
		chnset	0.1, "ModEnvDur"
		chnset	0.0, "RndModAmt"
		chnset	0.01, "RndModRte"
		chnset	0.0, "PanDepth"

  elseif ipreset==10 then	; Interference
   giVelToPos	ftgen	2,0,128,-7,0.33,128,0.1			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0.6,128,1			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.1,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,0.2			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	1, "bc"
		chnset	2.73, "T30"
		chnset	0, "T30_Hold"
		chnset	0.37, "rel"
   		chnset	0.011, "b"
		chnset	2, "PolyLimit"
		chnset	0.29 ,"wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	0.5, "OutAmp"
   		chnset	1,"ScanMix"
   		chnset	0.318,"scan"
   		chnset	1,"scan_x100"   		  		
		chnset	2.73, "ModEnvDur"
		chnset	0.0, "RndModAmt"
		chnset	0.01, "RndModRte"
		chnset	0.0, "PanDepth"

  elseif ipreset==11 then	; Ride Cymbal
   giVelToPos	ftgen	2,0,128,-7,0.33,128,0.1			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0,128,1			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.1,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	4, "bc"
		chnset	18.12, "T30"
		chnset	0, "T30_Hold"
		chnset	0.28, "rel"
   		chnset	0.028, "b"
		chnset	3, "PolyLimit"
		chnset	0.26 ,"wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0.25, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	0.3, "OutAmp"
   		chnset	1,"ScanMix"
   		chnset	1,"scan"
   		chnset	1,"scan_x100"   		  		
		chnset	10, "ModEnvDur"
		chnset	0.0, "RndModAmt"
		chnset	0.01, "RndModRte"
		chnset	0.0, "PanDepth"

  elseif ipreset==12 then	; Tubular Bell
   giVelToPos	ftgen	2,0,128,-7,0.33,128,0.1			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0,128,0.8			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.1,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,0.8			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	4, "bc"
		chnset	30, "T30"
		chnset	0, "T30_Hold"
		chnset	30, "rel"
   		chnset	0.001, "b"
		chnset	1, "PolyLimit"
		chnset	0.14 ,"wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0.25, "RvbMix"
		chnset	0.65, "RvbSize"
		chnset	0.5, "OutAmp"
   		chnset	0.352,"ScanMix"
   		chnset	0.178,"scan"
   		chnset	0,"scan_x100"   		  		
		chnset	10, "ModEnvDur"
		chnset	0.0, "RndModAmt"
		chnset	0.01, "RndModRte"
		chnset	0.15, "PanDepth"

  elseif ipreset==13 then	; Discord Bar
   giVelToPos	ftgen	2,0,128,-7,0.33,128,0.1			; map MIDI velocity to barmodel strike position parameter
   		chnset	"tablenumber(2)","table2"
   giVelToTone	ftgen	3,0,128,-7,0,128,0.8			; map MIDI velocity to tone (LPF)
   		chnset	"tablenumber(3)","table3"
   giVelToAmp	ftgen	4,0,128,-5,0.1,128,1			; map MIDI velocity to amplitude
   		chnset	"tablenumber(4)","table4"
   giModEnv	ftgen	5,0,512,-5,1,512,1			; modulation rate envelope
   		chnset	"tablenumber(5)","table5"
		chnset	4, "bc"
		chnset	2.95, "T30"
		chnset	0, "T30_Hold"
		chnset	0.28, "rel"
   		chnset	1.274, "b"
		chnset	1, "PolyLimit"
		chnset	0.26 ,"wid"
		chnset  0, "AttTim"
		chnset  0, "AttAmt"
		chnset	0.25, "RvbMix"
		chnset	0.8, "RvbSize"
		chnset	0.437, "OutAmp"
   		chnset	1,"ScanMix"
   		chnset	0.425,"scan"
   		chnset	1,"scan_x100"   		  		
		chnset	10, "ModEnvDur"
		chnset	0.0, "RndModAmt"
		chnset	0.01, "RndModRte"
		chnset	0, "PanDepth"

  endif
 endif 
endin

</CsInstruments>

<CsScore>
i 1  0 [3600*24*7]	; read in widgets
i 80 0 [3600*24*7]	; reverb
i 99 0 [3600*24*7]	; presets
</CsScore>

</CsoundSynthesizer>
; BassGuitar.csd
; Written by Iain McCurdy, 2011

; Physical model of a plucked string with a pickup point. 
; Model is created from first principles in order to implement some improvements over the existing Csound opcodes for plucked strings.
; A bandpass filter is employed within the delay buffer used to implement the pluck which facilitates filtering to specific harmonics. 
; Conventional damping effects are still possible when cutoff frequency ratio = 1.

<Cabbage>
form caption("Bass Guitar"), size(550, 200), pluginid("basg") style("legacy")

#define RSliderStyle # colour(150,205,150), textcolour("LightGreen"), outlinecolour(0,0,0), trackercolour(yellow)#

image    bounds(  0,  0,550,200),  colour("DarkGreen"), shape("sharp"), outlinecolour("white"), outlinethickness(3)
rslider  bounds( 10, 10, 60, 60),  text("Sustain"),      channel("feedback"), range(0.9,1, 0.999, 2, 0.001), $RSliderStyle
rslider  bounds( 70, 10, 60, 60),  text("Filt. Ratio"), channel("FiltRatio"), range(0.5, 32, 1, 0.5), $RSliderStyle
rslider  bounds(130, 10, 60, 60),  text("B.width"),     channel("bw"), range(1, 32, 16), $RSliderStyle
rslider  bounds(190, 10, 60, 60),  text("Att"),         channel("att"), range(0, 3, 1,0.5), $RSliderStyle
checkbox bounds(260, 20, 30, 30),  text("Legato")       channel("legato"),FontColour("LightGreen"), colour("yellow")  value(1)
label    bounds(252, 54, 43, 14),  text("Legato"), FontColour("LightGreen")
rslider  bounds(300, 10, 60, 60),  text("Leg.Speed"),        channel("LegSpeed"),  range(0.01,1,0.05,0.5), $RSliderStyle
rslider  bounds(360, 10, 60, 60),  text("Vib.Depth"),        channel("VibDep"),    range(0, 1, 0.25, 0.75, 0.001), $RSliderStyle
rslider  bounds(420, 10, 60, 60),  text("Vib.Rate"),         channel("VibRte"),    range(0.5, 20, 3, 0.5), $RSliderStyle
rslider  bounds(480, 10, 60, 60),  text("Level"),            channel("level"),     range(0, 1, 0.7), $RSliderStyle
hslider  bounds( 15, 70,525, 40),  text("Pickup Position"), channel("PickupPos"), range(0.01, 0.99, 0.1), $RSliderStyle
keyboard bounds(  5,115,540, 80)
</Cabbage>

<CsoundSynthesizer>

<CsOptions>
-dm0 -n -+rtmidi=null -M0
</CsOptions>

<CsInstruments>

sr 		= 	44100
ksmps 		= 	64
nchnls 		= 	2
0dbfs		=	1	;MAXIMUM AMPLITUDE
massign	0,2

gkNoteTrig	init	0
giwave	ftgen	0,0,4097,11,20,1,0.5	;waveform used by excitation (pluck) signal
gisine	ftgen	0,0,4097,10,1		;sine wave (used by lfos)

gkactive	init	0	; Will contain number of active instances of instr 3 when legato mode is chosen. NB. notes in release stage will not be regarded as active. 

;UDOs
;UDO for plucked electric string - using a UDO facilitates the use of ksmps=1 to improve sound quality
opcode	PluckedElectricString,a,aakkkak
	asig,acps,kcutoff,kbw,kfeedback,aPickupPos,kporttime	xin
	setksmps	1
	;smooth krate variables according to the local ksmps and kr
	
	kcutoff	portk		kcutoff,kporttime
	kbw	portk		kbw,kporttime
	
	acutoff	interp		kcutoff
	kcutoff	downsamp	acutoff
	abw	interp		kbw
	kbw	downsamp	abw
	kbw		limit	kcutoff*kbw,0.001,10000	;limit bandwidth values to prevent explosion
	aDelTim	limit	1/acps,0,1	;derive required delay time from cycles per second value (reciprocal) and limit range
		
	afb	init	0					;audio feedback signal used by delay buffer
	atap1	vdelay	asig+afb,aDelTim*aPickupPos*1000,1000	;tap 1. Nut

	atap2	vdelay	-atap1,aDelTim*(1-aPickupPos)*1000,1000	;tap 2, Tailpiece
	
	atap2	butbp	atap2,kcutoff,kbw			;bandpass filter (nb. within delay buffer)

	afb	=	atap2*-kfeedback			;create feedback signal to add to input for next iteration

		xout	atap1+atap2				;return audio to caller instrument. NB. audio at pickup is a mixture (with positive and negative interference) of wave reflected from the bridge and the nut (the two points of fixture of the string) 
endop

;UDO for lowpass filter attack enveloping - using a UDO permits setting ksmps=1 in order to improve sound quality
opcode	butlpsr,a,aii
	setksmps	1
	asig,icps,idur	xin
	kcfenv		expseg	icps,idur,15000,1,15000
	asig	butlp	asig,kcfenv
		xout	asig
endop

instr	1	;read in widgets - this instrument runs constantly during performance
	gkfeedback	chnget	"feedback"
	gkFiltRatio	chnget	"FiltRatio"
	gkbw		chnget	"bw"
	gkatt		chnget	"att"
	gklegato	chnget	"legato"
	gkLegSpeed	chnget	"LegSpeed"
	gkVibDep	chnget	"VibDep"
	gkVibRte	chnget	"VibRte"
	gklevel		chnget	"level"
	gkPickupPos	chnget	"PickupPos"
endin

instr	2	;triggered via MIDI
	gkNoteTrig	init	1	;at the beginning of a new note set note trigger flag to '1'
	icps		cpsmidi		;read in midi note pitch in cycles per second
	givel		veloc	0,1	;read in midi note velocity

	gkcps	=	icps		;update a global krate variable for note pitch

	if i(gklegato)==0 then		;if we are *not* in legato mode...
	 inum	notnum						; read midi note number (0 - 127)
	 	event_i	"i",p1+1+(inum*0.001),0,-1,icps		; call sound producing instr
	 krel	release						; release flag (1 when note is released, 0 otherwise)
	 if krel==1 then					; when note is released...
	  turnoff2	p1+1+(inum*0.001),4,1			; turn off the called instrument
	 endif							; end of conditional
	else				;otherwise... (i.e. legato mode)
	 iactive	=	i(gkactive)			;number of active notes of instr 3 (note in release are disregarded)
	 if iactive==0 then					;...if no notes are active
	  event_i	"i",p1+1,0,-1				;...start a new held note
	 endif
	endif
endin

instr	3
	kporttime	linseg	0,0.001,1		;portamento time function rises quickly from zero to a held value
	kporttime	=	kporttime*gkLegSpeed	;scale portamento time function with value from GUI knob widget
	
	if i(gklegato)==1 then				;if we are in legato mode...
	 krel	release					;sense when  note has been released
	 gkactive	=	1-krel			;if note is in release, gkactive=0, otherwise =1
	 kcps	portk	gkcps,kporttime			;apply portamento smooth to changes in note pitch (this will only have an effect in 'legato' mode)
	 acps	interp	kcps				;create a a-rate version of pitch (cycles per second)
	 kactive	active	p1-1			;...check number of active midi notes (previous instrument)
	 if kactive==0 then				;if no midi notes are active...
	  turnoff					;... turn this instrument off
	 endif
	else						;otherwise... (polyphonic / non-legato mode)
	 acps	=	p4		 		;pitch equal to the original note pitch
	endif
	
	aptr	line	0,1/i(gkcps),1			;pointer that will be used to read excitation signal waveform function table
	asig	tablei	aptr,giwave,1,0,0		;create excitation (pluck) signal
	asig	butlp	asig,cpsoct(4+(givel*8))	;lowpass filter excitation signal according to midi note velocity of this note 
	asig	buthp	asig,i(gkcps)			;highpass filter excitation signal (this could possibly be made adjustable using a GUI widget)
	
	kcutoff		limit	gkcps*gkFiltRatio,20,20000	;cutoff of frequency of the bandpass filter will be relative to the pitch of the note. Limit it to prevent out of range values that would cause filter expolosion.
	
	;In legato mode modulations are reinitialised
	if gkNoteTrig==1&&gklegato==1 then
	 reinit	RESTART_ENVELOPE
	endif
	RESTART_ENVELOPE:
	krise	linseg	0,0.3,0,1.5,1			;build-up envelope - modulations do not begin immediately
	rireturn
	arise	interp	krise				;interpolation prevents discontinuities (clicks) when oscili lfos are reinitialised
	avib	oscili	0.8*arise*gkVibDep,gkVibRte,gisine	;vibrato
	acps	=	acps*semitone(avib)
	atrm	oscili	0.8*arise*gkVibDep,gkVibRte,gisine,0	;tremolo

	gkPickupPos	portk	gkPickupPos,kporttime		;smooth changes made to pickup position slider
	aPickupPos	interp	gkPickupPos			;interpolate k-rate pickup position variable to create an a-rate version
	ares 		PluckedElectricString   asig, acps, kcutoff, gkbw, gkfeedback, aPickupPos,kporttime	;call UDO - using a UDO facilitates the use of a different ksmps value (ksmps=1 and kr=sr) to optimise sound quality
	
	aenv		linsegr	0.7,0.05,0			;amplitude envelope
	
	if i(gkatt)>0 then					;if attack time is anything greater than zero call the lowpass filter envelope
	 ares		butlpsr	ares,i(gkcps),i(gkatt)		;a UDO is used again to allow the use of ksmps=1
	endif
	
	ares		=	ares*aenv*(1+atrm)*gklevel	;scale amplitude of audio signal with envelope, tremolo and level knob widget
			outs	ares,ares
	gkNoteTrig	=	0				;reset new-note trigger (in case it was '1')
endin

</CsInstruments>

<CsScore>
i 1 0 [60*60*24*7]	;instrument that reads in widget data
</CsScore>

</CsoundSynthesizer>